Laravel 9.x

Laravel 9.x
Offline Documentation

Last updated on: Fri Oct 25 2024
Created & maintained by â€” Mohammad Nurul Islam (Shihan)

Page 1 of 1307

Laravel 9.x

Preface
Why PDF version?

As a full stack web (and backend service) developer, I often need to create api & admin interface for small to medium web
applications in shortest possible time. And due the expressive syntax & the rapid development tools provided, I find Laravel
to be very useful for this purpose.
Also for myself, I sometimes intensionally turn off internet while writing code to focus on work to meet deadline. During
that isolated time, I need offline versions of documentation of various tools, libraries and framework. Even though, for most
of the other tools, libraries & frameworks offline documentation is available, for Laravel it was never true. To solve this
issue, few years back I created & maintained offline downloadable documentation of all Laravel versions available then and
published via Leanpub as free (with 0.0 minimum price) for others, with scripted processing on the markdown files from the
Laravel documentation repo available in github. But, unfortunately with some successive policy changes by Leanpub
authority for the authors, it was becoming impossible for me to maintain already published versions or create new books
for new versions of Laravel. Also, due to professional requirement, I had to switch to various other technologies and didn't
had to work with Laravel for a few years. So, I eventually give up maintaining those Leanpub publications of Offline
Documentation of Laravel.
Recently I got back to Laravel for some new projects and missed the Offline Documentation again, while getting myself up
to date with new features available in new versions of Laravel. So, this time, instead of depending on third party publishing
platforms, I developed a new tool myself for automating the required processing and creation of PDFs from various
branches of the documentation repo. This file is result of one such conversion.
In laravel-docs-in-pdf repo, you can always find up-to-date
PDF files corresponding to documentation for each version of
Laravel and download copies for offline use. If you find these
PDF documentation files useful and want to show some
support, please give the repo a star and share with your
social/professional network.

You can also watch the repo
and/or follow me on Github,
Twitter or Linkedin, to get
notification about future
releases of the PDF version of
Laravel documentation.

Any kind of appreciation from the community will encourage & motivate me to continue maintaining this project
regularly. To show your generous support, you can of course

License & copyright

All the PDF files available in laravel-docs-in-pdf repo are licensed under The Unlicense license and available in public
domain. Feel free to copy, modify, distribute or whatever you want to do with these files.
But, please be aware that, the documentation content of all the PDF files (beside the cover & preface pages) are not
covered with this license and is licensed under the original license of Laravel documentation as defined in the original
documentation's repo.

Page 2 of 1307

Laravel 9.x

Prologue
Release Notes
Upgrade Guide
Contribution Guide
Getting Started
Installation
Configuration
Directory Structure
Frontend
Starter Kits
Deployment
Architecture Concepts
Request Lifecycle
Service Container
Service Providers
Facades
The Basics
Routing
Middleware
CSRF Protection
Controllers
Requests
Responses
Views
Blade Templates
Asset Bundling
URL Generation
Session
Validation
Error Handling
Logging
Digging Deeper
Artisan Console
Broadcasting
Cache
Collections
Contracts
Events
File Storage
Helpers
HTTP Client
Localization
Mail
Notifications
Package Development
Queues
Rate Limiting
Task Scheduling
Security

Table of Contents

Page 3 of 1307

Laravel 9.x

Authentication
Authorization
Email Verification
Encryption
Hashing
Password Reset
Database
Getting Started
Query Builder
Pagination
Migrations
Seeding
Redis
Eloquent ORM
Getting Started
Relationships
Collections
Mutators / Casts
API Resources
Serialization
Factories
Testing
Getting Started
HTTP Tests
Console Tests
Browser Tests
Database
Mocking
Packages
Breeze
Cashier (Stripe)
Cashier (Paddle)
Dusk
Envoy
Fortify
Homestead
Horizon
Jetstream
Mix
Octane
Passport
Pint
Sail
Sanctum
Scout
Socialite
Telescope
Valet
API Documentation

Page 4 of 1307

Laravel 9.x

Chapter 1

Prologue

Page 5 of 1307

Laravel 9.x

Release Notes

Versioning Scheme
Support Policy
Laravel 9

Versioning Scheme

Laravel and its other first-party packages follow Semantic Versioning. Major framework releases are released every year
(~February), while minor and patch releases may be released as often as every week. Minor and patch releases should
never contain breaking changes.
When referencing the Laravel framework or its components from your application or package, you should always use a
version constraint such as ^9.0 , since major releases of Laravel do include breaking changes. However, we strive to
always ensure you may update to a new major release in one day or less.
Named Arguments
Named arguments are not covered by Laravel's backwards compatibility guidelines. We may choose to rename function
arguments when necessary in order to improve the Laravel codebase. Therefore, using named arguments when calling
Laravel methods should be done cautiously and with the understanding that the parameter names may change in the
future.

Support Policy

For all Laravel releases, bug fixes are provided for 18 months and security fixes are provided for 2 years. For all additional
libraries, including Lumen, only the latest major release receives bug fixes. In addition, please review the database versions
supported by Laravel.
Version
6 (LTS)
7
8
9
10

PHP (*)
7.2 - 8.0
7.2 - 8.0
7.3 - 8.1
8.0 - 8.2
8.1 - 8.3

Release
September 3rd, 2019
March 3rd, 2020
September 8th, 2020
February 8th, 2022
February 14th, 2023

Bug Fixes Until
January 25th, 2022
October 6th, 2020
July 26th, 2022
August 8th, 2023
August 6th, 2024

Security Fixes Until
September 6th, 2022
March 3rd, 2021
January 24th, 2023
February 6th, 2024
February 4th, 2025

End of life
Security fixes only
(*) Supported PHP versions

Laravel 9

As you may know, Laravel transitioned to yearly releases with the release of Laravel 8. Previously, major versions were
released every 6 months. This transition is intended to ease the maintenance burden on the community and challenge our
development team to ship amazing, powerful new features without introducing breaking changes. Therefore, we have
shipped a variety of robust features to Laravel 8 without breaking backwards compatibility, such as parallel testing
support, improved Breeze starter kits, HTTP client improvements, and even new Eloquent relationship types such as "has
one of many".
Therefore, this commitment to ship great new features during the current release will likely lead to future "major" releases
being primarily used for "maintenance" tasks such as upgrading upstream dependencies, which can be seen in these
Page 6 of 1307

Laravel 9.x

release notes.
Laravel 9 continues the improvements made in Laravel 8.x by introducing support for Symfony 6.0 components, Symfony
Mailer, Flysystem 3.0, improved route:list output, a Laravel Scout database driver, new Eloquent accessor / mutator
syntax, implicit route bindings via Enums, and a variety of other bug fixes and usability improvements.

PHP 8.0

Laravel 9.x requires a minimum PHP version of 8.0.

Symfony Mailer

Symfony Mailer support was contributed by Dries Vints, James Brooks, and Julius Kiekbusch.
Previous releases of Laravel utilized the Swift Mailer library to send outgoing email. However, that library is no longer
maintained and has been succeeded by Symfony Mailer.
Please review the upgrade guide to learn more about ensuring your application is compatible with Symfony Mailer.

Flysystem 3.x

Flysystem 3.x support was contributed by Dries Vints.
Laravel 9.x upgrades our upstream Flysystem dependency to Flysystem 3.x. Flysystem powers all of filesystem interactions
offered by the Storage facade.
Please review the upgrade guide to learn more about ensuring your application is compatible with Flysystem 3.x.

Improved Eloquent Accessors / Mutators

Improved Eloquent accessors / mutators was contributed by Taylor Otwell.
Laravel 9.x offers a new way to define Eloquent accessors and mutators. In previous releases of Laravel, the only way to
define accessors and mutators was by defining prefixed methods on your model like so:
public function getNameAttribute($value)
{
return strtoupper($value);
}
public function setNameAttribute($value)
{
$this->attributes['name'] = $value;
}

However, in Laravel 9.x you may define an accessor and mutator using a single, non-prefixed method by type-hinting a
return type of Illuminate\Database\Eloquent\Casts\Attribute :
use Illuminate\Database\Eloquent\Casts\Attribute;
public function name(): Attribute
{
return new Attribute(
get: fn ($value) => strtoupper($value),
set: fn ($value) => $value,
);
}

Page 7 of 1307

Laravel 9.x

In addition, this new approach to defining accessors will cache object values that are returned by the attribute, just like
custom cast classes:
use App\Support\Address;
use Illuminate\Database\Eloquent\Casts\Attribute;
public function address(): Attribute
{
return new Attribute(
get: fn ($value, $attributes) => new Address(
$attributes['address_line_one'],
$attributes['address_line_two'],
),
set: fn (Address $value) => [
'address_line_one' => $value->lineOne,
'address_line_two' => $value->lineTwo,
],
);
}

Enum Eloquent Attribute Casting
Enum casting is only available for PHP 8.1+.
Enum casting was contributed by Mohamed Said.
Eloquent now allows you to cast your attribute values to PHP "backed" Enums. To accomplish this, you may specify the
attribute and enum you wish to cast in your model's $casts property array:
use App\Enums\ServerStatus;
/**
* The attributes that should be cast.
*
* @var array
*/
protected $casts = [
'status' => ServerStatus::class,
];

Once you have defined the cast on your model, the specified attribute will be automatically cast to and from an enum when
you interact with the attribute:
if ($server->status == ServerStatus::Provisioned) {
$server->status = ServerStatus::Ready;
$server->save();
}

Implicit Route Bindings With Enums
Page 8 of 1307

Laravel 9.x

Implicit Enum bindings was contributed by Nuno Maduro.
PHP 8.1 introduces support for Enums. Laravel 9.x introduces the ability to type-hint an Enum on your route definition and
Laravel will only invoke the route if that route segment is a valid Enum value in the URI. Otherwise, an HTTP 404 response
will be returned automatically. For example, given the following Enum:
enum Category: string
{
case Fruits = 'fruits';
case People = 'people';
}

You may define a route that will only be invoked if the {category} route segment is fruits or people . Otherwise, an
HTTP 404 response will be returned:
Route::get('/categories/{category}', function (Category $category) {
return $category->value;
});

Forced Scoping Of Route Bindings

Forced scoped bindings was contributed by Claudio Dekker.
In previous releases of Laravel, you may wish to scope the second Eloquent model in a route definition such that it must be
a child of the previous Eloquent model. For example, consider this route definition that retrieves a blog post by slug for a
specific user:
use App\Models\Post;
use App\Models\User;
Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
return $post;
});

When using a custom keyed implicit binding as a nested route parameter, Laravel will automatically scope the query to
retrieve the nested model by its parent using conventions to guess the relationship name on the parent. However, this
behavior was only previously supported by Laravel when a custom key was used for the child route binding.
However, in Laravel 9.x, you may now instruct Laravel to scope "child" bindings even when a custom key is not provided.
To do so, you may invoke the scopeBindings method when defining your route:
use App\Models\Post;
use App\Models\User;
Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
return $post;
})->scopeBindings();

Or, you may instruct an entire group of route definitions to use scoped bindings:

Page 9 of 1307

Laravel 9.x

Route::scopeBindings()->group(function () {
Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
return $post;
});
});

Controller Route Groups

Route group improvements were contributed by Luke Downing.
You may now use the controller method to define the common controller for all of the routes within the group. Then,
when defining the routes, you only need to provide the controller method that they invoke:
use App\Http\Controllers\OrderController;
Route::controller(OrderController::class)->group(function () {
Route::get('/orders/{id}', 'show');
Route::post('/orders', 'store');
});

Full Text Indexes / Where Clauses

Full text indexes and "where" clauses were contributed by Taylor Otwell and Dries Vints.
When using MySQL or PostgreSQL, the fullText method may now be added to column definitions to generate full text
indexes:
$table->text('bio')->fullText();

In addition, the whereFullText and orWhereFullText methods may be used to add full text "where" clauses to a
query for columns that have full text indexes. These methods will be transformed into the appropriate SQL for the
underlying database system by Laravel. For example, a MATCH AGAINST clause will be generated for applications utilizing
MySQL:
$users = DB::table('users')
->whereFullText('bio', 'web developer')
->get();

Laravel Scout Database Engine

The Laravel Scout database engine was contributed by Taylor Otwell and Dries Vints.
If your application interacts with small to medium sized databases or has a light workload, you may now use Scout's
"database" engine instead of a dedicated search service such as Algolia or MeiliSearch. The database engine will use
"where like" clauses and full text indexes when filtering results from your existing database to determine the applicable
search results for your query.
To learn more about the Scout database engine, consult the Scout documentation.

Rendering Inline Blade Templates

Rendering inline Blade templates was contributed by Jason Beggs. Rendering inline Blade components was contributed by
Toby Zerner.
Sometimes you may need to transform a raw Blade template string into valid HTML. You may accomplish this using the
render method provided by the Blade facade. The render method accepts the Blade template string and an
Page 10 of 1307

Laravel 9.x

optional array of data to provide to the template:
use Illuminate\Support\Facades\Blade;
return Blade::render('Hello, {{ $name }}', ['name' => 'Julian Bashir']);

Similarly, the renderComponent method may be used to render a given class component by passing the component
instance to the method:
use App\View\Components\HelloComponent;
return Blade::renderComponent(new HelloComponent('Julian Bashir'));

Slot Name Shortcut

Slot name shortcuts were contributed by Caleb Porzio.
In previous releases of Laravel, slot names were provided using a name attribute on the x-slot tag:
<x-alert>
<x-slot name="title">
Server Error
</x-slot>
<strong>Whoops!</strong> Something went wrong!
</x-alert>

However, beginning in Laravel 9.x, you may specify the slot's name using a convenient, shorter syntax:
<x-slot:title>
Server Error
</x-slot>

Checked / Selected Blade Directives

Checked and selected Blade directives were contributed by Ash Allen and Taylor Otwell.
For convenience, you may now use the @checked directive to easily indicate if a given HTML checkbox input is
"checked". This directive will echo checked if the provided condition evaluates to true :
<input type="checkbox"
name="active"
value="active"
@checked(old('active', $user->active)) />

Likewise, the @selected directive may be used to indicate if a given select option should be "selected":

Page 11 of 1307

Laravel 9.x

<select name="version">
@foreach ($product->versions as $version)
<option value="{{ $version }}" @selected(old('version') == $version)>
{{ $version }}
</option>
@endforeach
</select>

Bootstrap 5 Pagination Views

Bootstrap 5 pagination views were contributed by Jared Lewis.
Laravel now includes pagination views built using Bootstrap 5. To use these views instead of the default Tailwind views, you
may call the paginator's useBootstrapFive method within the boot method of your
App\Providers\AppServiceProvider class:
use Illuminate\Pagination\Paginator;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Paginator::useBootstrapFive();
}

Improved Validation Of Nested Array Data

Improved validation of nested array inputs was contributed by Steve Bauman.
Sometimes you may need to access the value for a given nested array element when assigning validation rules to the
attribute. You may now accomplish this using the Rule::forEach method. The forEach method accepts a closure that
will be invoked for each iteration of the array attribute under validation and will receive the attribute's value and explicit,
fully-expanded attribute name. The closure should return an array of rules to assign to the array element:
use App\Rules\HasPermission;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
$validator = Validator::make($request->all(), [
'companies.*.id' => Rule::forEach(function ($value, $attribute) {
return [
Rule::exists(Company::class, 'id'),
new HasPermission('manage-company', $value),
];
}),
]);

Laravel Breeze API & Next.js

The Laravel Breeze API scaffolding and Next.js starter kit was contributed by Taylor Otwell and Miguel Piedrafita.

Page 12 of 1307

Laravel 9.x

The Laravel Breeze starter kit has received an "API" scaffolding mode and complimentary Next.js frontend implementation.
This starter kit scaffolding may be used to jump start your Laravel applications that are serving as a backend, Laravel
Sanctum authenticated API for a JavaScript frontend.

Improved Ignition Exception Page

Ignition is developed by Spatie.
Ignition, the open source exception debug page created by Spatie, has been redesigned from the ground up. The new,
improved Ignition ships with Laravel 9.x and includes light / dark themes, customizable "open in editor" functionality, and
more.

Improved route:list CLI Output

Improved route:list CLI output was contributed by Nuno Maduro.
The route:list CLI output has been significantly improved for the Laravel 9.x release, offering a beautiful new
experience when exploring your route definitions.

Page 13 of 1307

Laravel 9.x

Test Coverage Using Artisan test Command

Test coverage when using the Artisan test command was contributed by Nuno Maduro.
The Artisan test command has received a new --coverage option that you may use to explore the amount of code
coverage your tests are providing to your application:
php artisan test --coverage

The test coverage results will be displayed directly within the CLI output.

In addition, if you would like to specify a minimum threshold that your test coverage percentage must meet, you may use
the --min option. The test suite will fail if the given minimum threshold is not met:
php artisan test --coverage --min=80.3

Page 14 of 1307

Laravel 9.x

Soketi Echo Server

The Soketi Echo server was developed by Alex Renoki.
Although not exclusive to Laravel 9.x, Laravel has recently assisted with the documentation of Soketi, a Laravel Echo
compatible Web Socket server written for Node.js. Soketi provides a great, open source alternative to Pusher and Ably for
those applications that prefer to manage their own Web Socket server.
For more information on using Soketi, please consult the broadcasting documentation and Soketi documentation.

Improved Collections IDE Support

Improved collections IDE support was contributed by Nuno Maduro.
Laravel 9.x adds improved, "generic" style type definitions to the collections component, improving IDE and static analysis
support. IDEs such as PHPStorm or static analysis tools such as PHPStan will now better understand Laravel collections
natively.

Page 15 of 1307

Laravel 9.x

New Helpers

Laravel 9.x introduces two new, convenient helper functions that you may use in your own application.
str

The str function returns a new Illuminate\Support\Stringable instance for the given string. This function is
equivalent to the Str::of method:
$string = str('Taylor')->append(' Otwell');
// 'Taylor Otwell'

If no argument is provided to the str function, the function returns an instance of Illuminate\Support\Str :
$snake = str()->snake('LaravelFramework');
// 'laravel_framework'

to_route

The to_route function generates a redirect HTTP response for a given named route, providing an expressive way to
redirect to named routes from your routes and controllers:
return to_route('users.show', ['user' => 1]);

Page 16 of 1307

Laravel 9.x

If necessary, you may pass the HTTP status code that should be assigned to the redirect and any additional response
headers as the third and fourth arguments to the to_route method:
return to_route('users.show', ['user' => 1], 302, ['X-Framework' => 'Laravel']);

Page 17 of 1307

Laravel 9.x

Upgrading To 9.0 From 8.x

Upgrade Guide

High Impact Changes
Updating Dependencies
Flysystem 3.x
Symfony Mailer

Medium Impact Changes

Belongs To Many firstOrNew , firstOrCreate , and updateOrCreate methods
Custom Casts & null
Default HTTP Client Timeout
PHP Return Types
Postgres "Schema" Configuration
The assertDeleted Method
The lang Directory
The password Rule
The when / unless Methods
Unvalidated Array Keys

Upgrading To 9.0 From 8.x
Estimated Upgrade Time: 30 Minutes

We attempt to document every possible breaking change. Since some of these breaking changes
are in obscure parts of the framework only a portion of these changes may actually affect your
application. Want to save time? You can use Laravel Shift to help automate your application
upgrades.

Updating Dependencies
Likelihood Of Impact: High

PHP 8.0.2 Required
Laravel now requires PHP 8.0.2 or greater.
Composer Dependencies
You should update the following dependencies in your application's composer.json file:
laravel/framework to ^9.0
nunomaduro/collision to ^6.1
In addition, please replace facade/ignition with "spatie/laravel-ignition": "^1.0" and pusher/pusherphp-server (if applicable) with "pusher/pusher-php-server": "^5.0" in your application's composer.json file.
Furthermore, the following first-party packages have received new major releases to support Laravel 9.x. If applicable, you
should read their individual upgrade guides before upgrading:
Vonage Notification Channel (v3.0) (Replaces Nexmo)
Page 18 of 1307

Laravel 9.x

Finally, examine any other third-party packages consumed by your application and verify you are using the proper version
for Laravel 9 support.
PHP Return Types
PHP is beginning to transition to requiring return type definitions on PHP methods such as offsetGet , offsetSet , etc.
In light of this, Laravel 9 has implemented these return types in its code base. Typically, this should not affect user written
code; however, if you are overriding one of these methods by extending Laravel's core classes, you will need to add these
return types to your own application or package code:
count(): int
getIterator(): Traversable
getSize(): int
jsonSerialize(): array
offsetExists($key): bool
offsetGet($key): mixed
offsetSet($key, $value): void
offsetUnset($key): void

In addition, return types were added to methods implementing PHP's SessionHandlerInterface . Again, it is unlikely
that this change affects your own application or package code:
open($savePath, $sessionName): bool
close(): bool
read($sessionId): string|false
write($sessionId, $data): bool
destroy($sessionId): bool
gc($lifetime): int

Application

The Application Contract
Likelihood Of Impact: Low
The storagePath method of the Illuminate\Contracts\Foundation\Application interface has been updated to
accept a $path argument. If you are implementing this interface you should update your implementation accordingly:
public function storagePath($path = '');

Similarly, the langPath method of the Illuminate\Foundation\Application class has been updated to accept a
$path argument:
public function langPath($path = '');

Exception Handler ignore Method
Likelihood Of Impact: Low
The exception handler's ignore method is now public instead of protected . This method is not included in the
default application skeleton; however, if you have manually defined this method you should update its visibility to
public :
public function ignore(string $class);

Exception Handler Contract Binding
Likelihood Of Impact: Very Low
Page 19 of 1307

Laravel 9.x

Previously, in order to override the default Laravel exception handler, custom implementations were bound into the service
container using the \App\Exceptions\Handler::class type. However, you should now bind custom implementations
using the \Illuminate\Contracts\Debug\ExceptionHandler::class type.

Blade

Lazy Collections & The $loop Variable
Likelihood Of Impact: Low
When iterating over a LazyCollection instance within a Blade template, the $loop variable is no longer available, as
accessing this variable causes the entire LazyCollection to be loaded into memory, thus rendering the usage of lazy
collections pointless in this scenario.
Checked / Disabled / Selected Blade Directives
Likelihood Of Impact: Low
The new @checked , @disabled , and @selected Blade directives may conflict with Vue events of the same name. You
may use @@ to escape the directives and avoid this conflict: @@selected .

Collections

The Enumerable Contract
Likelihood Of Impact: Low
The Illuminate\Support\Enumerable contract now defines a sole method. If you are manually implementing this
interface, you should update your implementation to reflect this new method:
public function sole($key = null, $operator = null, $value = null);

The reduceWithKeys Method
The reduceWithKeys method has been removed as the reduce method provides the same functionality. You may
simply update your code to call reduce instead of reduceWithKeys .
The reduceMany Method
The reduceMany method has been renamed to reduceSpread for naming consistency with other similar methods.

Container

The Container Contract
Likelihood Of Impact: Very Low
The Illuminate\Contracts\Container\Container contract has received two method definitions: scoped and
scopedIf . If you are manually implementing this contract, you should update your implementation to reflect these new
methods.
The ContextualBindingBuilder Contract
Likelihood Of Impact: Very Low
The Illuminate\Contracts\Container\ContextualBindingBuilder contract now defines a giveConfig method. If
you are manually implementing this interface, you should update your implementation to reflect this new method:
public function giveConfig($key, $default = null);

Page 20 of 1307

Laravel 9.x

Database

Postgres "Schema" Configuration
Likelihood Of Impact: Medium
The schema configuration option used to configure Postgres connection search paths in your application's
config/database.php configuration file should be renamed to search_path .
Schema Builder registerCustomDoctrineType Method
Likelihood Of Impact: Low
The registerCustomDoctrineType method has been removed from the Illuminate\Database\Schema\Builder
class. You may use the registerDoctrineType method on the DB facade instead, or register custom Doctrine types in
the config/database.php configuration file.

Eloquent

Custom Casts & null
Likelihood Of Impact: Medium
In previous releases of Laravel, the set method of custom cast classes was not invoked if the cast attribute was being
set to null . However, this behavior was inconsistent with the Laravel documentation. In Laravel 9.x, the set method of
the cast class will be invoked with null as the provided $value argument. Therefore, you should ensure your custom
casts are able to sufficiently handle this scenario:
/**
* Prepare the given value for storage.
*
* @param

\Illuminate\Database\Eloquent\Model

* @param

string

* @param

AddressModel

* @param

array

$model

$key
$value

$attributes

* @return array
*/
public function set($model, $key, $value, $attributes)
{
if (! $value instanceof AddressModel) {
throw new InvalidArgumentException('The given value is not an Address instance.');
}
return [
'address_line_one' => $value->lineOne,
'address_line_two' => $value->lineTwo,
];
}

Belongs To Many firstOrNew , firstOrCreate , and updateOrCreate Methods
Likelihood Of Impact: Medium
The belongsToMany relationship's firstOrNew , firstOrCreate , and updateOrCreate methods all accept an
array of attributes as their first argument. In previous releases of Laravel, this array of attributes was compared against the
"pivot" / intermediate table for existing records.
However, this behavior was unexpected and typically unwanted. Instead, these methods now compare the array of
attributes against the table of the related model:
Page 21 of 1307

Laravel 9.x

$user->roles()->updateOrCreate([
'name' => 'Administrator',
]);

In addition, the firstOrCreate method now accepts a $values array as its second argument. This array will be
merged with the first argument to the method ( $attributes ) when creating the related model if one does not already
exist. This change makes this method consistent with the firstOrCreate methods offered by other relationship types:
$user->roles()->firstOrCreate([
'name' => 'Administrator',
], [
'created_by' => $user->id,
]);

The touch Method
Likelihood Of Impact: Low
The touch method now accepts an attribute to touch. If you were previously overwriting this method, you should update
your method signature to reflect this new argument:
public function touch($attribute = null);

Encryption

The Encrypter Contract
Likelihood Of Impact: Low
The Illuminate\Contracts\Encryption\Encrypter contract now defines a getKey method. If you are manually
implementing this interface, you should update your implementation accordingly:
public function getKey();

Facades

The getFacadeAccessor Method
Likelihood Of Impact: Low
The getFacadeAccessor method must always return a container binding key. In previous releases of Laravel, this
method could return an object instance; however, this behavior is no longer supported. If you have written your own
facades, you should ensure that this method returns a container binding string:
/**
* Get the registered name of the component.
*
* @return string
*/
protected static function getFacadeAccessor()
{
return Example::class;
}

Page 22 of 1307

Laravel 9.x

Filesystem

The FILESYSTEM_DRIVER Environment Variable
Likelihood Of Impact: Low
The FILESYSTEM_DRIVER environment variable has been renamed to FILESYSTEM_DISK to more accurately reflect its
usage. This change only affects the application skeleton; however, you are welcome to update your own application's
environment variables to reflect this change if you wish.
The "Cloud" Disk
Likelihood Of Impact: Low
The cloud disk configuration option was removed from the default application skeleton in November of 2020. This
change only affects the application skeleton. If you are using the cloud disk within your application, you should leave
this configuration value in your own application's skeleton.

Flysystem 3.x

Likelihood Of Impact: High
Laravel 9.x has migrated from Flysystem 1.x to 3.x. Under the hood, Flysystem powers all of the file manipulation methods
provided by the Storage facade. In light of this, some changes may be required within your application; however, we
have tried to make this transition as seamless as possible.
Driver Prerequisites
Before using the S3, FTP, or SFTP drivers, you will need to install the appropriate package via the Composer package
manager:
Amazon S3: composer require -W league/flysystem-aws-s3-v3 "^3.0"
FTP: composer require league/flysystem-ftp "^3.0"
SFTP: composer require league/flysystem-sftp-v3 "^3.0"
Overwriting Existing Files
Write operations such as put , write , and writeStream now overwrite existing files by default. If you do not want to
overwrite existing files, you should manually check for the file's existence before performing the write operation.
Write Exceptions
Write operations such as put , write , and writeStream no longer throw an exception when a write operation fails.
Instead, false is returned. If you would like to preserve the previous behavior which threw exceptions, you may define
the throw option within a filesystem disk's configuration array:
'public' => [
'driver' => 'local',
// ...
'throw' => true,
],

Reading Missing Files
Attempting to read from a file that does not exist now returns null . In previous releases of Laravel, an
Illuminate\Contracts\Filesystem\FileNotFoundException would have been thrown.
Deleting Missing Files
Attempting to delete a file that does not exist now returns true .

Page 23 of 1307

Laravel 9.x

Cached Adapters
Flysystem no longer supports "cached adapters". Thus, they have been removed from Laravel and any relevant
configuration (such as the cache key within disk configurations) can be removed.
Custom Filesystems
Slight changes have been made to the steps required to register custom filesystem drivers. Therefore, if you were defining
your own custom filesystem drivers, or using packages that define custom drivers, you should update your code and
dependencies.
For example, in Laravel 8.x, a custom filesystem driver might be registered like so:
use Illuminate\Support\Facades\Storage;
use League\Flysystem\Filesystem;
use Spatie\Dropbox\Client as DropboxClient;
use Spatie\FlysystemDropbox\DropboxAdapter;
Storage::extend('dropbox', function ($app, $config) {
$client = new DropboxClient(
$config['authorization_token']
);
return new Filesystem(new DropboxAdapter($client));
});

However, in Laravel 9.x, the callback given to the Storage::extend method should return an instance of
Illuminate\Filesystem\FilesystemAdapter directly:
use Illuminate\Filesystem\FilesystemAdapter;
use Illuminate\Support\Facades\Storage;
use League\Flysystem\Filesystem;
use Spatie\Dropbox\Client as DropboxClient;
use Spatie\FlysystemDropbox\DropboxAdapter;
Storage::extend('dropbox', function ($app, $config) {
$adapter = new DropboxAdapter(
new DropboxClient($config['authorization_token'])
);
return new FilesystemAdapter(
new Filesystem($adapter, $config),
$adapter,
$config
);
});

SFTP Private-Public Key Passphrase
If your application is using Flysystem's SFTP adapter and private-public key authentication, the password configuration
item that is used to decrypt the private key should be renamed to passphrase .

Helpers

The data_get Helper & Iterable Objects
Likelihood Of Impact: Very Low
Page 24 of 1307

Laravel 9.x

Previously, the data_get helper could be used to retrieve nested data on arrays and Collection instances; however,
this helper can now retrieve nested data on all iterable objects.
The str Helper
Likelihood Of Impact: Very Low
Laravel 9.x now includes a global str helper function. If you are defining a global str helper in your application, you
should rename or remove it so that it does not conflict with Laravel's own str helper.
The when / unless Methods
Likelihood Of Impact: Medium
As you may know, when and unless methods are offered by various classes throughout the framework. These methods
can be used to conditionally perform an action if the boolean value of the first argument to the method evaluates to true
or false :
$collection->when(true, function ($collection) {
$collection->merge([1, 2, 3]);
});

Therefore, in previous releases of Laravel, passing a closure to the when or unless methods meant that the conditional
operation would always execute, since a loose comparison against a closure object (or any other object) always evaluates
to true . This often led to unexpected outcomes because developers expect the result of the closure to be used as the
boolean value that determines if the conditional action executes.
So, in Laravel 9.x, any closures passed to the when or unless methods will be executed and the value returned by the
closure will be considered the boolean value used by the when and unless methods:
$collection->when(function ($collection) {
// This closure is executed...
return false;
}, function ($collection) {
// Not executed since first closure returned "false"...
$collection->merge([1, 2, 3]);
});

HTTP Client

Default Timeout
Likelihood Of Impact: Medium
The HTTP client now has a default timeout of 30 seconds. In other words, if the server does not respond within 30
seconds, an exception will be thrown. Previously, no default timeout length was configured on the HTTP client, causing
requests to sometimes "hang" indefinitely.
If you wish to specify a longer timeout for a given request, you may do so using the timeout method:
$response = Http::timeout(120)->get(/* ... */);

HTTP Fake & Middleware
Likelihood Of Impact: Low
Previously, Laravel would not execute any provided Guzzle HTTP middleware when the HTTP client was "faked". However,
in Laravel 9.x, Guzzle HTTP middleware will be executed even when the HTTP client is faked.
Page 25 of 1307

Laravel 9.x

HTTP Fake & Dependency Injection
Likelihood Of Impact: Low
In previous releases of Laravel, invoking the Http::fake() method would not affect instances of the
Illuminate\Http\Client\Factory that were injected into class constructors. However, in Laravel 9.x, Http::fake()
will ensure fake responses are returned by HTTP clients injected into other services via dependency injection. This
behavior is more consistent with the behavior of other facades and fakes.

Symfony Mailer

Likelihood Of Impact: High
One of the largest changes in Laravel 9.x is the transition from SwiftMailer, which is no longer maintained as of December
2021, to Symfony Mailer. However, we have tried to make this transition as seamless as possible for your applications. That
being said, please thoroughly review the list of changes below to ensure your application is fully compatible.
Driver Prerequisites
To continue using the Mailgun transport, your application should require the symfony/mailgun-mailer and
symfony/http-client Composer packages:
composer require symfony/mailgun-mailer symfony/http-client

The wildbit/swiftmailer-postmark Composer package should be removed from your application. Instead, your
application should require the symfony/postmark-mailer and symfony/http-client Composer packages:
composer require symfony/postmark-mailer symfony/http-client

Updated Return Types
The send , html , raw , and plain methods on Illuminate\Mail\Mailer no longer return void . Instead, an
instance of Illuminate\Mail\SentMessage is returned. This object contains an instance of
Symfony\Component\Mailer\SentMessage that is accessible via the getSymfonySentMessage method or by
dynamically invoking methods on the object.
Renamed "Swift" Methods
Various SwiftMailer related methods, some of which were undocumented, have been renamed to their Symfony Mailer
counterparts. For example, the withSwiftMessage method has been renamed to withSymfonyMessage :
// Laravel 8.x...
$this->withSwiftMessage(function ($message) {
$message->getHeaders()->addTextHeader(
'Custom-Header', 'Header Value'
);
});
// Laravel 9.x...
use Symfony\Component\Mime\Email;
$this->withSymfonyMessage(function (Email $message) {
$message->getHeaders()->addTextHeader(
'Custom-Header', 'Header Value'
);
});

Page 26 of 1307

Laravel 9.x

Please thoroughly review the Symfony Mailer documentation for all possible interactions with the
Symfony\Component\Mime\Email object.
The list below contains a more thorough overview of renamed methods. Many of these methods are low-level methods
used to interact with SwiftMailer / Symfony Mailer directly, so may not be commonly used within most Laravel applications:
Message::getSwiftMessage();
Message::getSymfonyMessage();
Mailable::withSwiftMessage($callback);
Mailable::withSymfonyMessage($callback);
MailMessage::withSwiftMessage($callback);
MailMessage::withSymfonyMessage($callback);
Mailer::getSwiftMailer();
Mailer::getSymfonyTransport();
Mailer::setSwiftMailer($swift);
Mailer::setSymfonyTransport(TransportInterface $transport);
MailManager::createTransport($config);
MailManager::createSymfonyTransport($config);

Proxied Illuminate\Mail\Message Methods
The Illuminate\Mail\Message typically proxied missing methods to the underlying Swift_Message instance.
However, missing methods are now proxied to an instance of Symfony\Component\Mime\Email instead. So, any code
that was previously relying on missing methods to be proxied to SwiftMailer should be updated to their corresponding
Symfony Mailer counterparts.
Again, many applications may not be interacting with these methods, as they are not documented within the Laravel
documentation:
// Laravel 8.x...
$message
->setFrom('taylor@laravel.com')
->setTo('example@example.org')
->setSubject('Order Shipped')
->setBody('<h1>HTML</h1>', 'text/html')
->addPart('Plain Text', 'text/plain');
// Laravel 9.x...
$message
->from('taylor@laravel.com')
->to('example@example.org')
->subject('Order Shipped')
->html('<h1>HTML</h1>')
->text('Plain Text');

Generated Messages IDs

Page 27 of 1307

Laravel 9.x

SwiftMailer offered the ability to define a custom domain to include in generated Message IDs via the
mime.idgenerator.idright configuration option. This is not supported by Symfony Mailer. Instead, Symfony Mailer will
automatically generate a Message ID based on the sender.
Event Changes
The message property of the Illuminate\Mail\Events\MessageSent event now contains an instance of
Symfony\Component\Mime\Email instead of an instance of Swift_Message . This message represents the email
before it is sent.
Additionally, a new sent property has been added to the MessageSent event. This property contains an instance of
Illuminate\Mail\SentMessage and contains information about the sent email, such as the message ID.
MessageSent

Forced Reconnections
It is no longer possible to force a transport reconnection (for example when the mailer is running via a daemon process).
Instead, Symfony Mailer will attempt to reconnect to the transport automatically and throw an exception if the reconnection
fails.
SMTP Stream Options
Defining stream options for the SMTP transport is no longer supported. Instead, you must define the relevant options
directly within the configuration if they are supported. For example, to disable TLS peer verification:
'smtp' => [
// Laravel 8.x...
'stream' => [
'ssl' => [
'verify_peer' => false,
],
],
// Laravel 9.x...
'verify_peer' => false,
],

To learn more about the available configuration options, please review the Symfony Mailer documentation.
In spite of the example above, you are not generally advised to disable SSL verification since it
introduces the possibility of "man-in-the-middle" attacks.
SMTP auth_mode
Defining the SMTP auth_mode in the mail configuration file is no longer required. The authentication mode will be
automatically negotiated between Symfony Mailer and the SMTP server.
Failed Recipients
It is no longer possible to retrieve a list of failed recipients after sending a message. Instead, a
Symfony\Component\Mailer\Exception\TransportExceptionInterface exception will be thrown if a message fails
to send. Instead of relying on retrieving invalid email addresses after sending a message, we recommend that you validate
email addresses before sending the message instead.

Packages
Page 28 of 1307

Laravel 9.x

The lang Directory
Likelihood Of Impact: Medium
In new Laravel applications, the resources/lang directory is now located in the root project directory ( lang ). If your
package is publishing language files to this directory, you should ensure that your package is publishing to app()>langPath() instead of a hard-coded path.

Queue

The opis/closure Library
Likelihood Of Impact: Low
Laravel's dependency on opis/closure has been replaced by laravel/serializable-closure . This should not
cause any breaking change in your application unless you are interacting with the opis/closure library directly. In
addition, the previously deprecated Illuminate\Queue\SerializableClosureFactory and
Illuminate\Queue\SerializableClosure classes have been removed. If you are interacting with opis/closure
library directly or using any of the removed classes, you may use Laravel Serializable Closure instead.
The Failed Job Provider flush Method
Likelihood Of Impact: Low
The flush method defined by the Illuminate\Queue\Failed\FailedJobProviderInterface interface now accepts
an $hours argument which determines how old a failed job must be (in hours) before it is flushed by the queue:flush
command. If you are manually implementing the FailedJobProviderInterface you should ensure that your
implementation is updated to reflect this new argument:
public function flush($hours = null);

Session

The getSession Method
Likelihood Of Impact: Low
The Symfony\Component\HttpFoundaton\Request class that is extended by Laravel's own
Illuminate\Http\Request class offers a getSession method to get the current session storage handler. This
method is not documented by Laravel as most Laravel applications interact with the session through Laravel's own
session method.
The getSession method previously returned an instance of Illuminate\Session\Store or null ; however, due to
the Symfony 6.x release enforcing a return type of
Symfony\Component\HttpFoundation\Session\SessionInterface , the getSession now correctly returns a
SessionInterface implementation or throws an
\Symfony\Component\HttpFoundation\Exception\SessionNotFoundException exception when no session is
available.

Testing

The assertDeleted Method
Likelihood Of Impact: Medium
All calls to the assertDeleted method should be updated to assertModelMissing .

Trusted Proxies

Likelihood Of Impact: Low
Page 29 of 1307

Laravel 9.x

If you are upgrading your Laravel 8 project to Laravel 9 by importing your existing application code into a totally new
Laravel 9 application skeleton, you may need to update your application's "trusted proxy" middleware.
Within your app/Http/Middleware/TrustProxies.php file, update use Fideloper\Proxy\TrustProxies as
Middleware to use Illuminate\Http\Middleware\TrustProxies as Middleware .
Next, within app/Http/Middleware/TrustProxies.php , you should update the $headers property definition:
// Before...
protected $headers = Request::HEADER_X_FORWARDED_ALL;
// After...
protected $headers =
Request::HEADER_X_FORWARDED_FOR |
Request::HEADER_X_FORWARDED_HOST |
Request::HEADER_X_FORWARDED_PORT |
Request::HEADER_X_FORWARDED_PROTO |
Request::HEADER_X_FORWARDED_AWS_ELB;

Finally, you can remove the fideloper/proxy Composer dependency from your application:
composer remove fideloper/proxy

Validation

Form Request validated Method
Likelihood Of Impact: Low
The validated method offered by form requests now accepts $key and $default arguments. If you are manually
overwriting the definition of this method, you should update your method's signature to reflect these new arguments:
public function validated($key = null, $default = null)

The password Rule
Likelihood Of Impact: Medium
The password rule, which validates that the given input value matches the authenticated user's current password, has
been renamed to current_password .
Unvalidated Array Keys
Likelihood Of Impact: Medium
In previous releases of Laravel, you were required to manually instruct Laravel's validator to exclude unvalidated array keys
from the "validated" data it returns, especially in combination with an array rule that does not specify a list of allowed
keys.
However, in Laravel 9.x, unvalidated array keys are always excluded from the "validated" data even when no allowed keys
have been specified via the array rule. Typically, this behavior is the most expected behavior and the previous
excludeUnvalidatedArrayKeys method was only added to Laravel 8.x as a temporary measure in order to preserve
backwards compatibility.
Although it is not recommended, you may opt-in to the previous Laravel 8.x behavior by invoking a new
includeUnvalidatedArrayKeys method within the boot method of one of your application's service providers:

Page 30 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Validator;
/**
* Register any application services.
*
* @return void
*/
public function boot()
{
Validator::includeUnvalidatedArrayKeys();
}

Miscellaneous

We also encourage you to view the changes in the laravel/laravel GitHub repository. While many of these changes
are not required, you may wish to keep these files in sync with your application. Some of these changes will be covered in
this upgrade guide, but others, such as changes to configuration files or comments, will not be. You can easily view the
changes with the GitHub comparison tool and choose which updates are important to you.

Page 31 of 1307

Laravel 9.x

Contribution Guide

Bug Reports
Support Questions
Core Development Discussion
Which Branch?
Compiled Assets
Security Vulnerabilities
Coding Style
PHPDoc
StyleCI
Code of Conduct

Bug Reports

To encourage active collaboration, Laravel strongly encourages pull requests, not just bug reports. Pull requests will only
be reviewed when marked as "ready for review" (not in the "draft" state) and all tests for new features are passing.
Lingering, non-active pull requests left in the "draft" state will be closed after a few days.
However, if you file a bug report, your issue should contain a title and a clear description of the issue. You should also
include as much relevant information as possible and a code sample that demonstrates the issue. The goal of a bug report
is to make it easy for yourself - and others - to replicate the bug and develop a fix.
Remember, bug reports are created in the hope that others with the same problem will be able to collaborate with you on
solving it. Do not expect that the bug report will automatically see any activity or that others will jump to fix it. Creating a
bug report serves to help yourself and others start on the path of fixing the problem. If you want to chip in, you can help
out by fixing any bugs listed in our issue trackers. You must be authenticated with GitHub to view all of Laravel's issues.
The Laravel source code is managed on GitHub, and there are repositories for each of the Laravel projects:
Laravel Application
Laravel Art
Laravel Documentation
Laravel Dusk
Laravel Cashier Stripe
Laravel Cashier Paddle
Laravel Echo
Laravel Envoy
Laravel Framework
Laravel Homestead
Laravel Homestead Build Scripts
Laravel Horizon
Laravel Jetstream
Laravel Passport
Laravel Pint
Laravel Sail
Laravel Sanctum
Laravel Scout
Laravel Socialite
Laravel Telescope
Laravel Website

Support Questions

Page 32 of 1307

Laravel 9.x

Laravel's GitHub issue trackers are not intended to provide Laravel help or support. Instead, use one of the following
channels:
GitHub Discussions
Laracasts Forums
Laravel.io Forums
StackOverflow
Discord
Larachat
IRC

Core Development Discussion

You may propose new features or improvements of existing Laravel behavior in the Laravel framework repository's GitHub
discussion board. If you propose a new feature, please be willing to implement at least some of the code that would be
needed to complete the feature.
Informal discussion regarding bugs, new features, and implementation of existing features takes place in the #internals
channel of the Laravel Discord server. Taylor Otwell, the maintainer of Laravel, is typically present in the channel on
weekdays from 8am-5pm (UTC-06:00 or America/Chicago), and sporadically present in the channel at other times.

Which Branch?

All bug fixes should be sent to the latest version that supports bug fixes (currently 9.x ). Bug fixes should never be sent
to the master branch unless they fix features that exist only in the upcoming release.
Minor features that are fully backward compatible with the current release may be sent to the latest stable branch
(currently 9.x ).
Major new features or features with breaking changes should always be sent to the master branch, which contains the
upcoming release.

Compiled Assets

If you are submitting a change that will affect a compiled file, such as most of the files in resources/css or
resources/js of the laravel/laravel repository, do not commit the compiled files. Due to their large size, they
cannot realistically be reviewed by a maintainer. This could be exploited as a way to inject malicious code into Laravel. In
order to defensively prevent this, all compiled files will be generated and committed by Laravel maintainers.

Security Vulnerabilities

If you discover a security vulnerability within Laravel, please send an email to Taylor Otwell at taylor@laravel.com. All
security vulnerabilities will be promptly addressed.

Coding Style

Laravel follows the PSR-2 coding standard and the PSR-4 autoloading standard.

PHPDoc

Below is an example of a valid Laravel documentation block. Note that the @param attribute is followed by two spaces,
the argument type, two more spaces, and finally the variable name:

Page 33 of 1307

Laravel 9.x

/**
* Register a binding with the container.
*
* @param

string|array

* @param

\Closure|string|null

$abstract

* @param

bool

$concrete

$shared

* @return void
*
* @throws \Exception
*/
public function bind($abstract, $concrete = null, $shared = false)
{
//
}

StyleCI

Don't worry if your code styling isn't perfect! StyleCI will automatically merge any style fixes into the Laravel repository
after pull requests are merged. This allows us to focus on the content of the contribution and not the code style.

Code of Conduct

The Laravel code of conduct is derived from the Ruby code of conduct. Any violations of the code of conduct may be
reported to Taylor Otwell (taylor@laravel.com):
Participants will be tolerant of opposing views.
Participants must ensure that their language and actions are free of personal attacks and disparaging personal
remarks.
When interpreting the words and actions of others, participants should always assume good intentions.
Behavior that can be reasonably considered harassment will not be tolerated.

Page 34 of 1307

Laravel 9.x

Chapter 2

Getting Started

Page 35 of 1307

Laravel 9.x

Installation
Meet Laravel
Why Laravel?
Your First Laravel Project
Laravel & Docker
Getting Started On macOS
Getting Started On Windows
Getting Started On Linux
Choosing Your Sail Services
Initial Configuration
Environment Based Configuration
Databases & Migrations
Next Steps
Laravel The Full Stack Framework
Laravel The API Backend

Meet Laravel

Laravel is a web application framework with expressive, elegant syntax. A web framework provides a structure and starting
point for creating your application, allowing you to focus on creating something amazing while we sweat the details.
Laravel strives to provide an amazing developer experience while providing powerful features such as thorough
dependency injection, an expressive database abstraction layer, queues and scheduled jobs, unit and integration testing,
and more.
Whether you are new to PHP web frameworks or have years of experience, Laravel is a framework that can grow with you.
We'll help you take your first steps as a web developer or give you a boost as you take your expertise to the next level. We
can't wait to see what you build.
New to Laravel? Check out the Laravel Bootcamp for a hands-on tour of the framework while we
walk you through building your first Laravel application.

Why Laravel?

There are a variety of tools and frameworks available to you when building a web application. However, we believe Laravel
is the best choice for building modern, full-stack web applications.
A Progressive Framework
We like to call Laravel a "progressive" framework. By that, we mean that Laravel grows with you. If you're just taking your
first steps into web development, Laravel's vast library of documentation, guides, and video tutorials will help you learn the
ropes without becoming overwhelmed.
If you're a senior developer, Laravel gives you robust tools for dependency injection, unit testing, queues, real-time events,
and more. Laravel is fine-tuned for building professional web applications and ready to handle enterprise work loads.
A Scalable Framework
Laravel is incredibly scalable. Thanks to the scaling-friendly nature of PHP and Laravel's built-in support for fast,
distributed cache systems like Redis, horizontal scaling with Laravel is a breeze. In fact, Laravel applications have been
easily scaled to handle hundreds of millions of requests per month.

Page 36 of 1307

Laravel 9.x

Need extreme scaling? Platforms like Laravel Vapor allow you to run your Laravel application at nearly limitless scale on
AWS's latest serverless technology.
A Community Framework
Laravel combines the best packages in the PHP ecosystem to offer the most robust and developer friendly framework
available. In addition, thousands of talented developers from around the world have contributed to the framework. Who
knows, maybe you'll even become a Laravel contributor.

Your First Laravel Project

Before creating your first Laravel project, you should ensure that your local machine has PHP and Composer installed. If
you are developing on macOS, PHP and Composer can be installed via Homebrew. In addition, we recommend installing
Node and NPM.
After you have installed PHP and Composer, you may create a new Laravel project via the Composer create-project
command:
composer create-project laravel/laravel:^9.0 example-app

Or, you may create new Laravel projects by globally installing the Laravel installer via Composer:
composer global require laravel/installer
laravel new example-app

After the project has been created, start Laravel's local development server using the Laravel's Artisan CLI serve
command:
cd example-app
php artisan serve

Once you have started the Artisan development server, your application will be accessible in your web browser at
http://localhost:8000 . Next, you're ready to start taking your next steps into the Laravel ecosystem. Of course, you
may also want to configure a database.
If you would like a head start when developing your Laravel application, consider using one of our
starter kits. Laravel's starter kits provide backend and frontend authentication scaffolding for your
new Laravel application.

Laravel & Docker

We want it to be as easy as possible to get started with Laravel regardless of your preferred operating system. So, there
are a variety of options for developing and running a Laravel project on your local machine. While you may wish to explore
these options at a later time, Laravel provides Sail, a built-in solution for running your Laravel project using Docker.
Docker is a tool for running applications and services in small, light-weight "containers" which do not interfere with your
local machine's installed software or configuration. This means you don't have to worry about configuring or setting up
complicated development tools such as web servers and databases on your local machine. To get started, you only need to
install Docker Desktop.

Page 37 of 1307

Laravel 9.x

Laravel Sail is a light-weight command-line interface for interacting with Laravel's default Docker configuration. Sail
provides a great starting point for building a Laravel application using PHP, MySQL, and Redis without requiring prior
Docker experience.
Already a Docker expert? Don't worry! Everything about Sail can be customized using the dockerfile included with Laravel.

compose.yml

Getting Started On macOS

If you're developing on a Mac and Docker Desktop is already installed, you can use a simple terminal command to create a
new Laravel project. For example, to create a new Laravel application in a directory named "example-app", you may run the
following command in your terminal:
curl -s "https://laravel.build/example-app" | bash

Of course, you can change "example-app" in this URL to anything you like - just make sure the application name only
contains alpha-numeric characters, dashes, and underscores. The Laravel application's directory will be created within the
directory you execute the command from.
Sail installation may take several minutes while Sail's application containers are built on your local machine.
After the project has been created, you can navigate to the application directory and start Laravel Sail. Laravel Sail
provides a simple command-line interface for interacting with Laravel's default Docker configuration:
cd example-app
./vendor/bin/sail up

Once the application's Docker containers have been started, you can access the application in your web browser at:
http://localhost.
To continue learning more about Laravel Sail, review its complete documentation.

Getting Started On Windows

Before we create a new Laravel application on your Windows machine, make sure to install Docker Desktop. Next, you
should ensure that Windows Subsystem for Linux 2 (WSL2) is installed and enabled. WSL allows you to run Linux binary
executables natively on Windows 10. Information on how to install and enable WSL2 can be found within Microsoft's
developer environment documentation.
After installing and enabling WSL2, you should ensure that Docker Desktop is configured to use the
WSL2 backend.
Next, you are ready to create your first Laravel project. Launch Windows Terminal and begin a new terminal session for
your WSL2 Linux operating system. Next, you can use a simple terminal command to create a new Laravel project. For

Page 38 of 1307

Laravel 9.x

example, to create a new Laravel application in a directory named "example-app", you may run the following command in
your terminal:
curl -s https://laravel.build/example-app | bash

Of course, you can change "example-app" in this URL to anything you like - just make sure the application name only
contains alpha-numeric characters, dashes, and underscores. The Laravel application's directory will be created within the
directory you execute the command from.
Sail installation may take several minutes while Sail's application containers are built on your local machine.
After the project has been created, you can navigate to the application directory and start Laravel Sail. Laravel Sail
provides a simple command-line interface for interacting with Laravel's default Docker configuration:
cd example-app
./vendor/bin/sail up

Once the application's Docker containers have been started, you can access the application in your web browser at:
http://localhost.
To continue learning more about Laravel Sail, review its complete documentation.
Developing Within WSL2
Of course, you will need to be able to modify the Laravel application files that were created within your WSL2 installation.
To accomplish this, we recommend using Microsoft's Visual Studio Code editor and their first-party extension for Remote
Development.
Once these tools are installed, you may open any Laravel project by executing the code . command from your
application's root directory using Windows Terminal.

Getting Started On Linux

If you're developing on Linux and Docker Compose is already installed, you can use a simple terminal command to create a
new Laravel project. For example, to create a new Laravel application in a directory named "example-app", you may run the
following command in your terminal:
curl -s https://laravel.build/example-app | bash

Of course, you can change "example-app" in this URL to anything you like - just make sure the application name only
contains alpha-numeric characters, dashes, and underscores. The Laravel application's directory will be created within the
directory you execute the command from.
Sail installation may take several minutes while Sail's application containers are built on your local machine.
After the project has been created, you can navigate to the application directory and start Laravel Sail. Laravel Sail
provides a simple command-line interface for interacting with Laravel's default Docker configuration:
cd example-app
./vendor/bin/sail up

Page 39 of 1307

Laravel 9.x

Once the application's Docker containers have been started, you can access the application in your web browser at:
http://localhost.
To continue learning more about Laravel Sail, review its complete documentation.

Choosing Your Sail Services

When creating a new Laravel application via Sail, you may use the with query string variable to choose which services
should be configured in your new application's docker-compose.yml file. Available services include mysql , pgsql ,
mariadb , redis , memcached , meilisearch , minio , selenium , and mailpit :
curl -s "https://laravel.build/example-app?with=mysql,redis" | bash

If you do not specify which services you would like configured, a default stack of mysql , redis , meilisearch ,
mailpit , and selenium will be configured.
You may instruct Sail to install a default Devcontainer by adding the devcontainer parameter to the URL:
curl -s "https://laravel.build/example-app?with=mysql,redis&devcontainer" | bash

Initial Configuration

All of the configuration files for the Laravel framework are stored in the config directory. Each option is documented, so
feel free to look through the files and get familiar with the options available to you.
Laravel needs almost no additional configuration out of the box. You are free to get started developing! However, you may
wish to review the config/app.php file and its documentation. It contains several options such as timezone and
locale that you may wish to change according to your application.

Environment Based Configuration

Since many of Laravel's configuration option values may vary depending on whether your application is running on your
local machine or on a production web server, many important configuration values are defined using the .env file that
exists at the root of your application.
Your .env file should not be committed to your application's source control, since each developer / server using your
application could require a different environment configuration. Furthermore, this would be a security risk in the event an
intruder gains access to your source control repository, since any sensitive credentials would get exposed.
For more information about the .env file and environment based configuration, check out the full
configuration documentation.

Databases & Migrations

Now that you have created your Laravel application, you probably want to store some data in a database. By default, your
application's .env configuration file specifies that Laravel will be interacting with a MySQL database and will access the
database at 127.0.0.1 . If you are developing on macOS and need to install MySQL, Postgres, or Redis locally, you may
find it convenient to utilize DBngin.

Page 40 of 1307

Laravel 9.x

If you do not want to install MySQL or Postgres on your local machine, you can always use a SQLite database. SQLite is a
small, fast, self-contained database engine. To get started, update your .env configuration file to use Laravel's sqlite
database driver. You may remove the other database configuration options:
+ DB_CONNECTION=sqlite
- DB_CONNECTION=mysql
- DB_HOST=127.0.0.1
- DB_PORT=3306
- DB_DATABASE=laravel
- DB_USERNAME=root
- DB_PASSWORD=

Once you have configured your SQLite database, you may run your application's database migrations, which will create
your application's database tables:
php artisan migrate

If an SQLite database does not exist for your application, Laravel will ask you if you would like the database to be created.
Typically, the SQLite database file will be created at database/database.sqlite .

Next Steps

Now that you have created your Laravel project, you may be wondering what to learn next. First, we strongly recommend
becoming familiar with how Laravel works by reading the following documentation:
Request Lifecycle
Configuration
Directory Structure
Frontend
Service Container
Facades
How you want to use Laravel will also dictate the next steps on your journey. There are a variety of ways to use Laravel, and
we'll explore two primary use cases for the framework below.
New to Laravel? Check out the Laravel Bootcamp for a hands-on tour of the framework while we
walk you through building your first Laravel application.

Laravel The Full Stack Framework

Laravel may serve as a full stack framework. By "full stack" framework we mean that you are going to use Laravel to route
requests to your application and render your frontend via Blade templates or a single-page application hybrid technology
like Inertia. This is the most common way to use the Laravel framework, and, in our opinion, the most productive way to use
Laravel.
If this is how you plan to use Laravel, you may want to check out our documentation on frontend development, routing,
views, or the Eloquent ORM. In addition, you might be interested in learning about community packages like Livewire and
Inertia. These packages allow you to use Laravel as a full-stack framework while enjoying many of the UI benefits provided
by single-page JavaScript applications.
If you are using Laravel as a full stack framework, we also strongly encourage you to learn how to compile your
application's CSS and JavaScript using Vite.

Page 41 of 1307

Laravel 9.x

If you want to get a head start building your application, check out one of our official application
starter kits.

Laravel The API Backend

Laravel may also serve as an API backend to a JavaScript single-page application or mobile application. For example, you
might use Laravel as an API backend for your Next.js application. In this context, you may use Laravel to provide
authentication and data storage / retrieval for your application, while also taking advantage of Laravel's powerful services
such as queues, emails, notifications, and more.
If this is how you plan to use Laravel, you may want to check out our documentation on routing, Laravel Sanctum, and the
Eloquent ORM.
Need a head start scaffolding your Laravel backend and Next.js frontend? Laravel Breeze offers an
API stack as well as a Next.js frontend implementation so you can get started in minutes.

Page 42 of 1307

Laravel 9.x

Configuration

Introduction
Environment Configuration
Environment Variable Types
Retrieving Environment Configuration
Determining The Current Environment
Encrypting Environment Files
Accessing Configuration Values
Configuration Caching
Debug Mode
Maintenance Mode

Introduction

All of the configuration files for the Laravel framework are stored in the config directory. Each option is documented, so
feel free to look through the files and get familiar with the options available to you.
These configuration files allow you to configure things like your database connection information, your mail server
information, as well as various other core configuration values such as your application timezone and encryption key.
Application Overview
In a hurry? You can get a quick overview of your application's configuration, drivers, and environment via the about
Artisan command:
php artisan about

If you're only interested in a particular section of the application overview output, you may filter for that section using the
--only option:
php artisan about --only=environment

Environment Configuration

It is often helpful to have different configuration values based on the environment where the application is running. For
example, you may wish to use a different cache driver locally than you do on your production server.
To make this a cinch, Laravel utilizes the DotEnv PHP library. In a fresh Laravel installation, the root directory of your
application will contain a .env.example file that defines many common environment variables. During the Laravel
installation process, this file will automatically be copied to .env .
Laravel's default .env file contains some common configuration values that may differ based on whether your application
is running locally or on a production web server. These values are then retrieved from various Laravel configuration files
within the config directory using Laravel's env function.
If you are developing with a team, you may wish to continue including a .env.example file with your application. By
putting placeholder values in the example configuration file, other developers on your team can clearly see which
environment variables are needed to run your application.

Page 43 of 1307

Laravel 9.x

Any variable in your .env file can be overridden by external environment variables such as
server-level or system-level environment variables.
Environment File Security
Your .env file should not be committed to your application's source control, since each developer / server using your
application could require a different environment configuration. Furthermore, this would be a security risk in the event an
intruder gains access to your source control repository, since any sensitive credentials would get exposed.
However, it is possible to encrypt your environment file using Laravel's built-in environment encryption. Encrypted
environment files may be placed in source control safely.
Additional Environment Files
Before loading your application's environment variables, Laravel determines if an APP_ENV environment variable has been
externally provided or if the --env CLI argument has been specified. If so, Laravel will attempt to load an .env.
[APP_ENV] file if it exists. If it does not exist, the default .env file will be loaded.

Environment Variable Types

All variables in your .env files are typically parsed as strings, so some reserved values have been created to allow you to
return a wider range of types from the env() function:
.env

Value

true
(true)
false
(false)
empty
(empty)
null
(null)

Value
(bool) true
(bool) true
(bool) false
(bool) false
(string) ''
(string) ''
(null) null
(null) null

env()

If you need to define an environment variable with a value that contains spaces, you may do so by enclosing the value in
double quotes:
APP_NAME="My Application"

Retrieving Environment Configuration

All of the variables listed in the .env file will be loaded into the $_ENV PHP super-global when your application receives
a request. However, you may use the env function to retrieve values from these variables in your configuration files. In
fact, if you review the Laravel configuration files, you will notice many of the options are already using this function:
'debug' => env('APP_DEBUG', false),

Page 44 of 1307

Laravel 9.x

The second value passed to the env function is the "default value". This value will be returned if no environment variable
exists for the given key.

Determining The Current Environment

The current application environment is determined via the APP_ENV variable from your .env file. You may access this
value via the environment method on the App facade:
use Illuminate\Support\Facades\App;
$environment = App::environment();

You may also pass arguments to the environment method to determine if the environment matches a given value. The
method will return true if the environment matches any of the given values:
if (App::environment('local')) {
// The environment is local
}
if (App::environment(['local', 'staging'])) {
// The environment is either local OR staging...
}

The current application environment detection can be overridden by defining a server-level
APP_ENV environment variable.

Encrypting Environment Files

Unencrypted environment files should never be stored in source control. However, Laravel allows you to encrypt your
environment files so that they may safely be added to source control with the rest of your application.
Encryption
To encrypt an environment file, you may use the env:encrypt command:
php artisan env:encrypt

Running the env:encrypt command will encrypt your .env file and place the encrypted contents in an
.env.encrypted file. The decryption key is presented in the output of the command and should be stored in a secure
password manager. If you would like to provide your own encryption key you may use the --key option when invoking the
command:
php artisan env:encrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF

Page 45 of 1307

Laravel 9.x

The length of the key provided should match the key length required by the encryption cipher
being used. By default, Laravel will use the AES-256-CBC cipher which requires a 32 character
key. You are free to use any cipher supported by Laravel's encrypter by passing the --cipher
option when invoking the command.
If your application has multiple environment files, such as .env and .env.staging , you may specify the environment
file that should be encrypted by providing the environment name via the --env option:
php artisan env:encrypt --env=staging

Decryption
To decrypt an environment file, you may use the env:decrypt command. This command requires a decryption key, which
Laravel will retrieve from the LARAVEL_ENV_ENCRYPTION_KEY environment variable:
php artisan env:decrypt

Or, the key may be provided directly to the command via the --key option:
php artisan env:decrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF

When the env:decrypt command is invoked, Laravel will decrypt the contents of the .env.encrypted file and place
the decrypted contents in the .env file.
The --cipher option may be provided to the env:decrypt command in order to use a custom encryption cipher:
php artisan env:decrypt --key=qUWuNRdfuImXcKxZ --cipher=AES-128-CBC

If your application has multiple environment files, such as .env and .env.staging , you may specify the environment
file that should be decrypted by providing the environment name via the --env option:
php artisan env:decrypt --env=staging

In order to overwrite an existing environment file, you may provide the --force option to the env:decrypt command:
php artisan env:decrypt --force

Accessing Configuration Values

You may easily access your configuration values using the global config function from anywhere in your application. The
configuration values may be accessed using "dot" syntax, which includes the name of the file and option you wish to
access. A default value may also be specified and will be returned if the configuration option does not exist:
$value = config('app.timezone');
// Retrieve a default value if the configuration value does not exist...
$value = config('app.timezone', 'Asia/Seoul');

To set configuration values at runtime, pass an array to the config function:
Page 46 of 1307

Laravel 9.x

config(['app.timezone' => 'America/Chicago']);

Configuration Caching

To give your application a speed boost, you should cache all of your configuration files into a single file using the
config:cache Artisan command. This will combine all of the configuration options for your application into a single file
which can be quickly loaded by the framework.
You should typically run the php artisan config:cache command as part of your production deployment process. The
command should not be run during local development as configuration options will frequently need to be changed during
the course of your application's development.
The config:clear command may be used to purge the cached configuration:
php artisan config:clear

If you execute the config:cache command during your deployment process, you should be sure
that you are only calling the env function from within your configuration files. Once the
configuration has been cached, the .env file will not be loaded; therefore, the env function will
only return external, system level environment variables.

Debug Mode

The debug option in your config/app.php configuration file determines how much information about an error is
actually displayed to the user. By default, this option is set to respect the value of the APP_DEBUG environment variable,
which is stored in your .env file.
For local development, you should set the APP_DEBUG environment variable to true . In your production environment,
this value should always be false . If the variable is set to true in production, you risk exposing sensitive
configuration values to your application's end users.

Maintenance Mode

When your application is in maintenance mode, a custom view will be displayed for all requests into your application. This
makes it easy to "disable" your application while it is updating or when you are performing maintenance. A maintenance
mode check is included in the default middleware stack for your application. If the application is in maintenance mode, a
Symfony\Component\HttpKernel\Exception\HttpException instance will be thrown with a status code of 503.
To enable maintenance mode, execute the down Artisan command:
php artisan down

If you would like the Refresh HTTP header to be sent with all maintenance mode responses, you may provide the
refresh option when invoking the down command. The Refresh header will instruct the browser to automatically
refresh the page after the specified number of seconds:
php artisan down --refresh=15

You may also provide a retry option to the down command, which will be set as the Retry-After HTTP header's
value, although browsers generally ignore this header:
Page 47 of 1307

Laravel 9.x

php artisan down --retry=60

Bypassing Maintenance Mode
To allow maintenance mode to be bypassed using a secret token, you may use the secret option to specify a
maintenance mode bypass token:
php artisan down --secret="1630542a-246b-4b66-afa1-dd72a4c43515"

After placing the application in maintenance mode, you may navigate to the application URL matching this token and
Laravel will issue a maintenance mode bypass cookie to your browser:
https://example.com/1630542a-246b-4b66-afa1-dd72a4c43515

When accessing this hidden route, you will then be redirected to the / route of the application. Once the cookie has been
issued to your browser, you will be able to browse the application normally as if it was not in maintenance mode.
Your maintenance mode secret should typically consist of alpha-numeric characters and,
optionally, dashes. You should avoid using characters that have special meaning in URLs such as
? or & .
Pre-Rendering The Maintenance Mode View
If you utilize the php artisan down command during deployment, your users may still occasionally encounter errors if
they access the application while your Composer dependencies or other infrastructure components are updating. This
occurs because a significant part of the Laravel framework must boot in order to determine your application is in
maintenance mode and render the maintenance mode view using the templating engine.
For this reason, Laravel allows you to pre-render a maintenance mode view that will be returned at the very beginning of
the request cycle. This view is rendered before any of your application's dependencies have loaded. You may pre-render a
template of your choice using the down command's render option:
php artisan down --render="errors::503"

Redirecting Maintenance Mode Requests
While in maintenance mode, Laravel will display the maintenance mode view for all application URLs the user attempts to
access. If you wish, you may instruct Laravel to redirect all requests to a specific URL. This may be accomplished using the
redirect option. For example, you may wish to redirect all requests to the / URI:
php artisan down --redirect=/

Disabling Maintenance Mode
To disable maintenance mode, use the up command:
php artisan up

Page 48 of 1307

Laravel 9.x

You may customize the default maintenance mode template by defining your own template at
resources/views/errors/503.blade.php .
Maintenance Mode & Queues
While your application is in maintenance mode, no queued jobs will be handled. The jobs will continue to be handled as
normal once the application is out of maintenance mode.
Alternatives To Maintenance Mode
Since maintenance mode requires your application to have several seconds of downtime, consider alternatives like Laravel
Vapor and Envoyer to accomplish zero-downtime deployment with Laravel.

Page 49 of 1307

Laravel 9.x

Directory Structure
Introduction
The Root Directory
The app Directory
The bootstrap Directory
The config Directory
The database Directory
The lang Directory
The public Directory
The resources Directory
The routes Directory
The storage Directory
The tests Directory
The vendor Directory
The App Directory
The Broadcasting Directory
The Console Directory
The Events Directory
The Exceptions Directory
The Http Directory
The Jobs Directory
The Listeners Directory
The Mail Directory
The Models Directory
The Notifications Directory
The Policies Directory
The Providers Directory
The Rules Directory

Introduction

The default Laravel application structure is intended to provide a great starting point for both large and small applications.
But you are free to organize your application however you like. Laravel imposes almost no restrictions on where any given
class is located - as long as Composer can autoload the class.
New to Laravel? Check out the Laravel Bootcamp for a hands-on tour of the framework while we
walk you through building your first Laravel application.

The Root Directory

The App Directory
The app directory contains the core code of your application. We'll explore this directory in more detail soon; however,
almost all of the classes in your application will be in this directory.
The Bootstrap Directory
The bootstrap directory contains the app.php file which bootstraps the framework. This directory also houses a
cache directory which contains framework generated files for performance optimization such as the route and services
cache files. You should not typically need to modify any files within this directory.
Page 50 of 1307

Laravel 9.x

The Config Directory
The config directory, as the name implies, contains all of your application's configuration files. It's a great idea to read
through all of these files and familiarize yourself with all of the options available to you.
The Database Directory
The database directory contains your database migrations, model factories, and seeds. If you wish, you may also use
this directory to hold an SQLite database.
The Lang Directory
The lang directory houses all of your application's language files.
The Public Directory
The public directory contains the index.php file, which is the entry point for all requests entering your application
and configures autoloading. This directory also houses your assets such as images, JavaScript, and CSS.
The Resources Directory
The resources directory contains your views as well as your raw, un-compiled assets such as CSS or JavaScript.
The Routes Directory
The routes directory contains all of the route definitions for your application. By default, several route files are included
with Laravel: web.php , api.php , console.php , and channels.php .
The web.php file contains routes that the RouteServiceProvider places in the web middleware group, which
provides session state, CSRF protection, and cookie encryption. If your application does not offer a stateless, RESTful API
then all your routes will most likely be defined in the web.php file.
The api.php file contains routes that the RouteServiceProvider places in the api middleware group. These routes
are intended to be stateless, so requests entering the application through these routes are intended to be authenticated
via tokens and will not have access to session state.
The console.php file is where you may define all of your closure based console commands. Each closure is bound to a
command instance allowing a simple approach to interacting with each command's IO methods. Even though this file does
not define HTTP routes, it defines console based entry points (routes) into your application.
The channels.php file is where you may register all of the event broadcasting channels that your application supports.
The Storage Directory
The storage directory contains your logs, compiled Blade templates, file based sessions, file caches, and other files
generated by the framework. This directory is segregated into app , framework , and logs directories. The app
directory may be used to store any files generated by your application. The framework directory is used to store
framework generated files and caches. Finally, the logs directory contains your application's log files.
The storage/app/public directory may be used to store user-generated files, such as profile avatars, that should be
publicly accessible. You should create a symbolic link at public/storage which points to this directory. You may create
the link using the php artisan storage:link Artisan command.
The Tests Directory
The tests directory contains your automated tests. Example PHPUnit unit tests and feature tests are provided out of the
box. Each test class should be suffixed with the word Test . You may run your tests using the phpunit or php
vendor/bin/phpunit commands. Or, if you would like a more detailed and beautiful representation of your test results,
you may run your tests using the php artisan test Artisan command.
The Vendor Directory

Page 51 of 1307

Laravel 9.x

The vendor directory contains your Composer dependencies.

The App Directory

The majority of your application is housed in the app directory. By default, this directory is namespaced under App and
is autoloaded by Composer using the PSR-4 autoloading standard.
The app directory contains a variety of additional directories such as Console , Http , and Providers . Think of the
Console and Http directories as providing an API into the core of your application. The HTTP protocol and CLI are both
mechanisms to interact with your application, but do not actually contain application logic. In other words, they are two
ways of issuing commands to your application. The Console directory contains all of your Artisan commands, while the
Http directory contains your controllers, middleware, and requests.
A variety of other directories will be generated inside the app directory as you use the make Artisan commands to
generate classes. So, for example, the app/Jobs directory will not exist until you execute the make:job Artisan
command to generate a job class.
Many of the classes in the app directory can be generated by Artisan via commands. To review
the available commands, run the php artisan list make command in your terminal.
The Broadcasting Directory
The Broadcasting directory contains all of the broadcast channel classes for your application. These classes are
generated using the make:channel command. This directory does not exist by default, but will be created for you when
you create your first channel. To learn more about channels, check out the documentation on event broadcasting.
The Console Directory
The Console directory contains all of the custom Artisan commands for your application. These commands may be
generated using the make:command command. This directory also houses your console kernel, which is where your
custom Artisan commands are registered and your scheduled tasks are defined.
The Events Directory
This directory does not exist by default, but will be created for you by the event:generate and make:event Artisan
commands. The Events directory houses event classes. Events may be used to alert other parts of your application that
a given action has occurred, providing a great deal of flexibility and decoupling.
The Exceptions Directory
The Exceptions directory contains your application's exception handler and is also a good place to place any exceptions
thrown by your application. If you would like to customize how your exceptions are logged or rendered, you should modify
the Handler class in this directory.
The Http Directory
The Http directory contains your controllers, middleware, and form requests. Almost all of the logic to handle requests
entering your application will be placed in this directory.
The Jobs Directory
This directory does not exist by default, but will be created for you if you execute the make:job Artisan command. The
Jobs directory houses the queueable jobs for your application. Jobs may be queued by your application or run
synchronously within the current request lifecycle. Jobs that run synchronously during the current request are sometimes
referred to as "commands" since they are an implementation of the command pattern.

Page 52 of 1307

Laravel 9.x

The Listeners Directory
This directory does not exist by default, but will be created for you if you execute the event:generate or
make:listener Artisan commands. The Listeners directory contains the classes that handle your events. Event
listeners receive an event instance and perform logic in response to the event being fired. For example, a
UserRegistered event might be handled by a SendWelcomeEmail listener.
The Mail Directory
This directory does not exist by default, but will be created for you if you execute the make:mail Artisan command. The
Mail directory contains all of your classes that represent emails sent by your application. Mail objects allow you to
encapsulate all of the logic of building an email in a single, simple class that may be sent using the Mail::send method.
The Models Directory
The Models directory contains all of your Eloquent model classes. The Eloquent ORM included with Laravel provides a
beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding
"Model" which is used to interact with that table. Models allow you to query for data in your tables, as well as insert new
records into the table.
The Notifications Directory
This directory does not exist by default, but will be created for you if you execute the make:notification Artisan
command. The Notifications directory contains all of the "transactional" notifications that are sent by your
application, such as simple notifications about events that happen within your application. Laravel's notification feature
abstracts sending notifications over a variety of drivers such as email, Slack, SMS, or stored in a database.
The Policies Directory
This directory does not exist by default, but will be created for you if you execute the make:policy Artisan command.
The Policies directory contains the authorization policy classes for your application. Policies are used to determine if a
user can perform a given action against a resource.
The Providers Directory
The Providers directory contains all of the service providers for your application. Service providers bootstrap your
application by binding services in the service container, registering events, or performing any other tasks to prepare your
application for incoming requests.
In a fresh Laravel application, this directory will already contain several providers. You are free to add your own providers
to this directory as needed.
The Rules Directory
This directory does not exist by default, but will be created for you if you execute the make:rule Artisan command. The
Rules directory contains the custom validation rule objects for your application. Rules are used to encapsulate
complicated validation logic in a simple object. For more information, check out the validation documentation.

Page 53 of 1307

Laravel 9.x

Frontend
Introduction
Using PHP
PHP & Blade
Livewire
Starter Kits
Using Vue / React
Inertia
Starter Kits
Bundling Assets

Introduction

Laravel is a backend framework that provides all of the features you need to build modern web applications, such as
routing, validation, caching, queues, file storage, and more. However, we believe it's important to offer developers a
beautiful full-stack experience, including powerful approaches for building your application's frontend.
There are two primary ways to tackle frontend development when building an application with Laravel, and which approach
you choose is determined by whether you would like to build your frontend by leveraging PHP or by using JavaScript
frameworks such as Vue and React. We'll discuss both of these options below so that you can make an informed decision
regarding the best approach to frontend development for your application.

Using PHP
PHP & Blade

In the past, most PHP applications rendered HTML to the browser using simple HTML templates interspersed with PHP
echo statements which render data that was retrieved from a database during the request:
<div>
<?php foreach ($users as $user): ?>
Hello, <?php echo $user->name; ?> <br />
<?php endforeach; ?>
</div>

In Laravel, this approach to rendering HTML can still be achieved using views and Blade. Blade is an extremely light-weight
templating language that provides convenient, short syntax for displaying data, iterating over data, and more:
<div>
@foreach ($users as $user)
Hello, {{ $user->name }} <br />
@endforeach
</div>

When building applications in this fashion, form submissions and other page interactions typically receive an entirely new
HTML document from the server and the entire page is re-rendered by the browser. Even today, many applications may be
perfectly suited to having their frontends constructed in this way using simple Blade templates.
Growing Expectations
However, as user expectations regarding web applications have matured, many developers have found the need to build
more dynamic frontends with interactions that feel more polished. In light of this, some developers choose to begin
Page 54 of 1307

Laravel 9.x

building their application's frontend using JavaScript frameworks such as Vue and React.
Others, preferring to stick with the backend language they are comfortable with, have developed solutions that allow the
construction of modern web application UIs while still primarily utilizing their backend language of choice. For example, in
the Rails ecosystem, this has spurred the creation of libraries such as Turbo Hotwire, and Stimulus.
Within the Laravel ecosystem, the need to create modern, dynamic frontends by primarily using PHP has led to the
creation of Laravel Livewire and Alpine.js.

Livewire

Laravel Livewire is a framework for building Laravel powered frontends that feel dynamic, modern, and alive just like
frontends built with modern JavaScript frameworks like Vue and React.
When using Livewire, you will create Livewire "components" that render a discrete portion of your UI and expose methods
and data that can be invoked and interacted with from your application's frontend. For example, a simple "Counter"
component might look like the following:
<?php
namespace App\Http\Livewire;
use Livewire\Component;
class Counter extends Component
{
public $count = 0;
public function increment()
{
$this->count++;
}
public function render()
{
return view('livewire.counter');
}
}

And, the corresponding template for the counter would be written like so:
<div>
<button wire:click="increment">+</button>
<h1>{{ $count }}</h1>
</div>

As you can see, Livewire enables you to write new HTML attributes such as wire:click that connect your Laravel
application's frontend and backend. In addition, you can render your component's current state using simple Blade
expressions.
For many, Livewire has revolutionized frontend development with Laravel, allowing them to stay within the comfort of
Laravel while constructing modern, dynamic web applications. Typically, developers using Livewire will also utilize Alpine.js
to "sprinkle" JavaScript onto their frontend only where it is needed, such as in order to render a dialog window.
If you're new to Laravel, we recommend getting familiar with the basic usage of views and Blade. Then, consult the official
Laravel Livewire documentation to learn how to take your application to the next level with interactive Livewire
components.
Page 55 of 1307

Laravel 9.x

Starter Kits

If you would like to build your frontend using PHP and Livewire, you can leverage our Breeze or Jetstream starter kits to
jump-start your application's development. Both of these starter kits scaffold your application's backend and frontend
authentication flow using Blade and Tailwind so that you can simply start building your next big idea.

Using Vue / React

Although it's possible to build modern frontends using Laravel and Livewire, many developers still prefer to leverage the
power of a JavaScript framework like Vue or React. This allows developers to take advantage of the rich ecosystem of
JavaScript packages and tools available via NPM.
However, without additional tooling, pairing Laravel with Vue or React would leave us needing to solve a variety of
complicated problems such as client-side routing, data hydration, and authentication. Client-side routing is often simplified
by using opinionated Vue / React frameworks such as Nuxt and Next; however, data hydration and authentication remain
complicated and cumbersome problems to solve when pairing a backend framework like Laravel with these frontend
frameworks.
In addition, developers are left maintaining two separate code repositories, often needing to coordinate maintenance,
releases, and deployments across both repositories. While these problems are not insurmountable, we don't believe it's a
productive or enjoyable way to develop applications.

Inertia

Thankfully, Laravel offers the best of both worlds. Inertia bridges the gap between your Laravel application and your
modern Vue or React frontend, allowing you to build full-fledged, modern frontends using Vue or React while leveraging
Laravel routes and controllers for routing, data hydration, and authentication â€” all within a single code repository. With this
approach, you can enjoy the full power of both Laravel and Vue / React without crippling the capabilities of either tool.
After installing Inertia into your Laravel application, you will write routes and controllers like normal. However, instead of
returning a Blade template from your controller, you will return an Inertia page:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\User;
use Inertia\Inertia;
class UserController extends Controller
{
/**
* Show the profile for a given user.
*
* @param

int

$id

* @return \Inertia\Response
*/
public function show($id)
{
return Inertia::render('Users/Profile', [
'user' => User::findOrFail($id)
]);
}
}

Page 56 of 1307

Laravel 9.x

An Inertia page corresponds to a Vue or React component, typically stored within the resources/js/Pages directory of
your application. The data given to the page via the Inertia::render method will be used to hydrate the "props" of the
page component:
<script setup>
import Layout from '@/Layouts/Authenticated.vue';
import { Head } from '@inertiajs/inertia-vue3';
const props = defineProps(['user']);
</script>
<template>
<Head title="User Profile" />
<Layout>
<template #header>
<h2 class="font-semibold text-xl text-gray-800 leading-tight">
Profile
</h2>
</template>
<div class="py-12">
Hello, {{ user.name }}
</div>
</Layout>
</template>

As you can see, Inertia allows you to leverage the full power of Vue or React when building your frontend, while providing a
light-weight bridge between your Laravel powered backend and your JavaScript powered frontend.
Server-Side Rendering
If you're concerned about diving into Inertia because your application requires server-side rendering, don't worry. Inertia
offers server-side rendering support. And, when deploying your application via Laravel Forge, it's a breeze to ensure that
Inertia's server-side rendering process is always running.

Starter Kits

If you would like to build your frontend using Inertia and Vue / React, you can leverage our Breeze or Jetstream starter kits
to jump-start your application's development. Both of these starter kits scaffold your application's backend and frontend
authentication flow using Inertia, Vue / React, Tailwind, and Vite so that you can start building your next big idea.

Bundling Assets

Regardless of whether you choose to develop your frontend using Blade and Livewire or Vue / React and Inertia, you will
likely need to bundle your application's CSS into production ready assets. Of course, if you choose to build your
application's frontend with Vue or React, you will also need to bundle your components into browser ready JavaScript
assets.
By default, Laravel utilizes Vite to bundle your assets. Vite provides lightning-fast build times and near instantaneous Hot
Module Replacement (HMR) during local development. In all new Laravel applications, including those using our starter
kits, you will find a vite.config.js file that loads our light-weight Laravel Vite plugin that makes Vite a joy to use with
Laravel applications.
The fastest way to get started with Laravel and Vite is by beginning your application's development using Laravel Breeze,
our simplest starter kit that jump-starts your application by providing frontend and backend authentication scaffolding.

Page 57 of 1307

Laravel 9.x

For more detailed documentation on utilizing Vite with Laravel, please see our dedicated
documentation on bundling and compiling your assets.

Page 58 of 1307

Laravel 9.x

Introduction
Laravel Breeze
Installation
Breeze & Blade
Breeze & React / Vue
Breeze & Next.js / API
Laravel Jetstream

Starter Kits

Introduction

To give you a head start building your new Laravel application, we are happy to offer authentication and application starter
kits. These kits automatically scaffold your application with the routes, controllers, and views you need to register and
authenticate your application's users.
While you are welcome to use these starter kits, they are not required. You are free to build your own application from the
ground up by simply installing a fresh copy of Laravel. Either way, we know you will build something great!

Laravel Breeze

Laravel Breeze is a minimal, simple implementation of all of Laravel's authentication features, including login, registration,
password reset, email verification, and password confirmation. In addition, Breeze includes a simple "profile" page where
the user may update their name, email address, and password.
Laravel Breeze's default view layer is made up of simple Blade templates styled with Tailwind CSS. Or, Breeze can scaffold
your application using Vue or React and Inertia.
Breeze provides a wonderful starting point for beginning a fresh Laravel application and is also a great choice for projects
that plan to take their Blade templates to the next level with Laravel Livewire.

Page 59 of 1307

Laravel 9.x

Laravel Bootcamp
If you're new to Laravel, feel free to jump into the Laravel Bootcamp. The Laravel Bootcamp will walk you through building
your first Laravel application using Breeze. It's a great way to get a tour of everything that Laravel and Breeze have to offer.

Installation

First, you should create a new Laravel application, configure your database, and run your database migrations. Once you
have created a new Laravel application, you may install Laravel Breeze using Composer:
composer require laravel/breeze --dev

Once Breeze is installed, you may scaffold your application using one of the Breeze "stacks" discussed in the
documentation below.

Breeze & Blade

After Composer has installed the Laravel Breeze package, you may run the breeze:install Artisan command. This
command publishes the authentication views, routes, controllers, and other resources to your application. Laravel Breeze
publishes all of its code to your application so that you have full control and visibility over its features and implementation.
The default Breeze "stack" is the Blade stack, which utilizes simple Blade templates to render your application's frontend.
The Blade stack may be installed by invoking the breeze:install command with no other additional arguments. After
Breeze's scaffolding is installed, you should also compile your application's frontend assets:
Page 60 of 1307

Laravel 9.x

php artisan breeze:install
php artisan migrate
npm install
npm run dev

Next, you may navigate to your application's /login or /register URLs in your web browser. All of Breeze's routes are
defined within the routes/auth.php file.
Dark Mode
If you would like Breeze to include "dark mode" support when scaffolding your application's frontend, simply provide the
--dark directive when executing the breeze:install command:
php artisan breeze:install --dark

To learn more about compiling your application's CSS and JavaScript, check out Laravel's Vite
documentation.

Breeze & React / Vue

Laravel Breeze also offers React and Vue scaffolding via an Inertia frontend implementation. Inertia allows you to build
modern, single-page React and Vue applications using classic server-side routing and controllers.
Inertia lets you enjoy the frontend power of React and Vue combined with the incredible backend productivity of Laravel
and lightning-fast Vite compilation. To use an Inertia stack, specify vue or react as your desired stack when executing
the breeze:install Artisan command. After Breeze's scaffolding is installed, you should also compile your application's
frontend assets:
php artisan breeze:install vue
# Or...
php artisan breeze:install react
php artisan migrate
npm install
npm run dev

Next, you may navigate to your application's /login or /register URLs in your web browser. All of Breeze's routes are
defined within the routes/auth.php file.
Server-Side Rendering
If you would like Breeze to scaffold support for Inertia SSR, you may provide the ssr option when invoking the
breeze:install command:
php artisan breeze:install vue --ssr
php artisan breeze:install react --ssr

Breeze & Next.js / API
Page 61 of 1307

Laravel 9.x

Laravel Breeze can also scaffold an authentication API that is ready to authenticate modern JavaScript applications such as
those powered by Next, Nuxt, and others. To get started, specify the api stack as your desired stack when executing the
breeze:install Artisan command:
php artisan breeze:install api
php artisan migrate

During installation, Breeze will add a FRONTEND_URL environment variable to your application's .env file. This URL
should be the URL of your JavaScript application. This will typically be http://localhost:3000 during local
development. In addition, you should ensure that your APP_URL is set to http://localhost:8000 , which is the default
URL used by the serve Artisan command.
Next.js Reference Implementation
Finally, you are ready to pair this backend with the frontend of your choice. A Next reference implementation of the Breeze
frontend is available on GitHub. This frontend is maintained by Laravel and contains the same user interface as the
traditional Blade and Inertia stacks provided by Breeze.

Laravel Jetstream

While Laravel Breeze provides a simple and minimal starting point for building a Laravel application, Jetstream augments
that functionality with more robust features and additional frontend technology stacks. For those brand new to Laravel,
we recommend learning the ropes with Laravel Breeze before graduating to Laravel Jetstream.
Jetstream provides a beautifully designed application scaffolding for Laravel and includes login, registration, email
verification, two-factor authentication, session management, API support via Laravel Sanctum, and optional team
management. Jetstream is designed using Tailwind CSS and offers your choice of Livewire or Inertia driven frontend
scaffolding.
Complete documentation for installing Laravel Jetstream can be found within the official Jetstream documentation.

Page 62 of 1307

Laravel 9.x

Deployment

Introduction
Server Requirements
Server Configuration
Nginx
Optimization
Autoloader Optimization
Optimizing Configuration Loading
Optimizing Route Loading
Optimizing View Loading
Debug Mode
Deploying With Forge / Vapor

Introduction

When you're ready to deploy your Laravel application to production, there are some important things you can do to make
sure your application is running as efficiently as possible. In this document, we'll cover some great starting points for
making sure your Laravel application is deployed properly.

Server Requirements

The Laravel framework has a few system requirements. You should ensure that your web server has the following minimum
PHP version and extensions:
PHP >= 8.0
Ctype PHP Extension
cURL PHP Extension
DOM PHP Extension
Fileinfo PHP Extension
Filter PHP Extension
Hash PHP Extension
Mbstring PHP Extension
OpenSSL PHP Extension
PCRE PHP Extension
PDO PHP Extension
Session PHP Extension
Tokenizer PHP Extension
XML PHP Extension

Server Configuration
Nginx

If you are deploying your application to a server that is running Nginx, you may use the following configuration file as a
starting point for configuring your web server. Most likely, this file will need to be customized depending on your server's
configuration. If you would like assistance in managing your server, consider using a first-party Laravel server
management and deployment service such as Laravel Forge.
Please ensure, like the configuration below, your web server directs all requests to your application's public/index.php
file. You should never attempt to move the index.php file to your project's root, as serving the application from the
project root will expose many sensitive configuration files to the public Internet:

Page 63 of 1307

Laravel 9.x

server {
listen 80;
listen [::]:80;
server_name example.com;
root /srv/example.com/public;
add_header X-Frame-Options "SAMEORIGIN";
add_header X-Content-Type-Options "nosniff";
index index.php;
charset utf-8;
location / {
try_files $uri $uri/ /index.php?$query_string;
}
location = /favicon.ico { access_log off; log_not_found off; }
location = /robots.txt

{ access_log off; log_not_found off; }

error_page 404 /index.php;
location ~ \.php$ {
fastcgi_pass unix:/var/run/php/php8.0-fpm.sock;
fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
include fastcgi_params;
}
location ~ /\.(?!well-known).* {
deny all;
}
}

Optimization

Autoloader Optimization

When deploying to production, make sure that you are optimizing Composer's class autoloader map so Composer can
quickly find the proper file to load for a given class:
composer install --optimize-autoloader --no-dev

In addition to optimizing the autoloader, you should always be sure to include a composer.lock
file in your project's source control repository. Your project's dependencies can be installed much
faster when a composer.lock file is present.

Optimizing Configuration Loading

When deploying your application to production, you should make sure that you run the config:cache Artisan command
during your deployment process:

Page 64 of 1307

Laravel 9.x

php artisan config:cache

This command will combine all of Laravel's configuration files into a single, cached file, which greatly reduces the number
of trips the framework must make to the filesystem when loading your configuration values.
If you execute the config:cache command during your deployment process, you should be sure
that you are only calling the env function from within your configuration files. Once the
configuration has been cached, the .env file will not be loaded and all calls to the env function
for .env variables will return null .

Optimizing Route Loading

If you are building a large application with many routes, you should make sure that you are running the route:cache
Artisan command during your deployment process:
php artisan route:cache

This command reduces all of your route registrations into a single method call within a cached file, improving the
performance of route registration when registering hundreds of routes.

Optimizing View Loading

When deploying your application to production, you should make sure that you run the view:cache Artisan command
during your deployment process:
php artisan view:cache

This command precompiles all your Blade views so they are not compiled on demand, improving the performance of each
request that returns a view.

Debug Mode

The debug option in your config/app.php configuration file determines how much information about an error is actually
displayed to the user. By default, this option is set to respect the value of the APP_DEBUG environment variable, which is
stored in your application's .env file.
In your production environment, this value should always be false . If the APP_DEBUG variable is set to true in
production, you risk exposing sensitive configuration values to your application's end users.

Deploying With Forge / Vapor

Laravel Forge
If you aren't quite ready to manage your own server configuration or aren't comfortable configuring all of the various
services needed to run a robust Laravel application, Laravel Forge is a wonderful alternative.
Laravel Forge can create servers on various infrastructure providers such as DigitalOcean, Linode, AWS, and more. In
addition, Forge installs and manages all of the tools needed to build robust Laravel applications, such as Nginx, MySQL,
Redis, Memcached, Beanstalk, and more.

Page 65 of 1307

Laravel 9.x

Want a full guide to deploying with Laravel Forge? Check out the Laravel Bootcamp and the Forge
video series available on Laracasts.
Laravel Vapor
If you would like a totally serverless, auto-scaling deployment platform tuned for Laravel, check out Laravel Vapor. Laravel
Vapor is a serverless deployment platform for Laravel, powered by AWS. Launch your Laravel infrastructure on Vapor and
fall in love with the scalable simplicity of serverless. Laravel Vapor is fine-tuned by Laravel's creators to work seamlessly
with the framework so you can keep writing your Laravel applications exactly like you're used to.

Page 66 of 1307

Laravel 9.x

Chapter 3

Architecture Concepts

Page 67 of 1307

Laravel 9.x

Request Lifecycle
Introduction
Lifecycle Overview
First Steps
HTTP / Console Kernels
Service Providers
Routing
Finishing Up
Focus On Service Providers

Introduction

When using any tool in the "real world", you feel more confident if you understand how that tool works. Application
development is no different. When you understand how your development tools function, you feel more comfortable and
confident using them.
The goal of this document is to give you a good, high-level overview of how the Laravel framework works. By getting to
know the overall framework better, everything feels less "magical" and you will be more confident building your
applications. If you don't understand all of the terms right away, don't lose heart! Just try to get a basic grasp of what is
going on, and your knowledge will grow as you explore other sections of the documentation.

Lifecycle Overview
First Steps

The entry point for all requests to a Laravel application is the public/index.php file. All requests are directed to this file
by your web server (Apache / Nginx) configuration. The index.php file doesn't contain much code. Rather, it is a starting
point for loading the rest of the framework.
The index.php file loads the Composer generated autoloader definition, and then retrieves an instance of the Laravel
application from bootstrap/app.php . The first action taken by Laravel itself is to create an instance of the application /
service container.

HTTP / Console Kernels

Next, the incoming request is sent to either the HTTP kernel or the console kernel, depending on the type of request that is
entering the application. These two kernels serve as the central location that all requests flow through. For now, let's just
focus on the HTTP kernel, which is located in app/Http/Kernel.php .
The HTTP kernel extends the Illuminate\Foundation\Http\Kernel class, which defines an array of bootstrappers
that will be run before the request is executed. These bootstrappers configure error handling, configure logging, detect the
application environment, and perform other tasks that need to be done before the request is actually handled. Typically,
these classes handle internal Laravel configuration that you do not need to worry about.
The HTTP kernel also defines a list of HTTP middleware that all requests must pass through before being handled by the
application. These middleware handle reading and writing the HTTP session, determining if the application is in
maintenance mode, verifying the CSRF token, and more. We'll talk more about these soon.
The method signature for the HTTP kernel's handle method is quite simple: it receives a Request and returns a
Response . Think of the kernel as being a big black box that represents your entire application. Feed it HTTP requests and
it will return HTTP responses.

Service Providers
Page 68 of 1307

Laravel 9.x

One of the most important kernel bootstrapping actions is loading the service providers for your application. Service
providers are responsible for bootstrapping all of the framework's various components, such as the database, queue,
validation, and routing components. All of the service providers for the application are configured in the config/app.php
configuration file's providers array.
Laravel will iterate through this list of providers and instantiate each of them. After instantiating the providers, the
register method will be called on all of the providers. Then, once all of the providers have been registered, the boot
method will be called on each provider. This is so service providers may depend on every container binding being
registered and available by the time their boot method is executed.
Essentially every major feature offered by Laravel is bootstrapped and configured by a service provider. Since they
bootstrap and configure so many features offered by the framework, service providers are the most important aspect of
the entire Laravel bootstrap process.

Routing

One of the most important service providers in your application is the App\Providers\RouteServiceProvider . This
service provider loads the route files contained within your application's routes directory. Go ahead, crack open the
RouteServiceProvider code and take a look at how it works!
Once the application has been bootstrapped and all service providers have been registered, the Request will be handed
off to the router for dispatching. The router will dispatch the request to a route or controller, as well as run any route
specific middleware.
Middleware provide a convenient mechanism for filtering or examining HTTP requests entering your application. For
example, Laravel includes a middleware that verifies if the user of your application is authenticated. If the user is not
authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the
middleware will allow the request to proceed further into the application. Some middleware are assigned to all routes within
the application, like those defined in the $middleware property of your HTTP kernel, while some are only assigned to
specific routes or route groups. You can learn more about middleware by reading the complete middleware documentation.
If the request passes through all of the matched route's assigned middleware, the route or controller method will be
executed and the response returned by the route or controller method will be sent back through the route's chain of
middleware.

Finishing Up

Once the route or controller method returns a response, the response will travel back outward through the route's
middleware, giving the application a chance to modify or examine the outgoing response.
Finally, once the response travels back through the middleware, the HTTP kernel's handle method returns the response
object and the index.php file calls the send method on the returned response. The send method sends the response
content to the user's web browser. We've finished our journey through the entire Laravel request lifecycle!

Focus On Service Providers

Service providers are truly the key to bootstrapping a Laravel application. The application instance is created, the service
providers are registered, and the request is handed to the bootstrapped application. It's really that simple!
Having a firm grasp of how a Laravel application is built and bootstrapped via service providers is very valuable. Your
application's default service providers are stored in the app/Providers directory.
By default, the AppServiceProvider is fairly empty. This provider is a great place to add your application's own
bootstrapping and service container bindings. For large applications, you may wish to create several service providers,
each with more granular bootstrapping for specific services used by your application.

Page 69 of 1307

Laravel 9.x

Service Container
Introduction
Zero Configuration Resolution
When To Use The Container
Binding
Binding Basics
Binding Interfaces To Implementations
Contextual Binding
Binding Primitives
Binding Typed Variadics
Tagging
Extending Bindings
Resolving
The Make Method
Automatic Injection
Method Invocation & Injection
Container Events
PSR-11

Introduction

The Laravel service container is a powerful tool for managing class dependencies and performing dependency injection.
Dependency injection is a fancy phrase that essentially means this: class dependencies are "injected" into the class via the
constructor or, in some cases, "setter" methods.
Let's look at a simple example:

Page 70 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Repositories\UserRepository;
use App\Models\User;
class UserController extends Controller
{
/**
* The user repository implementation.
*
* @var UserRepository
*/
protected $users;
/**
* Create a new controller instance.
*
* @param

UserRepository

$users

* @return void
*/
public function __construct(UserRepository $users)
{
$this->users = $users;
}
/**
* Show the profile for the given user.
*
* @param

int

$id

* @return Response
*/
public function show($id)
{
$user = $this->users->find($id);
return view('user.profile', ['user' => $user]);
}
}

In this example, the UserController needs to retrieve users from a data source. So, we will inject a service that is able
to retrieve users. In this context, our UserRepository most likely uses Eloquent to retrieve user information from the
database. However, since the repository is injected, we are able to easily swap it out with another implementation. We are
also able to easily "mock", or create a dummy implementation of the UserRepository when testing our application.
A deep understanding of the Laravel service container is essential to building a powerful, large application, as well as for
contributing to the Laravel core itself.

Zero Configuration Resolution

If a class has no dependencies or only depends on other concrete classes (not interfaces), the container does not need to
be instructed on how to resolve that class. For example, you may place the following code in your routes/web.php file:

Page 71 of 1307

Laravel 9.x

<?php
class Service
{
//
}
Route::get('/', function (Service $service) {
die(get_class($service));
});

In this example, hitting your application's / route will automatically resolve the Service class and inject it into your
route's handler. This is game changing. It means you can develop your application and take advantage of dependency
injection without worrying about bloated configuration files.
Thankfully, many of the classes you will be writing when building a Laravel application automatically receive their
dependencies via the container, including controllers, event listeners, middleware, and more. Additionally, you may typehint dependencies in the handle method of queued jobs. Once you taste the power of automatic and zero configuration
dependency injection it feels impossible to develop without it.

When To Use The Container

Thanks to zero configuration resolution, you will often type-hint dependencies on routes, controllers, event listeners, and
elsewhere without ever manually interacting with the container. For example, you might type-hint the
Illuminate\Http\Request object on your route definition so that you can easily access the current request. Even
though we never have to interact with the container to write this code, it is managing the injection of these dependencies
behind the scenes:
use Illuminate\Http\Request;
Route::get('/', function (Request $request) {
// ...
});

In many cases, thanks to automatic dependency injection and facades, you can build Laravel applications without ever
manually binding or resolving anything from the container. So, when would you ever manually interact with the
container? Let's examine two situations.
First, if you write a class that implements an interface and you wish to type-hint that interface on a route or class
constructor, you must tell the container how to resolve that interface. Secondly, if you are writing a Laravel package that
you plan to share with other Laravel developers, you may need to bind your package's services into the container.

Binding

Binding Basics

Simple Bindings
Almost all of your service container bindings will be registered within service providers, so most of these examples will
demonstrate using the container in that context.
Within a service provider, you always have access to the container via the $this->app property. We can register a
binding using the bind method, passing the class or interface name that we wish to register along with a closure that
returns an instance of the class:

Page 72 of 1307

Laravel 9.x

use App\Services\Transistor;
use App\Services\PodcastParser;
$this->app->bind(Transistor::class, function ($app) {
return new Transistor($app->make(PodcastParser::class));
});

Note that we receive the container itself as an argument to the resolver. We can then use the container to resolve subdependencies of the object we are building.
As mentioned, you will typically be interacting with the container within service providers; however, if you would like to
interact with the container outside of a service provider, you may do so via the App facade:
use App\Services\Transistor;
use Illuminate\Support\Facades\App;
App::bind(Transistor::class, function ($app) {
// ...
});

There is no need to bind classes into the container if they do not depend on any interfaces. The
container does not need to be instructed on how to build these objects, since it can automatically
resolve these objects using reflection.
Binding A Singleton
The singleton method binds a class or interface into the container that should only be resolved one time. Once a
singleton binding is resolved, the same object instance will be returned on subsequent calls into the container:
use App\Services\Transistor;
use App\Services\PodcastParser;
$this->app->singleton(Transistor::class, function ($app) {
return new Transistor($app->make(PodcastParser::class));
});

Binding Scoped Singletons
The scoped method binds a class or interface into the container that should only be resolved one time within a given
Laravel request / job lifecycle. While this method is similar to the singleton method, instances registered using the
scoped method will be flushed whenever the Laravel application starts a new "lifecycle", such as when a Laravel Octane
worker processes a new request or when a Laravel queue worker processes a new job:
use App\Services\Transistor;
use App\Services\PodcastParser;
$this->app->scoped(Transistor::class, function ($app) {
return new Transistor($app->make(PodcastParser::class));
});

Binding Instances
Page 73 of 1307

Laravel 9.x

You may also bind an existing object instance into the container using the instance method. The given instance will
always be returned on subsequent calls into the container:
use App\Services\Transistor;
use App\Services\PodcastParser;
$service = new Transistor(new PodcastParser);
$this->app->instance(Transistor::class, $service);

Binding Interfaces To Implementations

A very powerful feature of the service container is its ability to bind an interface to a given implementation. For example,
let's assume we have an EventPusher interface and a RedisEventPusher implementation. Once we have coded our
RedisEventPusher implementation of this interface, we can register it with the service container like so:
use App\Contracts\EventPusher;
use App\Services\RedisEventPusher;
$this->app->bind(EventPusher::class, RedisEventPusher::class);

This statement tells the container that it should inject the RedisEventPusher when a class needs an implementation of
EventPusher . Now we can type-hint the EventPusher interface in the constructor of a class that is resolved by the
container. Remember, controllers, event listeners, middleware, and various other types of classes within Laravel
applications are always resolved using the container:
use App\Contracts\EventPusher;
/**
* Create a new class instance.
*
* @param

\App\Contracts\EventPusher

$pusher

* @return void
*/
public function __construct(EventPusher $pusher)
{
$this->pusher = $pusher;
}

Contextual Binding

Sometimes you may have two classes that utilize the same interface, but you wish to inject different implementations into
each class. For example, two controllers may depend on different implementations of the
Illuminate\Contracts\Filesystem\Filesystem contract. Laravel provides a simple, fluent interface for defining this
behavior:

Page 74 of 1307

Laravel 9.x

use App\Http\Controllers\PhotoController;
use App\Http\Controllers\UploadController;
use App\Http\Controllers\VideoController;
use Illuminate\Contracts\Filesystem\Filesystem;
use Illuminate\Support\Facades\Storage;
$this->app->when(PhotoController::class)
->needs(Filesystem::class)
->give(function () {
return Storage::disk('local');
});
$this->app->when([VideoController::class, UploadController::class])
->needs(Filesystem::class)
->give(function () {
return Storage::disk('s3');
});

Binding Primitives

Sometimes you may have a class that receives some injected classes, but also needs an injected primitive value such as an
integer. You may easily use contextual binding to inject any value your class may need:
use App\Http\Controllers\UserController;
$this->app->when(UserController::class)
->needs('$variableName')
->give($value);

Sometimes a class may depend on an array of tagged instances. Using the giveTagged method, you may easily inject all
of the container bindings with that tag:
$this->app->when(ReportAggregator::class)
->needs('$reports')
->giveTagged('reports');

If you need to inject a value from one of your application's configuration files, you may use the giveConfig method:
$this->app->when(ReportAggregator::class)
->needs('$timezone')
->giveConfig('app.timezone');

Binding Typed Variadics

Occasionally, you may have a class that receives an array of typed objects using a variadic constructor argument:

Page 75 of 1307

Laravel 9.x

<?php
use App\Models\Filter;
use App\Services\Logger;
class Firewall
{
/**
* The logger instance.
*
* @var \App\Services\Logger
*/
protected $logger;
/**
* The filter instances.
*
* @var array
*/
protected $filters;
/**
* Create a new class instance.
*
* @param

\App\Services\Logger

* @param

array

$logger

$filters

* @return void
*/
public function __construct(Logger $logger, Filter ...$filters)
{
$this->logger = $logger;
$this->filters = $filters;
}
}

Using contextual binding, you may resolve this dependency by providing the give method with a closure that returns an
array of resolved Filter instances:
$this->app->when(Firewall::class)
->needs(Filter::class)
->give(function ($app) {
return [
$app->make(NullFilter::class),
$app->make(ProfanityFilter::class),
$app->make(TooLongFilter::class),
];
});

For convenience, you may also just provide an array of class names to be resolved by the container whenever Firewall
needs Filter instances:

Page 76 of 1307

Laravel 9.x

$this->app->when(Firewall::class)
->needs(Filter::class)
->give([
NullFilter::class,
ProfanityFilter::class,
TooLongFilter::class,
]);

Variadic Tag Dependencies
Sometimes a class may have a variadic dependency that is type-hinted as a given class ( Report ...$reports ). Using
the needs and giveTagged methods, you may easily inject all of the container bindings with that tag for the given
dependency:
$this->app->when(ReportAggregator::class)
->needs(Report::class)
->giveTagged('reports');

Tagging

Occasionally, you may need to resolve all of a certain "category" of binding. For example, perhaps you are building a report
analyzer that receives an array of many different Report interface implementations. After registering the Report
implementations, you can assign them a tag using the tag method:
$this->app->bind(CpuReport::class, function () {
//
});
$this->app->bind(MemoryReport::class, function () {
//
});
$this->app->tag([CpuReport::class, MemoryReport::class], 'reports');

Once the services have been tagged, you may easily resolve them all via the container's tagged method:
$this->app->bind(ReportAnalyzer::class, function ($app) {
return new ReportAnalyzer($app->tagged('reports'));
});

Extending Bindings

The extend method allows the modification of resolved services. For example, when a service is resolved, you may run
additional code to decorate or configure the service. The extend method accepts two arguments, the service class
you're extending and a closure that should return the modified service. The closure receives the service being resolved
and the container instance:
$this->app->extend(Service::class, function ($service, $app) {
return new DecoratedService($service);
});

Resolving
Page 77 of 1307

Laravel 9.x

The make Method

You may use the make method to resolve a class instance from the container. The make method accepts the name of
the class or interface you wish to resolve:
use App\Services\Transistor;
$transistor = $this->app->make(Transistor::class);

If some of your class' dependencies are not resolvable via the container, you may inject them by passing them as an
associative array into the makeWith method. For example, we may manually pass the $id constructor argument
required by the Transistor service:
use App\Services\Transistor;
$transistor = $this->app->makeWith(Transistor::class, ['id' => 1]);

If you are outside of a service provider in a location of your code that does not have access to the $app variable, you may
use the App facade or the app helper to resolve a class instance from the container:
use App\Services\Transistor;
use Illuminate\Support\Facades\App;
$transistor = App::make(Transistor::class);
$transistor = app(Transistor::class);

If you would like to have the Laravel container instance itself injected into a class that is being resolved by the container,
you may type-hint the Illuminate\Container\Container class on your class' constructor:
use Illuminate\Container\Container;
/**
* Create a new class instance.
*
* @param

\Illuminate\Container\Container

$container

* @return void
*/
public function __construct(Container $container)
{
$this->container = $container;
}

Automatic Injection

Alternatively, and importantly, you may type-hint the dependency in the constructor of a class that is resolved by the
container, including controllers, event listeners, middleware, and more. Additionally, you may type-hint dependencies in the
handle method of queued jobs. In practice, this is how most of your objects should be resolved by the container.
For example, you may type-hint a repository defined by your application in a controller's constructor. The repository will
automatically be resolved and injected into the class:

Page 78 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Repositories\UserRepository;
class UserController extends Controller
{
/**
* The user repository instance.
*
* @var \App\Repositories\UserRepository
*/
protected $users;
/**
* Create a new controller instance.
*
* @param

\App\Repositories\UserRepository

$users

* @return void
*/
public function __construct(UserRepository $users)
{
$this->users = $users;
}
/**
* Show the user with the given ID.
*
* @param

int

$id

* @return \Illuminate\Http\Response
*/
public function show($id)
{
//
}
}

Method Invocation & Injection

Sometimes you may wish to invoke a method on an object instance while allowing the container to automatically inject that
method's dependencies. For example, given the following class:

Page 79 of 1307

Laravel 9.x

<?php
namespace App;
use App\Repositories\UserRepository;
class UserReport
{
/**
* Generate a new user report.
*
* @param

\App\Repositories\UserRepository

$repository

* @return array
*/
public function generate(UserRepository $repository)
{
// ...
}
}

You may invoke the generate method via the container like so:
use App\UserReport;
use Illuminate\Support\Facades\App;
$report = App::call([new UserReport, 'generate']);

The call method accepts any PHP callable. The container's call method may even be used to invoke a closure while
automatically injecting its dependencies:
use App\Repositories\UserRepository;
use Illuminate\Support\Facades\App;
$result = App::call(function (UserRepository $repository) {
// ...
});

Container Events

The service container fires an event each time it resolves an object. You may listen to this event using the resolving
method:
use App\Services\Transistor;
$this->app->resolving(Transistor::class, function ($transistor, $app) {
// Called when container resolves objects of type "Transistor"...
});
$this->app->resolving(function ($object, $app) {
// Called when container resolves object of any type...
});

Page 80 of 1307

Laravel 9.x

As you can see, the object being resolved will be passed to the callback, allowing you to set any additional properties on
the object before it is given to its consumer.

PSR-11

Laravel's service container implements the PSR-11 interface. Therefore, you may type-hint the PSR-11 container interface
to obtain an instance of the Laravel container:
use App\Services\Transistor;
use Psr\Container\ContainerInterface;
Route::get('/', function (ContainerInterface $container) {
$service = $container->get(Transistor::class);
//
});

An exception is thrown if the given identifier can't be resolved. The exception will be an instance of
Psr\Container\NotFoundExceptionInterface if the identifier was never bound. If the identifier was bound but was
unable to be resolved, an instance of Psr\Container\ContainerExceptionInterface will be thrown.

Page 81 of 1307

Laravel 9.x

Service Providers
Introduction
Writing Service Providers
The Register Method
The Boot Method
Registering Providers
Deferred Providers

Introduction

Service providers are the central place of all Laravel application bootstrapping. Your own application, as well as all of
Laravel's core services, are bootstrapped via service providers.
But, what do we mean by "bootstrapped"? In general, we mean registering things, including registering service container
bindings, event listeners, middleware, and even routes. Service providers are the central place to configure your
application.
If you open the config/app.php file included with Laravel, you will see a providers array. These are all of the service
provider classes that will be loaded for your application. By default, a set of Laravel core service providers are listed in this
array. These providers bootstrap the core Laravel components, such as the mailer, queue, cache, and others. Many of
these providers are "deferred" providers, meaning they will not be loaded on every request, but only when the services
they provide are actually needed.
In this overview, you will learn how to write your own service providers and register them with your Laravel application.
If you would like to learn more about how Laravel handles requests and works internally, check out
our documentation on the Laravel request lifecycle.

Writing Service Providers

All service providers extend the Illuminate\Support\ServiceProvider class. Most service providers contain a
register and a boot method. Within the register method, you should only bind things into the service
container. You should never attempt to register any event listeners, routes, or any other piece of functionality within the
register method.
The Artisan CLI can generate a new provider via the make:provider command:
php artisan make:provider RiakServiceProvider

The Register Method

As mentioned previously, within the register method, you should only bind things into the service container. You should
never attempt to register any event listeners, routes, or any other piece of functionality within the register method.
Otherwise, you may accidentally use a service that is provided by a service provider which has not loaded yet.
Let's take a look at a basic service provider. Within any of your service provider methods, you always have access to the
$app property which provides access to the service container:

Page 82 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use App\Services\Riak\Connection;
use Illuminate\Support\ServiceProvider;
class RiakServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
$this->app->singleton(Connection::class, function ($app) {
return new Connection(config('riak'));
});
}
}

This service provider only defines a register method, and uses that method to define an implementation of
App\Services\Riak\Connection in the service container. If you're not yet familiar with Laravel's service container,
check out its documentation.
The bindings And singletons Properties
If your service provider registers many simple bindings, you may wish to use the bindings and singletons properties
instead of manually registering each container binding. When the service provider is loaded by the framework, it will
automatically check for these properties and register their bindings:

Page 83 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use App\Contracts\DowntimeNotifier;
use App\Contracts\ServerProvider;
use App\Services\DigitalOceanServerProvider;
use App\Services\PingdomDowntimeNotifier;
use App\Services\ServerToolsProvider;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
/**
* All of the container bindings that should be registered.
*
* @var array
*/
public $bindings = [
ServerProvider::class => DigitalOceanServerProvider::class,
];
/**
* All of the container singletons that should be registered.
*
* @var array
*/
public $singletons = [
DowntimeNotifier::class => PingdomDowntimeNotifier::class,
ServerProvider::class => ServerToolsProvider::class,
];
}

The Boot Method

So, what if we need to register a view composer within our service provider? This should be done within the boot
method. This method is called after all other service providers have been registered, meaning you have access to all
other services that have been registered by the framework:

Page 84 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\View;
use Illuminate\Support\ServiceProvider;
class ComposerServiceProvider extends ServiceProvider
{
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
View::composer('view', function () {
//
});
}
}

Boot Method Dependency Injection
You may type-hint dependencies for your service provider's boot method. The service container will automatically inject
any dependencies you need:
use Illuminate\Contracts\Routing\ResponseFactory;
/**
* Bootstrap any application services.
*
* @param

\Illuminate\Contracts\Routing\ResponseFactory

$response

* @return void
*/
public function boot(ResponseFactory $response)
{
$response->macro('serialized', function ($value) {
//
});
}

Registering Providers

All service providers are registered in the config/app.php configuration file. This file contains a providers array
where you can list the class names of your service providers. By default, a set of Laravel core service providers are listed in
this array. These providers bootstrap the core Laravel components, such as the mailer, queue, cache, and others.
To register your provider, add it to the array:

Page 85 of 1307

Laravel 9.x

'providers' => [
// Other Service Providers
App\Providers\ComposerServiceProvider::class,
],

Deferred Providers

If your provider is only registering bindings in the service container, you may choose to defer its registration until one of
the registered bindings is actually needed. Deferring the loading of such a provider will improve the performance of your
application, since it is not loaded from the filesystem on every request.
Laravel compiles and stores a list of all of the services supplied by deferred service providers, along with the name of its
service provider class. Then, only when you attempt to resolve one of these services does Laravel load the service
provider.
To defer the loading of a provider, implement the \Illuminate\Contracts\Support\DeferrableProvider interface
and define a provides method. The provides method should return the service container bindings registered by the
provider:
<?php
namespace App\Providers;
use App\Services\Riak\Connection;
use Illuminate\Contracts\Support\DeferrableProvider;
use Illuminate\Support\ServiceProvider;
class RiakServiceProvider extends ServiceProvider implements DeferrableProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
$this->app->singleton(Connection::class, function ($app) {
return new Connection($app['config']['riak']);
});
}
/**
* Get the services provided by the provider.
*
* @return array
*/
public function provides()
{
return [Connection::class];
}
}

Page 86 of 1307

Laravel 9.x

Introduction
When To Use Facades
Facades Vs. Dependency Injection
Facades Vs. Helper Functions
How Facades Work
Real-Time Facades
Facade Class Reference

Facades

Introduction

Throughout the Laravel documentation, you will see examples of code that interacts with Laravel's features via "facades".
Facades provide a "static" interface to classes that are available in the application's service container. Laravel ships with
many facades which provide access to almost all of Laravel's features.
Laravel facades serve as "static proxies" to underlying classes in the service container, providing the benefit of a terse,
expressive syntax while maintaining more testability and flexibility than traditional static methods. It's perfectly fine if you
don't totally understand how facades work - just go with the flow and continue learning about Laravel.
All of Laravel's facades are defined in the Illuminate\Support\Facades namespace. So, we can easily access a facade
like so:
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Route;
Route::get('/cache', function () {
return Cache::get('key');
});

Throughout the Laravel documentation, many of the examples will use facades to demonstrate various features of the
framework.
Helper Functions
To complement facades, Laravel offers a variety of global "helper functions" that make it even easier to interact with
common Laravel features. Some of the common helper functions you may interact with are view , response , url ,
config , and more. Each helper function offered by Laravel is documented with their corresponding feature; however, a
complete list is available within the dedicated helper documentation.
For example, instead of using the Illuminate\Support\Facades\Response facade to generate a JSON response, we
may simply use the response function. Because helper functions are globally available, you do not need to import any
classes in order to use them:

Page 87 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Response;
Route::get('/users', function () {
return Response::json([
// ...
]);
});
Route::get('/users', function () {
return response()->json([
// ...
]);
});

When To Use Facades

Facades have many benefits. They provide a terse, memorable syntax that allows you to use Laravel's features without
remembering long class names that must be injected or configured manually. Furthermore, because of their unique usage
of PHP's dynamic methods, they are easy to test.
However, some care must be taken when using facades. The primary danger of facades is class "scope creep". Since
facades are so easy to use and do not require injection, it can be easy to let your classes continue to grow and use many
facades in a single class. Using dependency injection, this potential is mitigated by the visual feedback a large constructor
gives you that your class is growing too large. So, when using facades, pay special attention to the size of your class so
that its scope of responsibility stays narrow. If your class is getting too large, consider splitting it into multiple smaller
classes.

Facades Vs. Dependency Injection

One of the primary benefits of dependency injection is the ability to swap implementations of the injected class. This is
useful during testing since you can inject a mock or stub and assert that various methods were called on the stub.
Typically, it would not be possible to mock or stub a truly static class method. However, since facades use dynamic
methods to proxy method calls to objects resolved from the service container, we actually can test facades just as we
would test an injected class instance. For example, given the following route:
use Illuminate\Support\Facades\Cache;
Route::get('/cache', function () {
return Cache::get('key');
});

Using Laravel's facade testing methods, we can write the following test to verify that the Cache::get method was called
with the argument we expected:

Page 88 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Cache;
/**
* A basic functional test example.
*
* @return void
*/
public function testBasicExample()
{
Cache::shouldReceive('get')
->with('key')
->andReturn('value');
$response = $this->get('/cache');
$response->assertSee('value');
}

Facades Vs. Helper Functions

In addition to facades, Laravel includes a variety of "helper" functions which can perform common tasks like generating
views, firing events, dispatching jobs, or sending HTTP responses. Many of these helper functions perform the same
function as a corresponding facade. For example, this facade call and helper call are equivalent:
return Illuminate\Support\Facades\View::make('profile');
return view('profile');

There is absolutely no practical difference between facades and helper functions. When using helper functions, you may
still test them exactly as you would the corresponding facade. For example, given the following route:
Route::get('/cache', function () {
return cache('key');
});

The cache helper is going to call the get method on the class underlying the Cache facade. So, even though we are
using the helper function, we can write the following test to verify that the method was called with the argument we
expected:

Page 89 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Cache;
/**
* A basic functional test example.
*
* @return void
*/
public function testBasicExample()
{
Cache::shouldReceive('get')
->with('key')
->andReturn('value');
$response = $this->get('/cache');
$response->assertSee('value');
}

How Facades Work

In a Laravel application, a facade is a class that provides access to an object from the container. The machinery that makes
this work is in the Facade class. Laravel's facades, and any custom facades you create, will extend the base
Illuminate\Support\Facades\Facade class.
The Facade base class makes use of the __callStatic() magic-method to defer calls from your facade to an object
resolved from the container. In the example below, a call is made to the Laravel cache system. By glancing at this code, one
might assume that the static get method is being called on the Cache class:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\Cache;
class UserController extends Controller
{
/**
* Show the profile for the given user.
*
* @param

int

$id

* @return Response
*/
public function showProfile($id)
{
$user = Cache::get('user:'.$id);
return view('profile', ['user' => $user]);
}
}

Notice that near the top of the file we are "importing" the Cache facade. This facade serves as a proxy for accessing the
underlying implementation of the Illuminate\Contracts\Cache\Factory interface. Any calls we make using the
facade will be passed to the underlying instance of Laravel's cache service.
Page 90 of 1307

Laravel 9.x

If we look at that Illuminate\Support\Facades\Cache class, you'll see that there is no static method get :
class Cache extends Facade
{
/**
* Get the registered name of the component.
*
* @return string
*/
protected static function getFacadeAccessor() { return 'cache'; }
}

Instead, the Cache facade extends the base Facade class and defines the method getFacadeAccessor() . This
method's job is to return the name of a service container binding. When a user references any static method on the
Cache facade, Laravel resolves the cache binding from the service container and runs the requested method (in this
case, get ) against that object.

Real-Time Facades

Using real-time facades, you may treat any class in your application as if it was a facade. To illustrate how this can be used,
let's first examine some code that does not use real-time facades. For example, let's assume our Podcast model has a
publish method. However, in order to publish the podcast, we need to inject a Publisher instance:
<?php
namespace App\Models;
use App\Contracts\Publisher;
use Illuminate\Database\Eloquent\Model;
class Podcast extends Model
{
/**
* Publish the podcast.
*
* @param

Publisher

$publisher

* @return void
*/
public function publish(Publisher $publisher)
{
$this->update(['publishing' => now()]);
$publisher->publish($this);
}
}

Injecting a publisher implementation into the method allows us to easily test the method in isolation since we can mock the
injected publisher. However, it requires us to always pass a publisher instance each time we call the publish method.
Using real-time facades, we can maintain the same testability while not being required to explicitly pass a Publisher
instance. To generate a real-time facade, prefix the namespace of the imported class with Facades :

Page 91 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Facades\App\Contracts\Publisher;
use Illuminate\Database\Eloquent\Model;
class Podcast extends Model
{
/**
* Publish the podcast.
*
* @return void
*/
public function publish()
{
$this->update(['publishing' => now()]);
Publisher::publish($this);
}
}

When the real-time facade is used, the publisher implementation will be resolved out of the service container using the
portion of the interface or class name that appears after the Facades prefix. When testing, we can use Laravel's built-in
facade testing helpers to mock this method call:
<?php
namespace Tests\Feature;
use App\Models\Podcast;
use Facades\App\Contracts\Publisher;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;
class PodcastTest extends TestCase
{
use RefreshDatabase;
/**
* A test example.
*
* @return void
*/
public function test_podcast_can_be_published()
{
$podcast = Podcast::factory()->create();
Publisher::shouldReceive('publish')->once()->with($podcast);
$podcast->publish();
}
}

Page 92 of 1307

Laravel 9.x

Facade Class Reference

Below you will find every facade and its underlying class. This is a useful tool for quickly digging into the API
documentation for a given facade root. The service container binding key is also included where applicable.

Page 93 of 1307

Laravel 9.x

Facade
App
Artisan
Auth
Auth (Instance)
Blade
Broadcast
Broadcast (Instance)
Bus
Cache
Cache (Instance)
Config
Cookie
Crypt
Date
DB
DB (Instance)
Event
File
Gate
Hash
Http
Lang
Log
Mail
Notification
Password
Password (Instance)
Queue
Queue (Instance)
Queue (Base Class)
Redirect

Class
Illuminate\Foundation\Application
Illuminate\Contracts\Console\Kernel
Illuminate\Auth\AuthManager
Illuminate\Contracts\Auth\Guard
Illuminate\View\Compilers\BladeCompiler
Illuminate\Contracts\Broadcasting\Factory
Illuminate\Contracts\Broadcasting\Broadcaster
Illuminate\Contracts\Bus\Dispatcher
Illuminate\Cache\CacheManager
Illuminate\Cache\Repository
Illuminate\Config\Repository
Illuminate\Cookie\CookieJar
Illuminate\Encryption\Encrypter
Illuminate\Support\DateFactory
Illuminate\Database\DatabaseManager
Illuminate\Database\Connection
Illuminate\Events\Dispatcher
Illuminate\Filesystem\Filesystem
Illuminate\Contracts\Auth\Access\Gate
Illuminate\Contracts\Hashing\Hasher
Illuminate\Http\Client\Factory
Illuminate\Translation\Translator
Illuminate\Log\LogManager
Illuminate\Mail\Mailer
Illuminate\Notifications\ChannelManager
Illuminate\Auth\Passwords\PasswordBrokerManager
Illuminate\Auth\Passwords\PasswordBroker
Illuminate\Queue\QueueManager
Illuminate\Contracts\Queue\Queue
Illuminate\Queue\Queue
Illuminate\Routing\Redirector

Page 94 of 1307

Service Container Binding
app
artisan
auth
auth.driver
blade.compiler

cache
cache.store
config
cookie
encrypter
date
db
db.connection
events
files

hash

translator
log
mailer

auth.password
auth.password.broker
queue
queue.connection

redirect

Laravel 9.x

Redis
Redis (Instance)
Request
Response
Response (Instance)
Route
Schema
Session
Session (Instance)
Storage
Storage (Instance)
URL
Validator
Validator (Instance)
View
View (Instance)
Vite

Illuminate\Redis\RedisManager
Illuminate\Redis\Connections\Connection
Illuminate\Http\Request
Illuminate\Contracts\Routing\ResponseFactory
Illuminate\Http\Response
Illuminate\Routing\Router
Illuminate\Database\Schema\Builder
Illuminate\Session\SessionManager
Illuminate\Session\Store
Illuminate\Filesystem\FilesystemManager
Illuminate\Contracts\Filesystem\Filesystem
Illuminate\Routing\UrlGenerator
Illuminate\Validation\Factory
Illuminate\Validation\Validator
Illuminate\View\Factory
Illuminate\View\View
Illuminate\Foundation\Vite

Page 95 of 1307

redis
redis.connection
request

router

session
session.store
filesystem
filesystem.disk
url
validator

view

Laravel 9.x

Chapter 4

The Basics

Page 96 of 1307

Laravel 9.x

Basic Routing
Redirect Routes
View Routes
The Route List
Route Parameters
Required Parameters
Optional Parameters
Regular Expression Constraints
Named Routes
Route Groups
Middleware
Controllers
Subdomain Routing
Route Prefixes
Route Name Prefixes
Route Model Binding
Implicit Binding
Implicit Enum Binding
Explicit Binding
Fallback Routes
Rate Limiting
Defining Rate Limiters
Attaching Rate Limiters To Routes
Form Method Spoofing
Accessing The Current Route
Cross-Origin Resource Sharing (CORS)
Route Caching

Routing

Basic Routing

The most basic Laravel routes accept a URI and a closure, providing a very simple and expressive method of defining
routes and behavior without complicated routing configuration files:
use Illuminate\Support\Facades\Route;
Route::get('/greeting', function () {
return 'Hello World';
});

The Default Route Files
All Laravel routes are defined in your route files, which are located in the routes directory. These files are automatically
loaded by your application's App\Providers\RouteServiceProvider . The routes/web.php file defines routes that
are for your web interface. These routes are assigned the web middleware group, which provides features like session
state and CSRF protection. The routes in routes/api.php are stateless and are assigned the api middleware group.
For most applications, you will begin by defining routes in your routes/web.php file. The routes defined in
routes/web.php may be accessed by entering the defined route's URL in your browser. For example, you may access
the following route by navigating to http://example.com/user in your browser:

Page 97 of 1307

Laravel 9.x

use App\Http\Controllers\UserController;
Route::get('/user', [UserController::class, 'index']);

Routes defined in the routes/api.php file are nested within a route group by the RouteServiceProvider . Within this
group, the /api URI prefix is automatically applied so you do not need to manually apply it to every route in the file. You
may modify the prefix and other route group options by modifying your RouteServiceProvider class.
Available Router Methods
The router allows you to register routes that respond to any HTTP verb:
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

Sometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the match
method. Or, you may even register a route that responds to all HTTP verbs using the any method:
Route::match(['get', 'post'], '/', function () {
//
});
Route::any('/', function () {
//
});

When defining multiple routes that share the same URI, routes using the get , post , put ,
patch , delete , and options methods should be defined before routes using the any ,
match , and redirect methods. This ensures the incoming request is matched with the correct
route.
Dependency Injection
You may type-hint any dependencies required by your route in your route's callback signature. The declared dependencies
will automatically be resolved and injected into the callback by the Laravel service container. For example, you may typehint the Illuminate\Http\Request class to have the current HTTP request automatically injected into your route
callback:
use Illuminate\Http\Request;
Route::get('/users', function (Request $request) {
// ...
});

CSRF Protection

Page 98 of 1307

Laravel 9.x

Remember, any HTML forms pointing to POST , PUT , PATCH , or DELETE routes that are defined in the web routes file
should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the
CSRF documentation:
<form method="POST" action="/profile">
@csrf
...
</form>

Redirect Routes

If you are defining a route that redirects to another URI, you may use the Route::redirect method. This method
provides a convenient shortcut so that you do not have to define a full route or controller for performing a simple redirect:
Route::redirect('/here', '/there');

By default, Route::redirect returns a 302 status code. You may customize the status code using the optional third
parameter:
Route::redirect('/here', '/there', 301);

Or, you may use the Route::permanentRedirect method to return a 301 status code:
Route::permanentRedirect('/here', '/there');

When using route parameters in redirect routes, the following parameters are reserved by Laravel
and cannot be used: destination and status .

View Routes

If your route only needs to return a view, you may use the Route::view method. Like the redirect method, this
method provides a simple shortcut so that you do not have to define a full route or controller. The view method accepts
a URI as its first argument and a view name as its second argument. In addition, you may provide an array of data to pass
to the view as an optional third argument:
Route::view('/welcome', 'welcome');
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

When using route parameters in view routes, the following parameters are reserved by Laravel and
cannot be used: view , data , status , and headers .

The Route List

The route:list Artisan command can easily provide an overview of all of the routes that are defined by your
application:
Page 99 of 1307

Laravel 9.x

php artisan route:list

By default, the route middleware that are assigned to each route will not be displayed in the route:list output;
however, you can instruct Laravel to display the route middleware by adding the -v option to the command:
php artisan route:list -v

You may also instruct Laravel to only show routes that begin with a given URI:
php artisan route:list --path=api

In addition, you may instruct Laravel to hide any routes that are defined by third-party packages by providing the -except-vendor option when executing the route:list command:
php artisan route:list --except-vendor

Likewise, you may also instruct Laravel to only show routes that are defined by third-party packages by providing the -only-vendor option when executing the route:list command:
php artisan route:list --only-vendor

Route Parameters
Required Parameters

Sometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's
ID from the URL. You may do so by defining route parameters:
Route::get('/user/{id}', function ($id) {
return 'User '.$id;
});

You may define as many route parameters as required by your route:
Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {
//
});

Route parameters are always encased within {} braces and should consist of alphabetic characters. Underscores ( _ )
are also acceptable within route parameter names. Route parameters are injected into route callbacks / controllers based
on their order - the names of the route callback / controller arguments do not matter.
Parameters & Dependency Injection
If your route has dependencies that you would like the Laravel service container to automatically inject into your route's
callback, you should list your route parameters after your dependencies:

Page 100 of 1307

Laravel 9.x

use Illuminate\Http\Request;
Route::get('/user/{id}', function (Request $request, $id) {
return 'User '.$id;
});

Optional Parameters

Occasionally you may need to specify a route parameter that may not always be present in the URI. You may do so by
placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value:
Route::get('/user/{name?}', function ($name = null) {
return $name;
});
Route::get('/user/{name?}', function ($name = 'John') {
return $name;
});

Regular Expression Constraints

You may constrain the format of your route parameters using the where method on a route instance. The where
method accepts the name of the parameter and a regular expression defining how the parameter should be constrained:
Route::get('/user/{name}', function ($name) {
//
})->where('name', '[A-Za-z]+');
Route::get('/user/{id}', function ($id) {
//
})->where('id', '[0-9]+');
Route::get('/user/{id}/{name}', function ($id, $name) {
//
})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

For convenience, some commonly used regular expression patterns have helper methods that allow you to quickly add
pattern constraints to your routes:

Page 101 of 1307

Laravel 9.x

Route::get('/user/{id}/{name}', function ($id, $name) {
//
})->whereNumber('id')->whereAlpha('name');
Route::get('/user/{name}', function ($name) {
//
})->whereAlphaNumeric('name');
Route::get('/user/{id}', function ($id) {
//
})->whereUuid('id');
Route::get('/user/{id}', function ($id) {
//
})->whereUlid('id');
Route::get('/category/{category}', function ($category) {
//
})->whereIn('category', ['movie', 'song', 'painting']);

If the incoming request does not match the route pattern constraints, a 404 HTTP response will be returned.
Global Constraints
If you would like a route parameter to always be constrained by a given regular expression, you may use the pattern
method. You should define these patterns in the boot method of your App\Providers\RouteServiceProvider class:
/**
* Define your route model bindings, pattern filters, etc.
*
* @return void
*/
public function boot()
{
Route::pattern('id', '[0-9]+');
}

Once the pattern has been defined, it is automatically applied to all routes using that parameter name:
Route::get('/user/{id}', function ($id) {
// Only executed if {id} is numeric...
});

Encoded Forward Slashes
The Laravel routing component allows all characters except / to be present within route parameter values. You must
explicitly allow / to be part of your placeholder using a where condition regular expression:
Route::get('/search/{search}', function ($search) {
return $search;
})->where('search', '.*');

Page 102 of 1307

Laravel 9.x

Encoded forward slashes are only supported within the last route segment.

Named Routes

Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route
by chaining the name method onto the route definition:
Route::get('/user/profile', function () {
//
})->name('profile');

You may also specify route names for controller actions:
Route::get(
'/user/profile',
[UserProfileController::class, 'show']
)->name('profile');

Route names should always be unique.
Generating URLs To Named Routes
Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via
Laravel's route and redirect helper functions:
// Generating URLs...
$url = route('profile');
// Generating Redirects...
return redirect()->route('profile');
return to_route('profile');

If the named route defines parameters, you may pass the parameters as the second argument to the route function. The
given parameters will automatically be inserted into the generated URL in their correct positions:
Route::get('/user/{id}/profile', function ($id) {
//
})->name('profile');
$url = route('profile', ['id' => 1]);

If you pass additional parameters in the array, those key / value pairs will automatically be added to the generated URL's
query string:

Page 103 of 1307

Laravel 9.x

Route::get('/user/{id}/profile', function ($id) {
//
})->name('profile');
$url = route('profile', ['id' => 1, 'photos' => 'yes']);
// /user/1/profile?photos=yes

Sometimes, you may wish to specify request-wide default values for URL parameters, such as the
current locale. To accomplish this, you may use the URL::defaults method.
Inspecting The Current Route
If you would like to determine if the current request was routed to a given named route, you may use the named method
on a Route instance. For example, you may check the current route name from a route middleware:
/**
* Handle an incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

$request

$next

* @return mixed
*/
public function handle($request, Closure $next)
{
if ($request->route()->named('profile')) {
//
}
return $next($request);
}

Route Groups

Route groups allow you to share route attributes, such as middleware, across a large number of routes without needing to
define those attributes on each individual route.
Nested groups attempt to intelligently "merge" attributes with their parent group. Middleware and where conditions are
merged while names and prefixes are appended. Namespace delimiters and slashes in URI prefixes are automatically
added where appropriate.

Middleware

To assign middleware to all routes within a group, you may use the middleware method before defining the group.
Middleware are executed in the order they are listed in the array:

Page 104 of 1307

Laravel 9.x

Route::middleware(['first', 'second'])->group(function () {
Route::get('/', function () {
// Uses first & second middleware...
});
Route::get('/user/profile', function () {
// Uses first & second middleware...
});
});

Controllers

If a group of routes all utilize the same controller, you may use the controller method to define the common controller
for all of the routes within the group. Then, when defining the routes, you only need to provide the controller method that
they invoke:
use App\Http\Controllers\OrderController;
Route::controller(OrderController::class)->group(function () {
Route::get('/orders/{id}', 'show');
Route::post('/orders', 'store');
});

Subdomain Routing

Route groups may also be used to handle subdomain routing. Subdomains may be assigned route parameters just like
route URIs, allowing you to capture a portion of the subdomain for usage in your route or controller. The subdomain may be
specified by calling the domain method before defining the group:
Route::domain('{account}.example.com')->group(function () {
Route::get('user/{id}', function ($account, $id) {
//
});
});

In order to ensure your subdomain routes are reachable, you should register subdomain routes
before registering root domain routes. This will prevent root domain routes from overwriting
subdomain routes which have the same URI path.

Route Prefixes

The prefix method may be used to prefix each route in the group with a given URI. For example, you may want to prefix
all route URIs within the group with admin :
Route::prefix('admin')->group(function () {
Route::get('/users', function () {
// Matches The "/admin/users" URL
});
});

Page 105 of 1307

Laravel 9.x

Route Name Prefixes

The name method may be used to prefix each route name in the group with a given string. For example, you may want to
prefix all of the grouped route's names with admin . The given string is prefixed to the route name exactly as it is
specified, so we will be sure to provide the trailing . character in the prefix:
Route::name('admin.')->group(function () {
Route::get('/users', function () {
// Route assigned name "admin.users"...
})->name('users');
});

Route Model Binding

When injecting a model ID to a route or controller action, you will often query the database to retrieve the model that
corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances
directly into your routes. For example, instead of injecting a user's ID, you can inject the entire User model instance that
matches the given ID.

Implicit Binding

Laravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names
match a route segment name. For example:
use App\Models\User;
Route::get('/users/{user}', function (User $user) {
return $user->email;
});

Since the $user variable is type-hinted as the App\Models\User Eloquent model and the variable name matches the
{user} URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding
value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will
automatically be generated.
Of course, implicit binding is also possible when using controller methods. Again, note the {user} URI segment matches
the $user variable in the controller which contains an App\Models\User type-hint:
use App\Http\Controllers\UserController;
use App\Models\User;
// Route definition...
Route::get('/users/{user}', [UserController::class, 'show']);
// Controller method definition...
public function show(User $user)
{
return view('user.profile', ['user' => $user]);
}

Soft Deleted Models
Typically, implicit model binding will not retrieve models that have been soft deleted. However, you may instruct the implicit
binding to retrieve these models by chaining the withTrashed method onto your route's definition:

Page 106 of 1307

Laravel 9.x

use App\Models\User;
Route::get('/users/{user}', function (User $user) {
return $user->email;
})->withTrashed();

Customizing The Key
Sometimes you may wish to resolve Eloquent models using a column other than id . To do so, you may specify the
column in the route parameter definition:
use App\Models\Post;
Route::get('/posts/{post:slug}', function (Post $post) {
return $post;
});

If you would like model binding to always use a database column other than id when retrieving a given model class, you
may override the getRouteKeyName method on the Eloquent model:
/**
* Get the route key for the model.
*
* @return string
*/
public function getRouteKeyName()
{
return 'slug';
}

Custom Keys & Scoping
When implicitly binding multiple Eloquent models in a single route definition, you may wish to scope the second Eloquent
model such that it must be a child of the previous Eloquent model. For example, consider this route definition that retrieves
a blog post by slug for a specific user:
use App\Models\Post;
use App\Models\User;
Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
return $post;
});

When using a custom keyed implicit binding as a nested route parameter, Laravel will automatically scope the query to
retrieve the nested model by its parent using conventions to guess the relationship name on the parent. In this case, it will
be assumed that the User model has a relationship named posts (the plural form of the route parameter name) which
can be used to retrieve the Post model.
If you wish, you may instruct Laravel to scope "child" bindings even when a custom key is not provided. To do so, you may
invoke the scopeBindings method when defining your route:

Page 107 of 1307

Laravel 9.x

use App\Models\Post;
use App\Models\User;
Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
return $post;
})->scopeBindings();

Or, you may instruct an entire group of route definitions to use scoped bindings:
Route::scopeBindings()->group(function () {
Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
return $post;
});
});

Similarly, you may explicitly instruct Laravel to not scope bindings by invoking the withoutScopedBindings method:
Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
return $post;
})->withoutScopedBindings();

Customizing Missing Model Behavior
Typically, a 404 HTTP response will be generated if an implicitly bound model is not found. However, you may customize
this behavior by calling the missing method when defining your route. The missing method accepts a closure that will
be invoked if an implicitly bound model can not be found:
use App\Http\Controllers\LocationsController;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Redirect;
Route::get('/locations/{location:slug}', [LocationsController::class, 'show'])
->name('locations.view')
->missing(function (Request $request) {
return Redirect::route('locations.index');
});

Implicit Enum Binding

PHP 8.1 introduced support for Enums. To compliment this feature, Laravel allows you to type-hint a string-backed Enum
on your route definition and Laravel will only invoke the route if that route segment corresponds to a valid Enum value.
Otherwise, a 404 HTTP response will be returned automatically. For example, given the following Enum:
<?php
namespace App\Enums;
enum Category: string
{
case Fruits = 'fruits';
case People = 'people';
}

Page 108 of 1307

Laravel 9.x

You may define a route that will only be invoked if the {category} route segment is fruits or people . Otherwise,
Laravel will return a 404 HTTP response:
use App\Enums\Category;
use Illuminate\Support\Facades\Route;
Route::get('/categories/{category}', function (Category $category) {
return $category->value;
});

Explicit Binding

You are not required to use Laravel's implicit, convention based model resolution in order to use model binding. You can
also explicitly define how route parameters correspond to models. To register an explicit binding, use the router's model
method to specify the class for a given parameter. You should define your explicit model bindings at the beginning of the
boot method of your RouteServiceProvider class:
use App\Models\User;
use Illuminate\Support\Facades\Route;
/**
* Define your route model bindings, pattern filters, etc.
*
* @return void
*/
public function boot()
{
Route::model('user', User::class);
// ...
}

Next, define a route that contains a {user} parameter:
use App\Models\User;
Route::get('/users/{user}', function (User $user) {
//
});

Since we have bound all {user} parameters to the App\Models\User model, an instance of that class will be injected
into the route. So, for example, a request to users/1 will inject the User instance from the database which has an ID of
1 .
If a matching model instance is not found in the database, a 404 HTTP response will be automatically generated.
Customizing The Resolution Logic
If you wish to define your own model binding resolution logic, you may use the Route::bind method. The closure you
pass to the bind method will receive the value of the URI segment and should return the instance of the class that should
be injected into the route. Again, this customization should take place in the boot method of your application's
RouteServiceProvider :

Page 109 of 1307

Laravel 9.x

use App\Models\User;
use Illuminate\Support\Facades\Route;
/**
* Define your route model bindings, pattern filters, etc.
*
* @return void
*/
public function boot()
{
Route::bind('user', function ($value) {
return User::where('name', $value)->firstOrFail();
});
// ...
}

Alternatively, you may override the resolveRouteBinding method on your Eloquent model. This method will receive the
value of the URI segment and should return the instance of the class that should be injected into the route:
/**
* Retrieve the model for a bound value.
*
* @param

mixed

* @param

string|null

$value
$field

* @return \Illuminate\Database\Eloquent\Model|null
*/
public function resolveRouteBinding($value, $field = null)
{
return $this->where('name', $value)->firstOrFail();
}

If a route is utilizing implicit binding scoping, the resolveChildRouteBinding method will be used to resolve the child
binding of the parent model:
/**
* Retrieve the child model for a bound value.
*
* @param

string

$childType

* @param

mixed

$value

* @param

string|null

$field

* @return \Illuminate\Database\Eloquent\Model|null
*/
public function resolveChildRouteBinding($childType, $value, $field)
{
return parent::resolveChildRouteBinding($childType, $value, $field);
}

Fallback Routes

Using the Route::fallback method, you may define a route that will be executed when no other route matches the
incoming request. Typically, unhandled requests will automatically render a "404" page via your application's exception
handler. However, since you would typically define the fallback route within your routes/web.php file, all middleware
in the web middleware group will apply to the route. You are free to add additional middleware to this route as needed:
Page 110 of 1307

Laravel 9.x

Route::fallback(function () {
//
});

The fallback route should always be the last route registered by your application.

Rate Limiting

Defining Rate Limiters

Laravel includes powerful and customizable rate limiting services that you may utilize to restrict the amount of traffic for a
given route or group of routes. To get started, you should define rate limiter configurations that meet your application's
needs. Typically, this should be done within the configureRateLimiting method of your application's
App\Providers\RouteServiceProvider class, which already includes a rate limiter definition that is applied to the
routes in your application's routes/api.php file:
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
/**
* Configure the rate limiters for the application.
*/
protected function configureRateLimiting(): void
{
RateLimiter::for('api', function (Request $request) {
return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
});
}

Rate limiters are defined using the RateLimiter facade's for method. The for method accepts a rate limiter name
and a closure that returns the limit configuration that should apply to routes that are assigned to the rate limiter. Limit
configuration are instances of the Illuminate\Cache\RateLimiting\Limit class. This class contains helpful "builder"
methods so that you can quickly define your limit. The rate limiter name may be any string you wish:
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
/**
* Configure the rate limiters for the application.
*
* @return void
*/
protected function configureRateLimiting()
{
RateLimiter::for('global', function (Request $request) {
return Limit::perMinute(1000);
});
}

Page 111 of 1307

Laravel 9.x

If the incoming request exceeds the specified rate limit, a response with a 429 HTTP status code will automatically be
returned by Laravel. If you would like to define your own response that should be returned by a rate limit, you may use the
response method:
RateLimiter::for('global', function (Request $request) {
return Limit::perMinute(1000)->response(function (Request $request, array $headers) {
return response('Custom response...', 429, $headers);
});
});

Since rate limiter callbacks receive the incoming HTTP request instance, you may build the appropriate rate limit
dynamically based on the incoming request or authenticated user:
RateLimiter::for('uploads', function (Request $request) {
return $request->user()->vipCustomer()
? Limit::none()
: Limit::perMinute(100);
});

Segmenting Rate Limits
Sometimes you may wish to segment rate limits by some arbitrary value. For example, you may wish to allow users to
access a given route 100 times per minute per IP address. To accomplish this, you may use the by method when building
your rate limit:
RateLimiter::for('uploads', function (Request $request) {
return $request->user()->vipCustomer()
? Limit::none()
: Limit::perMinute(100)->by($request->ip());
});

To illustrate this feature using another example, we can limit access to the route to 100 times per minute per authenticated
user ID or 10 times per minute per IP address for guests:
RateLimiter::for('uploads', function (Request $request) {
return $request->user()
? Limit::perMinute(100)->by($request->user()->id)
: Limit::perMinute(10)->by($request->ip());
});

Multiple Rate Limits
If needed, you may return an array of rate limits for a given rate limiter configuration. Each rate limit will be evaluated for
the route based on the order they are placed within the array:
RateLimiter::for('login', function (Request $request) {
return [
Limit::perMinute(500),
Limit::perMinute(3)->by($request->input('email')),
];
});

Attaching Rate Limiters To Routes
Page 112 of 1307

Laravel 9.x

Rate limiters may be attached to routes or route groups using the throttle middleware. The throttle middleware
accepts the name of the rate limiter you wish to assign to the route:
Route::middleware(['throttle:uploads'])->group(function () {
Route::post('/audio', function () {
//
});
Route::post('/video', function () {
//
});
});

Throttling With Redis
Typically, the throttle middleware is mapped to the Illuminate\Routing\Middleware\ThrottleRequests class.
This mapping is defined in your application's HTTP kernel ( App\Http\Kernel ). However, if you are using Redis as your
application's cache driver, you may wish to change this mapping to use the
Illuminate\Routing\Middleware\ThrottleRequestsWithRedis class. This class is more efficient at managing rate
limiting using Redis:
'throttle' => \Illuminate\Routing\Middleware\ThrottleRequestsWithRedis::class,

Form Method Spoofing

HTML forms do not support PUT , PATCH , or DELETE actions. So, when defining PUT , PATCH , or DELETE routes
that are called from an HTML form, you will need to add a hidden _method field to the form. The value sent with the
_method field will be used as the HTTP request method:
<form action="/example" method="POST">
<input type="hidden" name="_method" value="PUT">
<input type="hidden" name="_token" value="{{ csrf_token() }}">
</form>

For convenience, you may use the @method Blade directive to generate the _method input field:
<form action="/example" method="POST">
@method('PUT')
@csrf
</form>

Accessing The Current Route

You may use the current , currentRouteName , and currentRouteAction methods on the Route facade to access
information about the route handling the incoming request:
use Illuminate\Support\Facades\Route;
$route = Route::current(); // Illuminate\Routing\Route
$name = Route::currentRouteName(); // string
$action = Route::currentRouteAction(); // string

Page 113 of 1307

Laravel 9.x

You may refer to the API documentation for both the underlying class of the Route facade and Route instance to review all
of the methods that are available on the router and route classes.

Cross-Origin Resource Sharing (CORS)

Laravel can automatically respond to CORS OPTIONS HTTP requests with values that you configure. All CORS settings
may be configured in your application's config/cors.php configuration file. The OPTIONS requests will automatically
be handled by the HandleCors middleware that is included by default in your global middleware stack. Your global
middleware stack is located in your application's HTTP kernel ( App\Http\Kernel ).
For more information on CORS and CORS headers, please consult the MDN web documentation on
CORS.

Route Caching

When deploying your application to production, you should take advantage of Laravel's route cache. Using the route cache
will drastically decrease the amount of time it takes to register all of your application's routes. To generate a route cache,
execute the route:cache Artisan command:
php artisan route:cache

After running this command, your cached routes file will be loaded on every request. Remember, if you add any new routes
you will need to generate a fresh route cache. Because of this, you should only run the route:cache command during
your project's deployment.
You may use the route:clear command to clear the route cache:
php artisan route:clear

Page 114 of 1307

Laravel 9.x

Middleware
Introduction
Defining Middleware
Registering Middleware
Global Middleware
Assigning Middleware To Routes
Middleware Groups
Sorting Middleware
Middleware Parameters
Terminable Middleware

Introduction

Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application. For
example, Laravel includes a middleware that verifies the user of your application is authenticated. If the user is not
authenticated, the middleware will redirect the user to your application's login screen. However, if the user is
authenticated, the middleware will allow the request to proceed further into the application.
Additional middleware can be written to perform a variety of tasks besides authentication. For example, a logging
middleware might log all incoming requests to your application. There are several middleware included in the Laravel
framework, including middleware for authentication and CSRF protection. All of these middleware are located in the
app/Http/Middleware directory.

Defining Middleware

To create a new middleware, use the make:middleware Artisan command:
php artisan make:middleware EnsureTokenIsValid

This command will place a new EnsureTokenIsValid class within your app/Http/Middleware directory. In this
middleware, we will only allow access to the route if the supplied token input matches a specified value. Otherwise, we
will redirect the users back to the home URI:

Page 115 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Closure;
class EnsureTokenIsValid
{
/**
* Handle an incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

$request

$next

* @return mixed
*/
public function handle($request, Closure $next)
{
if ($request->input('token') !== 'my-secret-token') {
return redirect('home');
}
return $next($request);
}
}

As you can see, if the given token does not match our secret token, the middleware will return an HTTP redirect to the
client; otherwise, the request will be passed further into the application. To pass the request deeper into the application
(allowing the middleware to "pass"), you should call the $next callback with the $request .
It's best to envision middleware as a series of "layers" HTTP requests must pass through before they hit your application.
Each layer can examine the request and even reject it entirely.
All middleware are resolved via the service container, so you may type-hint any dependencies you
need within a middleware's constructor.
Middleware & Responses
Of course, a middleware can perform tasks before or after passing the request deeper into the application. For example,
the following middleware would perform some task before the request is handled by the application:

Page 116 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Closure;
class BeforeMiddleware
{
public function handle($request, Closure $next)
{
// Perform action
return $next($request);
}
}

However, this middleware would perform its task after the request is handled by the application:
<?php
namespace App\Http\Middleware;
use Closure;
class AfterMiddleware
{
public function handle($request, Closure $next)
{
$response = $next($request);
// Perform action
return $response;
}
}

Registering Middleware
Global Middleware

If you want a middleware to run during every HTTP request to your application, list the middleware class in the
$middleware property of your app/Http/Kernel.php class.

Assigning Middleware To Routes

If you would like to assign middleware to specific routes, you should first assign the middleware a key in your application's
app/Http/Kernel.php file. By default, the $routeMiddleware property of this class contains entries for the
middleware included with Laravel. You may add your own middleware to this list and assign it a key of your choosing:

Page 117 of 1307

Laravel 9.x

// Within App\Http\Kernel class...
protected $routeMiddleware = [
'auth' => \App\Http\Middleware\Authenticate::class,
'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
'can' => \Illuminate\Auth\Middleware\Authorize::class,
'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
];

Once the middleware has been defined in the HTTP kernel, you may use the middleware method to assign middleware to
a route:
Route::get('/profile', function () {
//
})->middleware('auth');

You may assign multiple middleware to the route by passing an array of middleware names to the middleware method:
Route::get('/', function () {
//
})->middleware(['first', 'second']);

When assigning middleware, you may also pass the fully qualified class name:
use App\Http\Middleware\EnsureTokenIsValid;
Route::get('/profile', function () {
//
})->middleware(EnsureTokenIsValid::class);

Excluding Middleware
When assigning middleware to a group of routes, you may occasionally need to prevent the middleware from being applied
to an individual route within the group. You may accomplish this using the withoutMiddleware method:
use App\Http\Middleware\EnsureTokenIsValid;
Route::middleware([EnsureTokenIsValid::class])->group(function () {
Route::get('/', function () {
//
});
Route::get('/profile', function () {
//
})->withoutMiddleware([EnsureTokenIsValid::class]);
});

You may also exclude a given set of middleware from an entire group of route definitions:
Page 118 of 1307

Laravel 9.x

use App\Http\Middleware\EnsureTokenIsValid;
Route::withoutMiddleware([EnsureTokenIsValid::class])->group(function () {
Route::get('/profile', function () {
//
});
});

The withoutMiddleware method can only remove route middleware and does not apply to global middleware.

Middleware Groups

Sometimes you may want to group several middleware under a single key to make them easier to assign to routes. You may
accomplish this using the $middlewareGroups property of your HTTP kernel.
Laravel includes predefined web and api middleware groups that contain common middleware you may want to apply
to your web and API routes. Remember, these middleware groups are automatically applied by your application's
App\Providers\RouteServiceProvider service provider to routes within your corresponding web and api route
files:
/**
* The application's route middleware groups.
*
* @var array
*/
protected $middlewareGroups = [
'web' => [
\App\Http\Middleware\EncryptCookies::class,
\Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
\Illuminate\Session\Middleware\StartSession::class,
\Illuminate\View\Middleware\ShareErrorsFromSession::class,
\App\Http\Middleware\VerifyCsrfToken::class,
\Illuminate\Routing\Middleware\SubstituteBindings::class,
],
'api' => [
'throttle:api',
\Illuminate\Routing\Middleware\SubstituteBindings::class,
],
];

Middleware groups may be assigned to routes and controller actions using the same syntax as individual middleware.
Again, middleware groups make it more convenient to assign many middleware to a route at once:
Route::get('/', function () {
//
})->middleware('web');
Route::middleware(['web'])->group(function () {
//
});

Page 119 of 1307

Laravel 9.x

Out of the box, the web and api middleware groups are automatically applied to your
application's corresponding routes/web.php and routes/api.php files by the
App\Providers\RouteServiceProvider .

Sorting Middleware

Rarely, you may need your middleware to execute in a specific order but not have control over their order when they are
assigned to the route. In this case, you may specify your middleware priority using the $middlewarePriority property
of your app/Http/Kernel.php file. This property may not exist in your HTTP kernel by default. If it does not exist, you
may copy its default definition below:
/**
* The priority-sorted list of middleware.
*
* This forces non-global middleware to always be in the given order.
*
* @var string[]
*/
protected $middlewarePriority = [
\Illuminate\Foundation\Http\Middleware\HandlePrecognitiveRequests::class,
\Illuminate\Cookie\Middleware\EncryptCookies::class,
\Illuminate\Session\Middleware\StartSession::class,
\Illuminate\View\Middleware\ShareErrorsFromSession::class,
\Illuminate\Contracts\Auth\Middleware\AuthenticatesRequests::class,
\Illuminate\Routing\Middleware\ThrottleRequests::class,
\Illuminate\Routing\Middleware\ThrottleRequestsWithRedis::class,
\Illuminate\Contracts\Session\Middleware\AuthenticatesSessions::class,
\Illuminate\Routing\Middleware\SubstituteBindings::class,
\Illuminate\Auth\Middleware\Authorize::class,
];

Middleware Parameters

Middleware can also receive additional parameters. For example, if your application needs to verify that the authenticated
user has a given "role" before performing a given action, you could create an EnsureUserHasRole middleware that
receives a role name as an additional argument.
Additional middleware parameters will be passed to the middleware after the $next argument:

Page 120 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Closure;
class EnsureUserHasRole
{
/**
* Handle the incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

* @param

string

$request

$next

$role

* @return mixed
*/
public function handle($request, Closure $next, $role)
{
if (! $request->user()->hasRole($role)) {
// Redirect...
}
return $next($request);
}
}

Middleware parameters may be specified when defining the route by separating the middleware name and parameters with
a : . Multiple parameters should be delimited by commas:
Route::put('/post/{id}', function ($id) {
//
})->middleware('role:editor');

Terminable Middleware

Sometimes a middleware may need to do some work after the HTTP response has been sent to the browser. If you define a
terminate method on your middleware and your web server is using FastCGI, the terminate method will automatically
be called after the response is sent to the browser:

Page 121 of 1307

Laravel 9.x

<?php
namespace Illuminate\Session\Middleware;
use Closure;
class TerminatingMiddleware
{
/**
* Handle an incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

$request

$next

* @return mixed
*/
public function handle($request, Closure $next)
{
return $next($request);
}
/**
* Handle tasks after the response has been sent to the browser.
*
* @param

\Illuminate\Http\Request

$request

* @param

\Illuminate\Http\Response

$response

* @return void
*/
public function terminate($request, $response)
{
// ...
}
}

The terminate method should receive both the request and the response. Once you have defined a terminable
middleware, you should add it to the list of routes or global middleware in the app/Http/Kernel.php file.
When calling the terminate method on your middleware, Laravel will resolve a fresh instance of the middleware from the
service container. If you would like to use the same middleware instance when the handle and terminate methods are
called, register the middleware with the container using the container's singleton method. Typically this should be done
in the register method of your AppServiceProvider :
use App\Http\Middleware\TerminatingMiddleware;
/**
* Register any application services.
*
* @return void
*/
public function register()
{
$this->app->singleton(TerminatingMiddleware::class);
}

Page 122 of 1307

Laravel 9.x

CSRF Protection
Introduction
Preventing CSRF Requests
Excluding URIs
X-CSRF-Token
X-XSRF-Token

Introduction

Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of
an authenticated user. Thankfully, Laravel makes it easy to protect your application from cross-site request forgery (CSRF)
attacks.
An Explanation Of The Vulnerability
In case you're not familiar with cross-site request forgeries, let's discuss an example of how this vulnerability can be
exploited. Imagine your application has a /user/email route that accepts a POST request to change the authenticated
user's email address. Most likely, this route expects an email input field to contain the email address the user would like
to begin using.
Without CSRF protection, a malicious website could create an HTML form that points to your application's /user/email
route and submits the malicious user's own email address:
<form action="https://your-application.com/user/email" method="POST">
<input type="email" value="malicious-email@example.com">
</form>
<script>
document.forms[0].submit();
</script>

If the malicious website automatically submits the form when the page is loaded, the malicious user only needs to lure an
unsuspecting user of your application to visit their website and their email address will be changed in your application.
To prevent this vulnerability, we need to inspect every incoming POST , PUT , PATCH , or DELETE request for a secret
session value that the malicious application is unable to access.

Preventing CSRF Requests

Laravel automatically generates a CSRF "token" for each active user session managed by the application. This token is
used to verify that the authenticated user is the person actually making the requests to the application. Since this token is
stored in the user's session and changes each time the session is regenerated, a malicious application is unable to access
it.
The current session's CSRF token can be accessed via the request's session or via the csrf_token helper function:

Page 123 of 1307

Laravel 9.x

use Illuminate\Http\Request;
Route::get('/token', function (Request $request) {
$token = $request->session()->token();
$token = csrf_token();
// ...
});

Anytime you define a "POST", "PUT", "PATCH", or "DELETE" HTML form in your application, you should include a hidden
CSRF _token field in the form so that the CSRF protection middleware can validate the request. For convenience, you
may use the @csrf Blade directive to generate the hidden token input field:
<form method="POST" action="/profile">
@csrf
<!-- Equivalent to... -->
<input type="hidden" name="_token" value="{{ csrf_token() }}" />
</form>

The App\Http\Middleware\VerifyCsrfToken middleware, which is included in the web middleware group by default,
will automatically verify that the token in the request input matches the token stored in the session. When these two tokens
match, we know that the authenticated user is the one initiating the request.

CSRF Tokens & SPAs

If you are building a SPA that is utilizing Laravel as an API backend, you should consult the Laravel Sanctum documentation
for information on authenticating with your API and protecting against CSRF vulnerabilities.

Excluding URIs From CSRF Protection

Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using Stripe to process
payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF
protection since Stripe will not know what CSRF token to send to your routes.
Typically, you should place these kinds of routes outside of the web middleware group that the
App\Providers\RouteServiceProvider applies to all routes in the routes/web.php file. However, you may also
exclude the routes by adding their URIs to the $except property of the VerifyCsrfToken middleware:

Page 124 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken as Middleware;
class VerifyCsrfToken extends Middleware
{
/**
* The URIs that should be excluded from CSRF verification.
*
* @var array
*/
protected $except = [
'stripe/*',
'http://example.com/foo/bar',
'http://example.com/foo/*',
];
}

For convenience, the CSRF middleware is automatically disabled for all routes when running tests.

X-CSRF-TOKEN

In addition to checking for the CSRF token as a POST parameter, the App\Http\Middleware\VerifyCsrfToken
middleware will also check for the X-CSRF-TOKEN request header. You could, for example, store the token in an HTML
meta tag:
<meta name="csrf-token" content="{{ csrf_token() }}">

Then, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple,
convenient CSRF protection for your AJAX based applications using legacy JavaScript technology:
$.ajaxSetup({
headers: {
'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
}
});

X-XSRF-TOKEN

Laravel stores the current CSRF token in an encrypted XSRF-TOKEN cookie that is included with each response generated
by the framework. You can use the cookie value to set the X-XSRF-TOKEN request header.
This cookie is primarily sent as a developer convenience since some JavaScript frameworks and libraries, like Angular and
Axios, automatically place its value in the X-XSRF-TOKEN header on same-origin requests.

Page 125 of 1307

Laravel 9.x

By default, the resources/js/bootstrap.js file includes the Axios HTTP library which will
automatically send the X-XSRF-TOKEN header for you.

Page 126 of 1307

Laravel 9.x

Controllers
Introduction
Writing Controllers
Basic Controllers
Single Action Controllers
Controller Middleware
Resource Controllers
Partial Resource Routes
Nested Resources
Naming Resource Routes
Naming Resource Route Parameters
Scoping Resource Routes
Localizing Resource URIs
Supplementing Resource Controllers
Singleton Resource Controllers
Dependency Injection & Controllers

Introduction

Instead of defining all of your request handling logic as closures in your route files, you may wish to organize this behavior
using "controller" classes. Controllers can group related request handling logic into a single class. For example, a
UserController class might handle all incoming requests related to users, including showing, creating, updating, and
deleting users. By default, controllers are stored in the app/Http/Controllers directory.

Writing Controllers
Basic Controllers

Let's take a look at an example of a basic controller. Note that the controller extends the base controller class included
with Laravel: App\Http\Controllers\Controller :

Page 127 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Models\User;
class UserController extends Controller
{
/**
* Show the profile for a given user.
*
* @param

int

$id

* @return \Illuminate\View\View
*/
public function show($id)
{
return view('user.profile', [
'user' => User::findOrFail($id)
]);
}
}

You can define a route to this controller method like so:
use App\Http\Controllers\UserController;
Route::get('/user/{id}', [UserController::class, 'show']);

When an incoming request matches the specified route URI, the show method on the
App\Http\Controllers\UserController class will be invoked and the route parameters will be passed to the method.
Controllers are not required to extend a base class. However, you will not have access to
convenient features such as the middleware and authorize methods.

Single Action Controllers

If a controller action is particularly complex, you might find it convenient to dedicate an entire controller class to that single
action. To accomplish this, you may define a single __invoke method within the controller:

Page 128 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Models\User;
class ProvisionServer extends Controller
{
/**
* Provision a new web server.
*
* @return \Illuminate\Http\Response
*/
public function __invoke()
{
// ...
}
}

When registering routes for single action controllers, you do not need to specify a controller method. Instead, you may
simply pass the name of the controller to the router:
use App\Http\Controllers\ProvisionServer;
Route::post('/server', ProvisionServer::class);

You may generate an invokable controller by using the --invokable option of the make:controller Artisan command:
php artisan make:controller ProvisionServer --invokable

Controller stubs may be customized using stub publishing.

Controller Middleware

Middleware may be assigned to the controller's routes in your route files:
Route::get('profile', [UserController::class, 'show'])->middleware('auth');

Or, you may find it convenient to specify middleware within your controller's constructor. Using the middleware method
within your controller's constructor, you can assign middleware to the controller's actions:

Page 129 of 1307

Laravel 9.x

class UserController extends Controller
{
/**
* Instantiate a new controller instance.
*
* @return void
*/
public function __construct()
{
$this->middleware('auth');
$this->middleware('log')->only('index');
$this->middleware('subscribed')->except('store');
}
}

Controllers also allow you to register middleware using a closure. This provides a convenient way to define an inline
middleware for a single controller without defining an entire middleware class:
$this->middleware(function ($request, $next) {
return $next($request);
});

Resource Controllers

If you think of each Eloquent model in your application as a "resource", it is typical to perform the same sets of actions
against each resource in your application. For example, imagine your application contains a Photo model and a Movie
model. It is likely that users can create, read, update, or delete these resources.
Because of this common use case, Laravel resource routing assigns the typical create, read, update, and delete ("CRUD")
routes to a controller with a single line of code. To get started, we can use the make:controller Artisan command's -resource option to quickly create a controller to handle these actions:
php artisan make:controller PhotoController --resource

This command will generate a controller at app/Http/Controllers/PhotoController.php . The controller will contain a
method for each of the available resource operations. Next, you may register a resource route that points to the controller:
use App\Http\Controllers\PhotoController;
Route::resource('photos', PhotoController::class);

This single route declaration creates multiple routes to handle a variety of actions on the resource. The generated
controller will already have methods stubbed for each of these actions. Remember, you can always get a quick overview of
your application's routes by running the route:list Artisan command.
You may even register many resource controllers at once by passing an array to the resources method:
Route::resources([
'photos' => PhotoController::class,
'posts' => PostController::class,
]);

Actions Handled By Resource Controller
Page 130 of 1307

Laravel 9.x

Verb
GET
GET
POST
GET
GET
PUT/PATCH
DELETE

URI
/photos
/photos/create
/photos
/photos/{photo}
/photos/{photo}/edit
/photos/{photo}
/photos/{photo}

Action
index
create
store
show
edit
update
destroy

Route Name
photos.index
photos.create
photos.store
photos.show
photos.edit
photos.update
photos.destroy

Customizing Missing Model Behavior
Typically, a 404 HTTP response will be generated if an implicitly bound resource model is not found. However, you may
customize this behavior by calling the missing method when defining your resource route. The missing method
accepts a closure that will be invoked if an implicitly bound model can not be found for any of the resource's routes:
use App\Http\Controllers\PhotoController;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Redirect;
Route::resource('photos', PhotoController::class)
->missing(function (Request $request) {
return Redirect::route('photos.index');
});

Soft Deleted Models
Typically, implicit model binding will not retrieve models that have been soft deleted, and will instead return a 404 HTTP
response. However, you can instruct the framework to allow soft deleted models by invoking the withTrashed method
when defining your resource route:
use App\Http\Controllers\PhotoController;
Route::resource('photos', PhotoController::class)->withTrashed();

Calling withTrashed with no arguments will allow soft deleted models for the show , edit , and update resource
routes. You may specify a subset of these routes by passing an array to the withTrashed method:
Route::resource('photos', PhotoController::class)->withTrashed(['show']);

Specifying The Resource Model
If you are using route model binding and would like the resource controller's methods to type-hint a model instance, you
may use the --model option when generating the controller:
php artisan make:controller PhotoController --model=Photo --resource

Generating Form Requests

Page 131 of 1307

Laravel 9.x

You may provide the --requests option when generating a resource controller to instruct Artisan to generate form
request classes for the controller's storage and update methods:
php artisan make:controller PhotoController --model=Photo --resource --requests

Partial Resource Routes

When declaring a resource route, you may specify a subset of actions the controller should handle instead of the full set of
default actions:
use App\Http\Controllers\PhotoController;
Route::resource('photos', PhotoController::class)->only([
'index', 'show'
]);
Route::resource('photos', PhotoController::class)->except([
'create', 'store', 'update', 'destroy'
]);

API Resource Routes
When declaring resource routes that will be consumed by APIs, you will commonly want to exclude routes that present
HTML templates such as create and edit . For convenience, you may use the apiResource method to automatically
exclude these two routes:
use App\Http\Controllers\PhotoController;
Route::apiResource('photos', PhotoController::class);

You may register many API resource controllers at once by passing an array to the apiResources method:
use App\Http\Controllers\PhotoController;
use App\Http\Controllers\PostController;
Route::apiResources([
'photos' => PhotoController::class,
'posts' => PostController::class,
]);

To quickly generate an API resource controller that does not include the create or edit methods, use the --api
switch when executing the make:controller command:
php artisan make:controller PhotoController --api

Nested Resources

Sometimes you may need to define routes to a nested resource. For example, a photo resource may have multiple
comments that may be attached to the photo. To nest the resource controllers, you may use "dot" notation in your route
declaration:

Page 132 of 1307

Laravel 9.x

use App\Http\Controllers\PhotoCommentController;
Route::resource('photos.comments', PhotoCommentController::class);

This route will register a nested resource that may be accessed with URIs like the following:
/photos/{photo}/comments/{comment}

Scoping Nested Resources
Laravel's implicit model binding feature can automatically scope nested bindings such that the resolved child model is
confirmed to belong to the parent model. By using the scoped method when defining your nested resource, you may
enable automatic scoping as well as instruct Laravel which field the child resource should be retrieved by. For more
information on how to accomplish this, please see the documentation on scoping resource routes.
Shallow Nesting
Often, it is not entirely necessary to have both the parent and the child IDs within a URI since the child ID is already a
unique identifier. When using unique identifiers such as auto-incrementing primary keys to identify your models in URI
segments, you may choose to use "shallow nesting":
use App\Http\Controllers\CommentController;
Route::resource('photos.comments', CommentController::class)->shallow();

This route definition will define the following routes:
Verb
GET
GET
POST
GET
GET
PUT/PATCH
DELETE

URI
/photos/{photo}/comments
/photos/{photo}/comments/create
/photos/{photo}/comments
/comments/{comment}
/comments/{comment}/edit
/comments/{comment}
/comments/{comment}

Action
index
create
store
show
edit
update
destroy

Naming Resource Routes

Route Name
photos.comments.index
photos.comments.create
photos.comments.store
comments.show
comments.edit
comments.update
comments.destroy

By default, all resource controller actions have a route name; however, you can override these names by passing a names
array with your desired route names:
use App\Http\Controllers\PhotoController;
Route::resource('photos', PhotoController::class)->names([
'create' => 'photos.build'
]);

Naming Resource Route Parameters
Page 133 of 1307

Laravel 9.x

By default, Route::resource will create the route parameters for your resource routes based on the "singularized"
version of the resource name. You can easily override this on a per resource basis using the parameters method. The
array passed into the parameters method should be an associative array of resource names and parameter names:
use App\Http\Controllers\AdminUserController;
Route::resource('users', AdminUserController::class)->parameters([
'users' => 'admin_user'
]);

The example above generates the following URI for the resource's show route:
/users/{admin_user}

Scoping Resource Routes

Laravel's scoped implicit model binding feature can automatically scope nested bindings such that the resolved child
model is confirmed to belong to the parent model. By using the scoped method when defining your nested resource, you
may enable automatic scoping as well as instruct Laravel which field the child resource should be retrieved by:
use App\Http\Controllers\PhotoCommentController;
Route::resource('photos.comments', PhotoCommentController::class)->scoped([
'comment' => 'slug',
]);

This route will register a scoped nested resource that may be accessed with URIs like the following:
/photos/{photo}/comments/{comment:slug}

When using a custom keyed implicit binding as a nested route parameter, Laravel will automatically scope the query to
retrieve the nested model by its parent using conventions to guess the relationship name on the parent. In this case, it will
be assumed that the Photo model has a relationship named comments (the plural of the route parameter name) which
can be used to retrieve the Comment model.

Localizing Resource URIs

By default, Route::resource will create resource URIs using English verbs and plural rules. If you need to localize the
create and edit action verbs, you may use the Route::resourceVerbs method. This may be done at the beginning
of the boot method within your application's App\Providers\RouteServiceProvider :

Page 134 of 1307

Laravel 9.x

/**
* Define your route model bindings, pattern filters, etc.
*
* @return void
*/
public function boot()
{
Route::resourceVerbs([
'create' => 'crear',
'edit' => 'editar',
]);
// ...
}

Laravel's pluralizer supports several different languages which you may configure based on your needs. Once the verbs
and pluralization language have been customized, a resource route registration such as
Route::resource('publicacion', PublicacionController::class) will produce the following URIs:
/publicacion/crear
/publicacion/{publicaciones}/editar

Supplementing Resource Controllers

If you need to add additional routes to a resource controller beyond the default set of resource routes, you should define
those routes before your call to the Route::resource method; otherwise, the routes defined by the resource method
may unintentionally take precedence over your supplemental routes:
use App\Http\Controller\PhotoController;
Route::get('/photos/popular', [PhotoController::class, 'popular']);
Route::resource('photos', PhotoController::class);

Remember to keep your controllers focused. If you find yourself routinely needing methods outside
of the typical set of resource actions, consider splitting your controller into two, smaller controllers.

Singleton Resource Controllers

Sometimes, your application will have resources that may only have a single instance. For example, a user's "profile" can
be edited or updated, but a user may not have more than one "profile". Likewise, an image may have a single "thumbnail".
These resources are called "singleton resources", meaning one and only one instance of the resource may exist. In these
scenarios, you may register a "singleton" resource controller:
use App\Http\Controllers\ProfileController;
use Illuminate\Support\Facades\Route;
Route::singleton('profile', ProfileController::class);

Page 135 of 1307

Laravel 9.x

The singleton resource definition above will register the following routes. As you can see, "creation" routes are not
registered for singleton resources, and the registered routes do not accept an identifier since only one instance of the
resource may exist:
Verb
GET
GET
PUT/PATCH

URI
/profile
/profile/edit
/profile

Action
show
edit
update

Route Name
profile.show
profile.edit
profile.update

Singleton resources may also be nested within a standard resource:
Route::singleton('photos.thumbnail', ThumbnailController::class);

In this example, the photos resource would receive all of the standard resource routes; however, the thumbnail
resource would be a singleton resource with the following routes:
Verb
GET
GET
PUT/PATCH

URI
/photos/{photo}/thumbnail
/photos/{photo}/thumbnail/edit
/photos/{photo}/thumbnail

Action
show
edit
update

Route Name
photos.thumbnail.show
photos.thumbnail.edit
photos.thumbnail.update

Creatable Singleton Resources
Occasionally, you may want to define creation and storage routes for a singleton resource. To accomplish this, you may
invoke the creatable method when registering the singleton resource route:
Route::singleton('photos.thumbnail', ThumbnailController::class)->creatable();

In this example, the following routes will be registered. As you can see, a DELETE route will also be registered for
creatable singleton resources:
Verb
GET
POST
GET
GET
PUT/PATCH
DELETE

URI
/photos/{photo}/thumbnail/create
/photos/{photo}/thumbnail
/photos/{photo}/thumbnail
/photos/{photo}/thumbnail/edit
/photos/{photo}/thumbnail
/photos/{photo}/thumbnail

Action
create
store
show
edit
update
destroy

Route Name
photos.thumbnail.create
photos.thumbnail.store
photos.thumbnail.show
photos.thumbnail.edit
photos.thumbnail.update
photos.thumbnail.destroy

If you would like Laravel to register the DELETE route for a singleton resource but not register the creation or storage
routes, you may utilize the destroyable method:
Route::singleton(...)->destroyable();

Page 136 of 1307

Laravel 9.x

API Singleton Resources
The apiSingleton method may be used to register a singleton resource that will be manipulated via an API, thus
rendering the create and edit routes unnecessary:
Route::apiSingleton('profile', ProfileController::class);

Of course, API singleton resources may also be creatable , which will register store and destroy routes for the
resource:
Route::apiSingleton('photos.thumbnail', ProfileController::class)->creatable();

Dependency Injection & Controllers

Constructor Injection
The Laravel service container is used to resolve all Laravel controllers. As a result, you are able to type-hint any
dependencies your controller may need in its constructor. The declared dependencies will automatically be resolved and
injected into the controller instance:
<?php
namespace App\Http\Controllers;
use App\Repositories\UserRepository;
class UserController extends Controller
{
/**
* The user repository instance.
*/
protected $users;
/**
* Create a new controller instance.
*
* @param

\App\Repositories\UserRepository

$users

* @return void
*/
public function __construct(UserRepository $users)
{
$this->users = $users;
}
}

Method Injection
In addition to constructor injection, you may also type-hint dependencies on your controller's methods. A common usecase for method injection is injecting the Illuminate\Http\Request instance into your controller methods:

Page 137 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UserController extends Controller
{
/**
* Store a new user.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$name = $request->name;
//
}
}

If your controller method is also expecting input from a route parameter, list your route arguments after your other
dependencies. For example, if your route is defined like so:
use App\Http\Controllers\UserController;
Route::put('/user/{id}', [UserController::class, 'update']);

You may still type-hint the Illuminate\Http\Request and access your id parameter by defining your controller
method as follows:
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UserController extends Controller
{
/**
* Update the given user.
*
* @param

\Illuminate\Http\Request

* @param

string

$request

$id

* @return \Illuminate\Http\Response
*/
public function update(Request $request, $id)
{
//
}
}

Page 138 of 1307

Laravel 9.x

HTTP Requests
Introduction
Interacting With The Request
Accessing The Request
Request Path, Host, & Method
Request Headers
Request IP Address
Content Negotiation
PSR-7 Requests
Input
Retrieving Input
Determining If Input Is Present
Merging Additional Input
Old Input
Cookies
Input Trimming & Normalization
Files
Retrieving Uploaded Files
Storing Uploaded Files
Configuring Trusted Proxies
Configuring Trusted Hosts

Introduction

Laravel's Illuminate\Http\Request class provides an object-oriented way to interact with the current HTTP request
being handled by your application as well as retrieve the input, cookies, and files that were submitted with the request.

Interacting With The Request
Accessing The Request

To obtain an instance of the current HTTP request via dependency injection, you should type-hint the
Illuminate\Http\Request class on your route closure or controller method. The incoming request instance will
automatically be injected by the Laravel service container:

Page 139 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UserController extends Controller
{
/**
* Store a new user.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$name = $request->input('name');
//
}
}

As mentioned, you may also type-hint the Illuminate\Http\Request class on a route closure. The service container
will automatically inject the incoming request into the closure when it is executed:
use Illuminate\Http\Request;
Route::get('/', function (Request $request) {
//
});

Dependency Injection & Route Parameters
If your controller method is also expecting input from a route parameter you should list your route parameters after your
other dependencies. For example, if your route is defined like so:
use App\Http\Controllers\UserController;
Route::put('/user/{id}', [UserController::class, 'update']);

You may still type-hint the Illuminate\Http\Request and access your id route parameter by defining your controller
method as follows:

Page 140 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UserController extends Controller
{
/**
* Update the specified user.
*
* @param

\Illuminate\Http\Request

* @param

string

$request

$id

* @return \Illuminate\Http\Response
*/
public function update(Request $request, $id)
{
//
}
}

Request Path, Host, & Method

The Illuminate\Http\Request instance provides a variety of methods for examining the incoming HTTP request and
extends the Symfony\Component\HttpFoundation\Request class. We will discuss a few of the most important
methods below.
Retrieving The Request Path
The path method returns the request's path information. So, if the incoming request is targeted at
http://example.com/foo/bar , the path method will return foo/bar :
$uri = $request->path();

Inspecting The Request Path / Route
The is method allows you to verify that the incoming request path matches a given pattern. You may use the *
character as a wildcard when utilizing this method:
if ($request->is('admin/*')) {
//
}

Using the routeIs method, you may determine if the incoming request has matched a named route:
if ($request->routeIs('admin.*')) {
//
}

Retrieving The Request URL
To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will
return the URL without the query string, while the fullUrl method includes the query string:

Page 141 of 1307

Laravel 9.x

$url = $request->url();
$urlWithQueryString = $request->fullUrl();

If you would like to append query string data to the current URL, you may call the fullUrlWithQuery method. This
method merges the given array of query string variables with the current query string:
$request->fullUrlWithQuery(['type' => 'phone']);

Retrieving The Request Host
You may retrieve the "host" of the incoming request via the host , httpHost , and schemeAndHttpHost methods:
$request->host();
$request->httpHost();
$request->schemeAndHttpHost();

Retrieving The Request Method
The method method will return the HTTP verb for the request. You may use the isMethod method to verify that the
HTTP verb matches a given string:
$method = $request->method();
if ($request->isMethod('post')) {
//
}

Request Headers

You may retrieve a request header from the Illuminate\Http\Request instance using the header method. If the
header is not present on the request, null will be returned. However, the header method accepts an optional second
argument that will be returned if the header is not present on the request:
$value = $request->header('X-Header-Name');
$value = $request->header('X-Header-Name', 'default');

The hasHeader method may be used to determine if the request contains a given header:
if ($request->hasHeader('X-Header-Name')) {
//
}

For convenience, the bearerToken method may be used to retrieve a bearer token from the Authorization header. If
no such header is present, an empty string will be returned:
$token = $request->bearerToken();

Request IP Address

The ip method may be used to retrieve the IP address of the client that made the request to your application:
Page 142 of 1307

Laravel 9.x

$ipAddress = $request->ip();

Content Negotiation

Laravel provides several methods for inspecting the incoming request's requested content types via the Accept header.
First, the getAcceptableContentTypes method will return an array containing all of the content types accepted by the
request:
$contentTypes = $request->getAcceptableContentTypes();

The accepts method accepts an array of content types and returns true if any of the content types are accepted by
the request. Otherwise, false will be returned:
if ($request->accepts(['text/html', 'application/json'])) {
// ...
}

You may use the prefers method to determine which content type out of a given array of content types is most
preferred by the request. If none of the provided content types are accepted by the request, null will be returned:
$preferred = $request->prefers(['text/html', 'application/json']);

Since many applications only serve HTML or JSON, you may use the expectsJson method to quickly determine if the
incoming request expects a JSON response:
if ($request->expectsJson()) {
// ...
}

PSR-7 Requests

The PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain
an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the
Symfony HTTP Message Bridge component to convert typical Laravel requests and responses into PSR-7 compatible
implementations:
composer require symfony/psr-http-message-bridge
composer require nyholm/psr7

Once you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your
route closure or controller method:
use Psr\Http\Message\ServerRequestInterface;
Route::get('/', function (ServerRequestInterface $request) {
//
});

Page 143 of 1307

Laravel 9.x

If you return a PSR-7 response instance from a route or controller, it will automatically be converted
back to a Laravel response instance and be displayed by the framework.

Input

Retrieving Input

Retrieving All Input Data
You may retrieve all of the incoming request's input data as an array using the all method. This method may be used
regardless of whether the incoming request is from an HTML form or is an XHR request:
$input = $request->all();

Using the collect method, you may retrieve all of the incoming request's input data as a collection:
$input = $request->collect();

The collect method also allows you to retrieve a subset of the incoming request input as a collection:
$request->collect('users')->each(function ($user) {
// ...
});

Retrieving An Input Value
Using a few simple methods, you may access all of the user input from your Illuminate\Http\Request instance
without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may
be used to retrieve user input:
$name = $request->input('name');

You may pass a default value as the second argument to the input method. This value will be returned if the requested
input value is not present on the request:
$name = $request->input('name', 'Sally');

When working with forms that contain array inputs, use "dot" notation to access the arrays:
$name = $request->input('products.0.name');
$names = $request->input('products.*.name');

You may call the input method without any arguments in order to retrieve all of the input values as an associative array:
$input = $request->input();

Retrieving Input From The Query String

Page 144 of 1307

Laravel 9.x

While the input method retrieves values from the entire request payload (including the query string), the query
method will only retrieve values from the query string:
$name = $request->query('name');

If the requested query string value data is not present, the second argument to this method will be returned:
$name = $request->query('name', 'Helen');

You may call the query method without any arguments in order to retrieve all of the query string values as an associative
array:
$query = $request->query();

Retrieving JSON Input Values
When sending JSON requests to your application, you may access the JSON data via the input method as long as the
Content-Type header of the request is properly set to application/json . You may even use "dot" syntax to retrieve
values that are nested within JSON arrays / objects:
$name = $request->input('user.name');

Retrieving Stringable Input Values
Instead of retrieving the request's input data as a primitive string , you may use the string method to retrieve the
request data as an instance of Illuminate\Support\Stringable :
$name = $request->string('name')->trim();

Retrieving Boolean Input Values
When dealing with HTML elements like checkboxes, your application may receive "truthy" values that are actually strings.
For example, "true" or "on". For convenience, you may use the boolean method to retrieve these values as booleans.
The boolean method returns true for 1, "1", true, "true", "on", and "yes". All other values will return false :
$archived = $request->boolean('archived');

Retrieving Date Input Values
For convenience, input values containing dates / times may be retrieved as Carbon instances using the date method. If
the request does not contain an input value with the given name, null will be returned:
$birthday = $request->date('birthday');

The second and third arguments accepted by the date method may be used to specify the date's format and timezone,
respectively:
$elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');

If the input value is present but has an invalid format, an InvalidArgumentException will be thrown; therefore, it is
recommended that you validate the input before invoking the date method.

Page 145 of 1307

Laravel 9.x

Retrieving Enum Input Values
Input values that correspond to PHP enums may also be retrieved from the request. If the request does not contain an
input value with the given name or the enum does not have a backing value that matches the input value, null will be
returned. The enum method accepts the name of the input value and the enum class as its first and second arguments:
use App\Enums\Status;
$status = $request->enum('status', Status::class);

Retrieving Input Via Dynamic Properties
You may also access user input using dynamic properties on the Illuminate\Http\Request instance. For example, if
one of your application's forms contains a name field, you may access the value of the field like so:
$name = $request->name;

When using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present,
Laravel will search for the field in the matched route's parameters.
Retrieving A Portion Of The Input Data
If you need to retrieve a subset of the input data, you may use the only and except methods. Both of these methods
accept a single array or a dynamic list of arguments:
$input = $request->only(['username', 'password']);
$input = $request->only('username', 'password');
$input = $request->except(['credit_card']);
$input = $request->except('credit_card');

The only method returns all of the key / value pairs that you request; however, it will not return
key / value pairs that are not present on the request.

Determining If Input Is Present

You may use the has method to determine if a value is present on the request. The has method returns true if the
value is present on the request:
if ($request->has('name')) {
//
}

When given an array, the has method will determine if all of the specified values are present:
if ($request->has(['name', 'email'])) {
//
}

Page 146 of 1307

Laravel 9.x

The whenHas method will execute the given closure if a value is present on the request:
$request->whenHas('name', function ($input) {
//
});

A second closure may be passed to the whenHas method that will be executed if the specified value is not present on the
request:
$request->whenHas('name', function ($input) {
// The "name" value is present...
}, function () {
// The "name" value is not present...
});

The hasAny method returns true if any of the specified values are present:
if ($request->hasAny(['name', 'email'])) {
//
}

If you would like to determine if a value is present on the request and is not an empty string, you may use the filled
method:
if ($request->filled('name')) {
//
}

The whenFilled method will execute the given closure if a value is present on the request and is not an empty string:
$request->whenFilled('name', function ($input) {
//
});

A second closure may be passed to the whenFilled method that will be executed if the specified value is not "filled":
$request->whenFilled('name', function ($input) {
// The "name" value is filled...
}, function () {
// The "name" value is not filled...
});

To determine if a given key is absent from the request, you may use the missing and whenMissing methods:

Page 147 of 1307

Laravel 9.x

if ($request->missing('name')) {
//
}
$request->whenMissing('name', function ($input) {
// The "name" value is missing...
}, function () {
// The "name" value is present...
});

Merging Additional Input

Sometimes you may need to manually merge additional input into the request's existing input data. To accomplish this, you
may use the merge method. If a given input key already exists on the request, it will be overwritten by the data provided
to the merge method:
$request->merge(['votes' => 0]);

The mergeIfMissing method may be used to merge input into the request if the corresponding keys do not already exist
within the request's input data:
$request->mergeIfMissing(['votes' => 0]);

Old Input

Laravel allows you to keep input from one request during the next request. This feature is particularly useful for repopulating forms after detecting validation errors. However, if you are using Laravel's included validation features, it is
possible that you will not need to manually use these session input flashing methods directly, as some of Laravel's built-in
validation facilities will call them automatically.
Flashing Input To The Session
The flash method on the Illuminate\Http\Request class will flash the current input to the session so that it is
available during the user's next request to the application:
$request->flash();

You may also use the flashOnly and flashExcept methods to flash a subset of the request data to the session. These
methods are useful for keeping sensitive information such as passwords out of the session:
$request->flashOnly(['username', 'email']);
$request->flashExcept('password');

Flashing Input Then Redirecting
Since you often will want to flash input to the session and then redirect to the previous page, you may easily chain input
flashing onto a redirect using the withInput method:

Page 148 of 1307

Laravel 9.x

return redirect('form')->withInput();
return redirect()->route('user.create')->withInput();
return redirect('form')->withInput(
$request->except('password')
);

Retrieving Old Input
To retrieve flashed input from the previous request, invoke the old method on an instance of
Illuminate\Http\Request . The old method will pull the previously flashed input data from the session:
$username = $request->old('username');

Laravel also provides a global old helper. If you are displaying old input within a Blade template, it is more convenient to
use the old helper to repopulate the form. If no old input exists for the given field, null will be returned:
<input type="text" name="username" value="{{ old('username') }}">

Cookies

Retrieving Cookies From Requests
All cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be
considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the cookie
method on an Illuminate\Http\Request instance:
$value = $request->cookie('name');

Input Trimming & Normalization

By default, Laravel includes the App\Http\Middleware\TrimStrings and

Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull middleware in your application's global
middleware stack. These middleware are listed in the global middleware stack by the App\Http\Kernel class. These
middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to
null . This allows you to not have to worry about these normalization concerns in your routes and controllers.

Disabling Input Normalization
If you would like to disable this behavior for all requests, you may remove the two middleware from your application's
middleware stack by removing them from the $middleware property of your App\Http\Kernel class.
If you would like to disable string trimming and empty string conversion for a subset of requests to your application, you
may use the skipWhen method offered by both middleware. This method accepts a closure which should return true
or false to indicate if input normalization should be skipped. Typically, the skipWhen method should be invoked in the
boot method of your application's AppServiceProvider .

Page 149 of 1307

Laravel 9.x

use App\Http\Middleware\TrimStrings;
use Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
TrimStrings::skipWhen(function ($request) {
return $request->is('admin/*');
});
ConvertEmptyStringsToNull::skipWhen(function ($request) {
// ...
});
}

Files

Retrieving Uploaded Files

You may retrieve uploaded files from an Illuminate\Http\Request instance using the file method or using dynamic
properties. The file method returns an instance of the Illuminate\Http\UploadedFile class, which extends the
PHP SplFileInfo class and provides a variety of methods for interacting with the file:
$file = $request->file('photo');
$file = $request->photo;

You may determine if a file is present on the request using the hasFile method:
if ($request->hasFile('photo')) {
//
}

Validating Successful Uploads
In addition to checking if the file is present, you may verify that there were no problems uploading the file via the
isValid method:
if ($request->file('photo')->isValid()) {
//
}

File Paths & Extensions
The UploadedFile class also contains methods for accessing the file's fully-qualified path and its extension. The
extension method will attempt to guess the file's extension based on its contents. This extension may be different from
the extension that was supplied by the client:

Page 150 of 1307

Laravel 9.x

$path = $request->photo->path();
$extension = $request->photo->extension();

Other File Methods
There are a variety of other methods available on UploadedFile instances. Check out the API documentation for the
class for more information regarding these methods.

Storing Uploaded Files

To store an uploaded file, you will typically use one of your configured filesystems. The UploadedFile class has a
store method that will move an uploaded file to one of your disks, which may be a location on your local filesystem or a
cloud storage location like Amazon S3.
The store method accepts the path where the file should be stored relative to the filesystem's configured root directory.
This path should not contain a filename, since a unique ID will automatically be generated to serve as the filename.
The store method also accepts an optional second argument for the name of the disk that should be used to store the
file. The method will return the path of the file relative to the disk's root:
$path = $request->photo->store('images');
$path = $request->photo->store('images', 's3');

If you do not want a filename to be automatically generated, you may use the storeAs method, which accepts the path,
filename, and disk name as its arguments:
$path = $request->photo->storeAs('images', 'filename.jpg');
$path = $request->photo->storeAs('images', 'filename.jpg', 's3');

For more information about file storage in Laravel, check out the complete file storage
documentation.

Configuring Trusted Proxies

When running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your
application sometimes does not generate HTTPS links when using the url helper. Typically this is because your
application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure
links.
To solve this, you may use the App\Http\Middleware\TrustProxies middleware that is included in your Laravel
application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application.
Your trusted proxies should be listed as an array on the $proxies property of this middleware. In addition to configuring
the trusted proxies, you may configure the proxy $headers that should be trusted:

Page 151 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Illuminate\Http\Middleware\TrustProxies as Middleware;
use Illuminate\Http\Request;
class TrustProxies extends Middleware
{
/**
* The trusted proxies for this application.
*
* @var string|array
*/
protected $proxies = [
'192.168.1.1',
'192.168.1.2',
];
/**
* The headers that should be used to detect proxies.
*
* @var int
*/
protected $headers = Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_HOST |
Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO;
}

If you are using AWS Elastic Load Balancing, your $headers value should be
Request::HEADER_X_FORWARDED_AWS_ELB . For more information on the constants that may be
used in the $headers property, check out Symfony's documentation on trusting proxies.
Trusting All Proxies
If you are using Amazon AWS or another "cloud" load balancer provider, you may not know the IP addresses of your actual
balancers. In this case, you may use * to trust all proxies:
/**
* The trusted proxies for this application.
*
* @var string|array
*/
protected $proxies = '*';

Configuring Trusted Hosts

By default, Laravel will respond to all requests it receives regardless of the content of the HTTP request's Host header. In
addition, the Host header's value will be used when generating absolute URLs to your application during a web request.
Typically, you should configure your web server, such as Nginx or Apache, to only send requests to your application that
match a given host name. However, if you do not have the ability to customize your web server directly and need to instruct
Page 152 of 1307

Laravel 9.x

Laravel to only respond to certain host names, you may do so by enabling the App\Http\Middleware\TrustHosts
middleware for your application.
The TrustHosts middleware is already included in the $middleware stack of your application; however, you should
uncomment it so that it becomes active. Within this middleware's hosts method, you may specify the host names that
your application should respond to. Incoming requests with other Host value headers will be rejected:
/**
* Get the host patterns that should be trusted.
*
* @return array
*/
public function hosts()
{
return [
'laravel.test',
$this->allSubdomainsOfApplicationUrl(),
];
}

The allSubdomainsOfApplicationUrl helper method will return a regular expression matching all subdomains of your
application's app.url configuration value. This helper method provides a convenient way to allow all of your
application's subdomains when building an application that utilizes wildcard subdomains.

Page 153 of 1307

Laravel 9.x

HTTP Responses
Creating Responses
Attaching Headers To Responses
Attaching Cookies To Responses
Cookies & Encryption
Redirects
Redirecting To Named Routes
Redirecting To Controller Actions
Redirecting To External Domains
Redirecting With Flashed Session Data
Other Response Types
View Responses
JSON Responses
File Downloads
File Responses
Response Macros

Creating Responses

Strings & Arrays
All routes and controllers should return a response to be sent back to the user's browser. Laravel provides several different
ways to return responses. The most basic response is returning a string from a route or controller. The framework will
automatically convert the string into a full HTTP response:
Route::get('/', function () {
return 'Hello World';
});

In addition to returning strings from your routes and controllers, you may also return arrays. The framework will
automatically convert the array into a JSON response:
Route::get('/', function () {
return [1, 2, 3];
});

Did you know you can also return Eloquent collections from your routes or controllers? They will
automatically be converted to JSON. Give it a shot!
Response Objects
Typically, you won't just be returning simple strings or arrays from your route actions. Instead, you will be returning full
Illuminate\Http\Response instances or views.
Returning a full Response instance allows you to customize the response's HTTP status code and headers. A Response
instance inherits from the Symfony\Component\HttpFoundation\Response class, which provides a variety of methods
for building HTTP responses:

Page 154 of 1307

Laravel 9.x

Route::get('/home', function () {
return response('Hello World', 200)
->header('Content-Type', 'text/plain');
});

Eloquent Models & Collections
You may also return Eloquent ORM models and collections directly from your routes and controllers. When you do, Laravel
will automatically convert the models and collections to JSON responses while respecting the model's hidden attributes:
use App\Models\User;
Route::get('/user/{user}', function (User $user) {
return $user;
});

Attaching Headers To Responses

Keep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For
example, you may use the header method to add a series of headers to the response before sending it back to the user:
return response($content)
->header('Content-Type', $type)
->header('X-Header-One', 'Header Value')
->header('X-Header-Two', 'Header Value');

Or, you may use the withHeaders method to specify an array of headers to be added to the response:
return response($content)
->withHeaders([
'Content-Type' => $type,
'X-Header-One' => 'Header Value',
'X-Header-Two' => 'Header Value',
]);

Cache Control Middleware
Laravel includes a cache.headers middleware, which may be used to quickly set the Cache-Control header for a
group of routes. Directives should be provided using the "snake case" equivalent of the corresponding cache-control
directive and should be separated by a semicolon. If etag is specified in the list of directives, an MD5 hash of the
response content will automatically be set as the ETag identifier:
Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
Route::get('/privacy', function () {
// ...
});
Route::get('/terms', function () {
// ...
});
});

Attaching Cookies To Responses
Page 155 of 1307

Laravel 9.x

You may attach a cookie to an outgoing Illuminate\Http\Response instance using the cookie method. You should
pass the name, value, and the number of minutes the cookie should be considered valid to this method:
return response('Hello World')->cookie(
'name', 'value', $minutes
);

The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have
the same purpose and meaning as the arguments that would be given to PHP's native setcookie method:
return response('Hello World')->cookie(
'name', 'value', $minutes, $path, $domain, $secure, $httpOnly
);

If you would like to ensure that a cookie is sent with the outgoing response but you do not yet have an instance of that
response, you can use the Cookie facade to "queue" cookies for attachment to the response when it is sent. The
queue method accepts the arguments needed to create a cookie instance. These cookies will be attached to the
outgoing response before it is sent to the browser:
use Illuminate\Support\Facades\Cookie;
Cookie::queue('name', 'value', $minutes);

Generating Cookie Instances
If you would like to generate a Symfony\Component\HttpFoundation\Cookie instance that can be attached to a
response instance at a later time, you may use the global cookie helper. This cookie will not be sent back to the client
unless it is attached to a response instance:
$cookie = cookie('name', 'value', $minutes);
return response('Hello World')->cookie($cookie);

Expiring Cookies Early
You may remove a cookie by expiring it via the withoutCookie method of an outgoing response:
return response('Hello World')->withoutCookie('name');

If you do not yet have an instance of the outgoing response, you may use the Cookie facade's expire method to
expire a cookie:
Cookie::expire('name');

Cookies & Encryption

By default, all cookies generated by Laravel are encrypted and signed so that they can't be modified or read by the client.
If you would like to disable encryption for a subset of cookies generated by your application, you may use the $except
property of the App\Http\Middleware\EncryptCookies middleware, which is located in the app/Http/Middleware
directory:

Page 156 of 1307

Laravel 9.x

/**
* The names of the cookies that should not be encrypted.
*
* @var array
*/
protected $except = [
'cookie_name',
];

Redirects

Redirect responses are instances of the Illuminate\Http\RedirectResponse class, and contain the proper headers
needed to redirect the user to another URL. There are several ways to generate a RedirectResponse instance. The
simplest method is to use the global redirect helper:
Route::get('/dashboard', function () {
return redirect('home/dashboard');
});

Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may
do so by using the global back helper function. Since this feature utilizes the session, make sure the route calling the
back function is using the web middleware group:
Route::post('/user/profile', function () {
// Validate the request...
return back()->withInput();
});

Redirecting To Named Routes

When you call the redirect helper with no parameters, an instance of Illuminate\Routing\Redirector is returned,
allowing you to call any method on the Redirector instance. For example, to generate a RedirectResponse to a
named route, you may use the route method:
return redirect()->route('login');

If your route has parameters, you may pass them as the second argument to the route method:
// For a route with the following URI: /profile/{id}
return redirect()->route('profile', ['id' => 1]);

Populating Parameters Via Eloquent Models
If you are redirecting to a route with an "ID" parameter that is being populated from an Eloquent model, you may pass the
model itself. The ID will be extracted automatically:
// For a route with the following URI: /profile/{id}
return redirect()->route('profile', [$user]);

Page 157 of 1307

Laravel 9.x

If you would like to customize the value that is placed in the route parameter, you can specify the column in the route
parameter definition ( /profile/{id:slug} ) or you can override the getRouteKey method on your Eloquent model:
/**
* Get the value of the model's route key.
*
* @return mixed
*/
public function getRouteKey()
{
return $this->slug;
}

Redirecting To Controller Actions

You may also generate redirects to controller actions. To do so, pass the controller and action name to the action
method:
use App\Http\Controllers\UserController;
return redirect()->action([UserController::class, 'index']);

If your controller route requires parameters, you may pass them as the second argument to the action method:
return redirect()->action(
[UserController::class, 'profile'], ['id' => 1]
);

Redirecting To External Domains

Sometimes you may need to redirect to a domain outside of your application. You may do so by calling the away method,
which creates a RedirectResponse without any additional URL encoding, validation, or verification:
return redirect()->away('https://www.google.com');

Redirecting With Flashed Session Data

Redirecting to a new URL and flashing data to the session are usually done at the same time. Typically, this is done after
successfully performing an action when you flash a success message to the session. For convenience, you may create a
RedirectResponse instance and flash data to the session in a single, fluent method chain:
Route::post('/user/profile', function () {
// ...
return redirect('dashboard')->with('status', 'Profile updated!');
});

After the user is redirected, you may display the flashed message from the session. For example, using Blade syntax:

Page 158 of 1307

Laravel 9.x

@if (session('status'))
<div class="alert alert-success">
{{ session('status') }}
</div>
@endif

Redirecting With Input
You may use the withInput method provided by the RedirectResponse instance to flash the current request's input
data to the session before redirecting the user to a new location. This is typically done if the user has encountered a
validation error. Once the input has been flashed to the session, you may easily retrieve it during the next request to
repopulate the form:
return back()->withInput();

Other Response Types

The response helper may be used to generate other types of response instances. When the response helper is called
without arguments, an implementation of the Illuminate\Contracts\Routing\ResponseFactory contract is returned.
This contract provides several helpful methods for generating responses.

View Responses

If you need control over the response's status and headers but also need to return a view as the response's content, you
should use the view method:
return response()
->view('hello', $data, 200)
->header('Content-Type', $type);

Of course, if you do not need to pass a custom HTTP status code or custom headers, you may use the global view helper
function.

JSON Responses

The json method will automatically set the Content-Type header to application/json , as well as convert the
given array to JSON using the json_encode PHP function:
return response()->json([
'name' => 'Abigail',
'state' => 'CA',
]);

If you would like to create a JSONP response, you may use the json method in combination with the withCallback
method:
return response()
->json(['name' => 'Abigail', 'state' => 'CA'])
->withCallback($request->input('callback'));

File Downloads

Page 159 of 1307

Laravel 9.x

The download method may be used to generate a response that forces the user's browser to download the file at the
given path. The download method accepts a filename as the second argument to the method, which will determine the
filename that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third
argument to the method:
return response()->download($pathToFile);
return response()->download($pathToFile, $name, $headers);

Symfony HttpFoundation, which manages file downloads, requires the file being downloaded to
have an ASCII filename.
Streamed Downloads
Sometimes you may wish to turn the string response of a given operation into a downloadable response without having to
write the contents of the operation to disk. You may use the streamDownload method in this scenario. This method
accepts a callback, filename, and an optional array of headers as its arguments:
use App\Services\GitHub;
return response()->streamDownload(function () {
echo GitHub::api('repo')
->contents()
->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');

File Responses

The file method may be used to display a file, such as an image or PDF, directly in the user's browser instead of
initiating a download. This method accepts the path to the file as its first argument and an array of headers as its second
argument:
return response()->file($pathToFile);
return response()->file($pathToFile, $headers);

Response Macros

If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use
the macro method on the Response facade. Typically, you should call this method from the boot method of one of
your application's service providers, such as the App\Providers\AppServiceProvider service provider:

Page 160 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Response::macro('caps', function ($value) {
return Response::make(strtoupper($value));
});
}
}

The macro function accepts a name as its first argument and a closure as its second argument. The macro's closure will
be executed when calling the macro name from a ResponseFactory implementation or the response helper:
return response()->caps('foo');

Page 161 of 1307

Laravel 9.x

Views
Introduction
Writing Views In React / Vue
Creating & Rendering Views
Nested View Directories
Creating The First Available View
Determining If A View Exists
Passing Data To Views
Sharing Data With All Views
View Composers
View Creators
Optimizing Views

Introduction

Of course, it's not practical to return entire HTML documents strings directly from your routes and controllers. Thankfully,
views provide a convenient way to place all of our HTML in separate files.
Views separate your controller / application logic from your presentation logic and are stored in the resources/views
directory. When using Laravel, view templates are usually written using the Blade templating language. A simple view might
look something like this:
<!-- View stored in resources/views/greeting.blade.php -->
<html>
<body>
<h1>Hello, {{ $name }}</h1>
</body>
</html>

Since this view is stored at resources/views/greeting.blade.php , we may return it using the global view helper
like so:
Route::get('/', function () {
return view('greeting', ['name' => 'James']);
});

Looking for more information on how to write Blade templates? Check out the full Blade
documentation to get started.

Writing Views In React / Vue

Instead of writing their frontend templates in PHP via Blade, many developers have begun to prefer to write their templates
using React or Vue. Laravel makes this painless thanks to Inertia, a library that makes it a cinch to tie your React / Vue
frontend to your Laravel backend without the typical complexities of building an SPA.
Our Breeze and Jetstream starter kits give you a great starting point for your next Laravel application powered by Inertia. In
addition, the Laravel Bootcamp provides a full demonstration of building a Laravel application powered by Inertia, including
Page 162 of 1307

Laravel 9.x

examples in Vue and React.

Creating & Rendering Views

You may create a view by placing a file with the .blade.php extension in your application's resources/views
directory. The .blade.php extension informs the framework that the file contains a Blade template. Blade templates
contain HTML as well as Blade directives that allow you to easily echo values, create "if" statements, iterate over data, and
more.
Once you have created a view, you may return it from one of your application's routes or controllers using the global
view helper:
Route::get('/', function () {
return view('greeting', ['name' => 'James']);
});

Views may also be returned using the View facade:
use Illuminate\Support\Facades\View;
return View::make('greeting', ['name' => 'James']);

As you can see, the first argument passed to the view helper corresponds to the name of the view file in the
resources/views directory. The second argument is an array of data that should be made available to the view. In this
case, we are passing the name variable, which is displayed in the view using Blade syntax.

Nested View Directories

Views may also be nested within subdirectories of the resources/views directory. "Dot" notation may be used to
reference nested views. For example, if your view is stored at resources/views/admin/profile.blade.php , you may
return it from one of your application's routes / controllers like so:
return view('admin.profile', $data);

View directory names should not contain the . character.

Creating The First Available View

Using the View facade's first method, you may create the first view that exists in a given array of views. This may be
useful if your application or package allows views to be customized or overwritten:
use Illuminate\Support\Facades\View;
return View::first(['custom.admin', 'admin'], $data);

Determining If A View Exists

If you need to determine if a view exists, you may use the View facade. The exists method will return true if the
view exists:

Page 163 of 1307

Laravel 9.x

use Illuminate\Support\Facades\View;
if (View::exists('emails.customer')) {
//
}

Passing Data To Views

As you saw in the previous examples, you may pass an array of data to views to make that data available to the view:
return view('greetings', ['name' => 'Victoria']);

When passing information in this manner, the data should be an array with key / value pairs. After providing data to a view,
you can then access each value within your view using the data's keys, such as <?php echo $name; ?> .
As an alternative to passing a complete array of data to the view helper function, you may use the with method to add
individual pieces of data to the view. The with method returns an instance of the view object so that you can continue
chaining methods before returning the view:
return view('greeting')
->with('name', 'Victoria')
->with('occupation', 'Astronaut');

Sharing Data With All Views

Occasionally, you may need to share data with all views that are rendered by your application. You may do so using the
View facade's share method. Typically, you should place calls to the share method within a service provider's
boot method. You are free to add them to the App\Providers\AppServiceProvider class or generate a separate
service provider to house them:

Page 164 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\View;
class AppServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
View::share('key', 'value');
}
}

View Composers

View composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to
be bound to a view each time that view is rendered, a view composer can help you organize that logic into a single
location. View composers may prove particularly useful if the same view is returned by multiple routes or controllers within
your application and always needs a particular piece of data.
Typically, view composers will be registered within one of your application's service providers. In this example, we'll
assume that we have created a new App\Providers\ViewServiceProvider to house this logic.
We'll use the View facade's composer method to register the view composer. Laravel does not include a default
directory for class based view composers, so you are free to organize them however you wish. For example, you could
create an app/View/Composers directory to house all of your application's view composers:

Page 165 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use App\View\Composers\ProfileComposer;
use Illuminate\Support\Facades\View;
use Illuminate\Support\ServiceProvider;
class ViewServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
// Using class based composers...
View::composer('profile', ProfileComposer::class);
// Using closure based composers...
View::composer('dashboard', function ($view) {
//
});
}
}

Remember, if you create a new service provider to contain your view composer registrations, you
will need to add the service provider to the providers array in the config/app.php
configuration file.
Now that we have registered the composer, the compose method of the App\View\Composers\ProfileComposer class
will be executed each time the profile view is being rendered. Let's take a look at an example of the composer class:

Page 166 of 1307

Laravel 9.x

<?php
namespace App\View\Composers;
use App\Repositories\UserRepository;
use Illuminate\View\View;
class ProfileComposer
{
/**
* The user repository implementation.
*
* @var \App\Repositories\UserRepository
*/
protected $users;
/**
* Create a new profile composer.
*
* @param

\App\Repositories\UserRepository

$users

* @return void
*/
public function __construct(UserRepository $users)
{
$this->users = $users;
}
/**
* Bind data to the view.
*
* @param

\Illuminate\View\View

$view

* @return void
*/
public function compose(View $view)
{
$view->with('count', $this->users->count());
}
}

As you can see, all view composers are resolved via the service container, so you may type-hint any dependencies you
need within a composer's constructor.
Attaching A Composer To Multiple Views
You may attach a view composer to multiple views at once by passing an array of views as the first argument to the
composer method:
use App\Views\Composers\MultiComposer;
View::composer(
['profile', 'dashboard'],
MultiComposer::class
);

The composer method also accepts the * character as a wildcard, allowing you to attach a composer to all views:
Page 167 of 1307

Laravel 9.x

View::composer('*', function ($view) {
//
});

View Creators

View "creators" are very similar to view composers; however, they are executed immediately after the view is instantiated
instead of waiting until the view is about to render. To register a view creator, use the creator method:
use App\View\Creators\ProfileCreator;
use Illuminate\Support\Facades\View;
View::creator('profile', ProfileCreator::class);

Optimizing Views

By default, Blade template views are compiled on demand. When a request is executed that renders a view, Laravel will
determine if a compiled version of the view exists. If the file exists, Laravel will then determine if the uncompiled view has
been modified more recently than the compiled view. If the compiled view either does not exist, or the uncompiled view
has been modified, Laravel will recompile the view.
Compiling views during the request may have a small negative impact on performance, so Laravel provides the
view:cache Artisan command to precompile all of the views utilized by your application. For increased performance, you
may wish to run this command as part of your deployment process:
php artisan view:cache

You may use the view:clear command to clear the view cache:
php artisan view:clear

Page 168 of 1307

Laravel 9.x

Blade Templates
Introduction
Supercharging Blade With Livewire
Displaying Data
HTML Entity Encoding
Blade & JavaScript Frameworks
Blade Directives
If Statements
Switch Statements
Loops
The Loop Variable
Conditional Classes
Additional Attributes
Including Subviews
The @once Directive
Raw PHP
Comments
Components
Rendering Components
Passing Data To Components
Component Attributes
Reserved Keywords
Slots
Inline Component Views
Dynamic Components
Manually Registering Components
Anonymous Components
Anonymous Index Components
Data Properties / Attributes
Accessing Parent Data
Anonymous Components Paths
Building Layouts
Layouts Using Components
Layouts Using Template Inheritance
Forms
CSRF Field
Method Field
Validation Errors
Stacks
Service Injection
Rendering Inline Blade Templates
Rendering Blade Fragments
Extending Blade
Custom Echo Handlers
Custom If Statements

Introduction

Blade is the simple, yet powerful templating engine that is included with Laravel. Unlike some PHP templating engines,
Blade does not restrict you from using plain PHP code in your templates. In fact, all Blade templates are compiled into plain
Page 169 of 1307

Laravel 9.x

PHP code and cached until they are modified, meaning Blade adds essentially zero overhead to your application. Blade
template files use the .blade.php file extension and are typically stored in the resources/views directory.
Blade views may be returned from routes or controllers using the global view helper. Of course, as mentioned in the
documentation on views, data may be passed to the Blade view using the view helper's second argument:
Route::get('/', function () {
return view('greeting', ['name' => 'Finn']);
});

Supercharging Blade With Livewire

Want to take your Blade templates to the next level and build dynamic interfaces with ease? Check out Laravel Livewire.
Livewire allows you to write Blade components that are augmented with dynamic functionality that would typically only be
possible via frontend frameworks like React or Vue, providing a great approach to building modern, reactive frontends
without the complexities, client-side rendering, or build steps of many JavaScript frameworks.

Displaying Data

You may display data that is passed to your Blade views by wrapping the variable in curly braces. For example, given the
following route:
Route::get('/', function () {
return view('welcome', ['name' => 'Samantha']);
});

You may display the contents of the name variable like so:
Hello, {{ $name }}.

Blade's {{ }} echo statements are automatically sent through PHP's htmlspecialchars
function to prevent XSS attacks.
You are not limited to displaying the contents of the variables passed to the view. You may also echo the results of any PHP
function. In fact, you can put any PHP code you wish inside of a Blade echo statement:
The current UNIX timestamp is {{ time() }}.

HTML Entity Encoding

By default, Blade (and the Laravel e helper) will double encode HTML entities. If you would like to disable double
encoding, call the Blade::withoutDoubleEncoding method from the boot method of your AppServiceProvider :

Page 170 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\Blade;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Blade::withoutDoubleEncoding();
}
}

Displaying Unescaped Data
By default, Blade {{ }} statements are automatically sent through PHP's htmlspecialchars function to prevent XSS
attacks. If you do not want your data to be escaped, you may use the following syntax:
Hello, {!! $name !!}.

Be very careful when echoing content that is supplied by users of your application. You should
typically use the escaped, double curly brace syntax to prevent XSS attacks when displaying user
supplied data.

Blade & JavaScript Frameworks

Since many JavaScript frameworks also use "curly" braces to indicate a given expression should be displayed in the
browser, you may use the @ symbol to inform the Blade rendering engine an expression should remain untouched. For
example:
<h1>Laravel</h1>
Hello, @{{ name }}.

In this example, the @ symbol will be removed by Blade; however, {{ name }} expression will remain untouched by the
Blade engine, allowing it to be rendered by your JavaScript framework.
The @ symbol may also be used to escape Blade directives:

Page 171 of 1307

Laravel 9.x

{{-- Blade template --}}
@@if()
<!-- HTML output -->
@if()

Rendering JSON
Sometimes you may pass an array to your view with the intention of rendering it as JSON in order to initialize a JavaScript
variable. For example:
<script>
var app = <?php echo json_encode($array); ?>;
</script>

However, instead of manually calling json_encode , you may use the Illuminate\Support\Js::from method
directive. The from method accepts the same arguments as PHP's json_encode function; however, it will ensure that
the resulting JSON is properly escaped for inclusion within HTML quotes. The from method will return a string
JSON.parse JavaScript statement that will convert the given object or array into a valid JavaScript object:
<script>
var app = {{ Illuminate\Support\Js::from($array) }};
</script>

The latest versions of the Laravel application skeleton include a Js facade, which provides convenient access to this
functionality within your Blade templates:
<script>
var app = {{ Js::from($array) }};
</script>

You should only use the Js::from method to render existing variables as JSON. The Blade
templating is based on regular expressions and attempts to pass a complex expression to the
directive may cause unexpected failures.
The @verbatim Directive
If you are displaying JavaScript variables in a large portion of your template, you may wrap the HTML in the @verbatim
directive so that you do not have to prefix each Blade echo statement with an @ symbol:
@verbatim
<div class="container">
Hello, {{ name }}.
</div>
@endverbatim

Blade Directives

In addition to template inheritance and displaying data, Blade also provides convenient shortcuts for common PHP control
structures, such as conditional statements and loops. These shortcuts provide a very clean, terse way of working with PHP
Page 172 of 1307

Laravel 9.x

control structures while also remaining familiar to their PHP counterparts.

If Statements

You may construct if statements using the @if , @elseif , @else , and @endif directives. These directives
function identically to their PHP counterparts:
@if (count($records) === 1)
I have one record!
@elseif (count($records) > 1)
I have multiple records!
@else
I don't have any records!
@endif

For convenience, Blade also provides an @unless directive:
@unless (Auth::check())
You are not signed in.
@endunless

In addition to the conditional directives already discussed, the @isset and @empty directives may be used as
convenient shortcuts for their respective PHP functions:
@isset($records)
// $records is defined and is not null...
@endisset
@empty($records)
// $records is "empty"...
@endempty

Authentication Directives
The @auth and @guest directives may be used to quickly determine if the current user is authenticated or is a guest:
@auth
// The user is authenticated...
@endauth
@guest
// The user is not authenticated...
@endguest

If needed, you may specify the authentication guard that should be checked when using the @auth and @guest
directives:
@auth('admin')
// The user is authenticated...
@endauth
@guest('admin')
// The user is not authenticated...
@endguest

Page 173 of 1307

Laravel 9.x

Environment Directives
You may check if the application is running in the production environment using the @production directive:
@production
// Production specific content...
@endproduction

Or, you may determine if the application is running in a specific environment using the @env directive:
@env('staging')
// The application is running in "staging"...
@endenv
@env(['staging', 'production'])
// The application is running in "staging" or "production"...
@endenv

Section Directives
You may determine if a template inheritance section has content using the @hasSection directive:
@hasSection('navigation')
<div class="pull-right">
@yield('navigation')
</div>
<div class="clearfix"></div>
@endif

You may use the @sectionMissing directive to determine if a section does not have content:
@sectionMissing('navigation')
<div class="pull-right">
@include('default-navigation')
</div>
@endif

Switch Statements

Switch statements can be constructed using the @switch , @case , @break , @default and @endswitch directives:
@switch($i)
@case(1)
First case...
@break
@case(2)
Second case...
@break
@default
Default case...
@endswitch

Page 174 of 1307

Laravel 9.x

Loops

In addition to conditional statements, Blade provides simple directives for working with PHP's loop structures. Again, each
of these directives functions identically to their PHP counterparts:
@for ($i = 0; $i < 10; $i++)
The current value is {{ $i }}
@endfor
@foreach ($users as $user)
<p>This is user {{ $user->id }}</p>
@endforeach
@forelse ($users as $user)
<li>{{ $user->name }}</li>
@empty
<p>No users</p>
@endforelse
@while (true)
<p>I'm looping forever.</p>
@endwhile

While iterating through a foreach loop, you may use the loop variable to gain valuable
information about the loop, such as whether you are in the first or last iteration through the loop.
When using loops you may also skip the current iteration or end the loop using the @continue and @break directives:
@foreach ($users as $user)
@if ($user->type == 1)
@continue
@endif
<li>{{ $user->name }}</li>
@if ($user->number == 5)
@break
@endif
@endforeach

You may also include the continuation or break condition within the directive declaration:
@foreach ($users as $user)
@continue($user->type == 1)
<li>{{ $user->name }}</li>
@break($user->number == 5)
@endforeach

Page 175 of 1307

Laravel 9.x

The Loop Variable

While iterating through a foreach loop, a $loop variable will be available inside of your loop. This variable provides
access to some useful bits of information such as the current loop index and whether this is the first or last iteration
through the loop:
@foreach ($users as $user)
@if ($loop->first)
This is the first iteration.
@endif
@if ($loop->last)
This is the last iteration.
@endif
<p>This is user {{ $user->id }}</p>
@endforeach

If you are in a nested loop, you may access the parent loop's $loop variable via the parent property:
@foreach ($users as $user)
@foreach ($user->posts as $post)
@if ($loop->parent->first)
This is the first iteration of the parent loop.
@endif
@endforeach
@endforeach

The $loop variable also contains a variety of other useful properties:
Property
$loop->index
$loop->iteration
$loop->remaining
$loop->count
$loop->first
$loop->last
$loop->even
$loop->odd
$loop->depth
$loop->parent

Description
The index of the current loop iteration (starts at 0).
The current loop iteration (starts at 1).
The iterations remaining in the loop.
The total number of items in the array being iterated.
Whether this is the first iteration through the loop.
Whether this is the last iteration through the loop.
Whether this is an even iteration through the loop.
Whether this is an odd iteration through the loop.
The nesting level of the current loop.
When in a nested loop, the parent's loop variable.

Conditional Classes & Styles

The @class directive conditionally compiles a CSS class string. The directive accepts an array of classes where the array
key contains the class or classes you wish to add, while the value is a boolean expression. If the array element has a
numeric key, it will always be included in the rendered class list:
Page 176 of 1307

Laravel 9.x

@php
$isActive = false;
$hasError = true;
@endphp
<span @class([
'p-4',
'font-bold' => $isActive,
'text-gray-500' => ! $isActive,
'bg-red' => $hasError,
])></span>
<span class="p-4 text-gray-500 bg-red"></span>

Likewise, the @style directive may be used to conditionally add inline CSS styles to an HTML element:
@php
$isActive = true;
@endphp
<span @style([
'background-color: red',
'font-weight: bold' => $isActive,
])></span>
<span style="background-color: red; font-weight: bold;"></span>

Additional Attributes

For convenience, you may use the @checked directive to easily indicate if a given HTML checkbox input is "checked".
This directive will echo checked if the provided condition evaluates to true :
<input type="checkbox"
name="active"
value="active"
@checked(old('active', $user->active)) />

Likewise, the @selected directive may be used to indicate if a given select option should be "selected":
<select name="version">
@foreach ($product->versions as $version)
<option value="{{ $version }}" @selected(old('version') == $version)>
{{ $version }}
</option>
@endforeach
</select>

Additionally, the @disabled directive may be used to indicate if a given element should be "disabled":
<button type="submit" @disabled($errors->isNotEmpty())>Submit</button>

Moreover, the @readonly directive may be used to indicate if a given element should be "readonly":

Page 177 of 1307

Laravel 9.x

<input type="email"
name="email"
value="email@laravel.com"
@readonly($user->isNotAdmin()) />

In addition, the @required directive may be used to indicate if a given element should be "required":
<input type="text"
name="title"
value="title"
@required($user->isAdmin()) />

Including Subviews
While you're free to use the @include directive, Blade components provide similar functionality
and offer several benefits over the @include directive such as data and attribute binding.
Blade's @include directive allows you to include a Blade view from within another view. All variables that are available to
the parent view will be made available to the included view:
<div>
@include('shared.errors')
<form>
<!-- Form Contents -->
</form>
</div>

Even though the included view will inherit all data available in the parent view, you may also pass an array of additional data
that should be made available to the included view:
@include('view.name', ['status' => 'complete'])

If you attempt to @include a view which does not exist, Laravel will throw an error. If you would like to include a view that
may or may not be present, you should use the @includeIf directive:
@includeIf('view.name', ['status' => 'complete'])

If you would like to @include a view if a given boolean expression evaluates to true or false , you may use the
@includeWhen and @includeUnless directives:
@includeWhen($boolean, 'view.name', ['status' => 'complete'])
@includeUnless($boolean, 'view.name', ['status' => 'complete'])

To include the first view that exists from a given array of views, you may use the @includeFirst directive:
@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])

Page 178 of 1307

Laravel 9.x

You should avoid using the __DIR__ and __FILE__ constants in your Blade views, since they
will refer to the location of the cached, compiled view.
Rendering Views For Collections
You may combine loops and includes into one line with Blade's @each directive:
@each('view.name', $jobs, 'job')

The @each directive's first argument is the view to render for each element in the array or collection. The second
argument is the array or collection you wish to iterate over, while the third argument is the variable name that will be
assigned to the current iteration within the view. So, for example, if you are iterating over an array of jobs , typically you
will want to access each job as a job variable within the view. The array key for the current iteration will be available as
the key variable within the view.
You may also pass a fourth argument to the @each directive. This argument determines the view that will be rendered if
the given array is empty.
@each('view.name', $jobs, 'job', 'view.empty')

Views rendered via @each do not inherit the variables from the parent view. If the child view
requires these variables, you should use the @foreach and @include directives instead.

The @once Directive

The @once directive allows you to define a portion of the template that will only be evaluated once per rendering cycle.
This may be useful for pushing a given piece of JavaScript into the page's header using stacks. For example, if you are
rendering a given component within a loop, you may wish to only push the JavaScript to the header the first time the
component is rendered:
@once
@push('scripts')
<script>
// Your custom JavaScript...
</script>
@endpush
@endonce

Since the @once directive is often used in conjunction with the @push or @prepend directives, the @pushOnce and
@prependOnce directives are available for your convenience:
@pushOnce('scripts')
<script>
// Your custom JavaScript...
</script>
@endPushOnce

Page 179 of 1307

Laravel 9.x

Raw PHP

In some situations, it's useful to embed PHP code into your views. You can use the Blade @php directive to execute a
block of plain PHP within your template:
@php
$counter = 1;
@endphp

If you only need to write a single PHP statement, you can include the statement within the @php directive:
@php($counter = 1)

Comments

Blade also allows you to define comments in your views. However, unlike HTML comments, Blade comments are not
included in the HTML returned by your application:
{{-- This comment will not be present in the rendered HTML --}}

Components

Components and slots provide similar benefits to sections, layouts, and includes; however, some may find the mental
model of components and slots easier to understand. There are two approaches to writing components: class based
components and anonymous components.
To create a class based component, you may use the make:component Artisan command. To illustrate how to use
components, we will create a simple Alert component. The make:component command will place the component in
the app/View/Components directory:
php artisan make:component Alert

The make:component command will also create a view template for the component. The view will be placed in the
resources/views/components directory. When writing components for your own application, components are
automatically discovered within the app/View/Components directory and resources/views/components directory, so
no further component registration is typically required.
You may also create components within subdirectories:
php artisan make:component Forms/Input

The command above will create an Input component in the app/View/Components/Forms directory and the view will
be placed in the resources/views/components/forms directory.
If you would like to create an anonymous component (a component with only a Blade template and no class), you may use
the --view flag when invoking the make:component command:
php artisan make:component forms.input --view

The command above will create a Blade file at resources/views/components/forms/input.blade.php which can be
rendered as a component via <x-forms.input /> .
Manually Registering Package Components
Page 180 of 1307

Laravel 9.x

When writing components for your own application, components are automatically discovered within the
app/View/Components directory and resources/views/components directory.
However, if you are building a package that utilizes Blade components, you will need to manually register your component
class and its HTML tag alias. You should typically register your components in the boot method of your package's
service provider:
use Illuminate\Support\Facades\Blade;
/**
* Bootstrap your package's services.
*/
public function boot()
{
Blade::component('package-alert', Alert::class);
}

Once your component has been registered, it may be rendered using its tag alias:
<x-package-alert/>

Alternatively, you may use the componentNamespace method to autoload component classes by convention. For
example, a Nightshade package might have Calendar and ColorPicker components that reside within the
Package\Views\Components namespace:
use Illuminate\Support\Facades\Blade;
/**
* Bootstrap your package's services.
*
* @return void
*/
public function boot()
{
Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');
}

This will allow the usage of package components by their vendor namespace using the package-name:: syntax:
<x-nightshade::calendar />
<x-nightshade::color-picker />

Blade will automatically detect the class that's linked to this component by pascal-casing the component name.
Subdirectories are also supported using "dot" notation.

Rendering Components

To display a component, you may use a Blade component tag within one of your Blade templates. Blade component tags
start with the string x- followed by the kebab case name of the component class:
<x-alert/>
<x-user-profile/>

Page 181 of 1307

Laravel 9.x

If the component class is nested deeper within the app/View/Components directory, you may use the . character to
indicate directory nesting. For example, if we assume a component is located at
app/View/Components/Inputs/Button.php , we may render it like so:
<x-inputs.button/>

Passing Data To Components

You may pass data to Blade components using HTML attributes. Hard-coded, primitive values may be passed to the
component using simple HTML attribute strings. PHP expressions and variables should be passed to the component via
attributes that use the : character as a prefix:
<x-alert type="error" :message="$message"/>

You should define all of the component's data attributes in its class constructor. All public properties on a component will
automatically be made available to the component's view. It is not necessary to pass the data to the view from the
component's render method:

Page 182 of 1307

Laravel 9.x

<?php
namespace App\View\Components;
use Illuminate\View\Component;
class Alert extends Component
{
/**
* The alert type.
*
* @var string
*/
public $type;
/**
* The alert message.
*
* @var string
*/
public $message;
/**
* Create the component instance.
*
* @param

string

$type

* @param

string

$message

* @return void
*/
public function __construct($type, $message)
{
$this->type = $type;
$this->message = $message;
}
/**
* Get the view / contents that represent the component.
*
* @return \Illuminate\View\View|\Closure|string
*/
public function render()
{
return view('components.alert');
}
}

When your component is rendered, you may display the contents of your component's public variables by echoing the
variables by name:
<div class="alert alert-{{ $type }}">
{{ $message }}
</div>

Casing
Page 183 of 1307

Laravel 9.x

Component constructor arguments should be specified using camelCase , while kebab-case should be used when
referencing the argument names in your HTML attributes. For example, given the following component constructor:
/**
* Create the component instance.
*
* @param

string

$alertType

* @return void
*/
public function __construct($alertType)
{
$this->alertType = $alertType;
}

The $alertType argument may be provided to the component like so:
<x-alert alert-type="danger" />

Short Attribute Syntax
When passing attributes to components, you may also use a "short attribute" syntax. This is often convenient since
attribute names frequently match the variable names they correspond to:
{{-- Short attribute syntax... --}}
<x-profile :$userId :$name />
{{-- Is equivalent to... --}}
<x-profile :user-id="$userId" :name="$name" />

Escaping Attribute Rendering
Since some JavaScript frameworks such as Alpine.js also use colon-prefixed attributes, you may use a double colon ( :: )
prefix to inform Blade that the attribute is not a PHP expression. For example, given the following component:
<x-button ::class="{ danger: isDeleting }">
Submit
</x-button>

The following HTML will be rendered by Blade:
<button :class="{ danger: isDeleting }">
Submit
</button>

Component Methods
In addition to public variables being available to your component template, any public methods on the component may be
invoked. For example, imagine a component that has an isSelected method:

Page 184 of 1307

Laravel 9.x

/**
* Determine if the given option is the currently selected option.
*
* @param

string

$option

* @return bool
*/
public function isSelected($option)
{
return $option === $this->selected;
}

You may execute this method from your component template by invoking the variable matching the name of the method:
<option {{ $isSelected($value) ? 'selected' : '' }} value="{{ $value }}">
{{ $label }}
</option>

Accessing Attributes & Slots Within Component Classes
Blade components also allow you to access the component name, attributes, and slot inside the class's render method.
However, in order to access this data, you should return a closure from your component's render method. The closure
will receive a $data array as its only argument. This array will contain several elements that provide information about
the component:
/**
* Get the view / contents that represent the component.
*
* @return \Illuminate\View\View|\Closure|string
*/
public function render()
{
return function (array $data) {
// $data['componentName'];
// $data['attributes'];
// $data['slot'];
return '<div>Components content</div>';
};
}

The componentName is equal to the name used in the HTML tag after the x- prefix. So <x-alert /> 's
componentName will be alert . The attributes element will contain all of the attributes that were present on the
HTML tag. The slot element is an Illuminate\Support\HtmlString instance with the contents of the component's
slot.
The closure should return a string. If the returned string corresponds to an existing view, that view will be rendered;
otherwise, the returned string will be evaluated as an inline Blade view.
Additional Dependencies
If your component requires dependencies from Laravel's service container, you may list them before any of the
component's data attributes and they will automatically be injected by the container:

Page 185 of 1307

Laravel 9.x

use App\Services\AlertCreator;
/**
* Create the component instance.
*
* @param

\App\Services\AlertCreator

* @param

string

$type

* @param

string

$message

$creator

* @return void
*/
public function __construct(AlertCreator $creator, $type, $message)
{
$this->creator = $creator;
$this->type = $type;
$this->message = $message;
}

Hiding Attributes / Methods
If you would like to prevent some public methods or properties from being exposed as variables to your component
template, you may add them to an $except array property on your component:
<?php
namespace App\View\Components;
use Illuminate\View\Component;
class Alert extends Component
{
/**
* The alert type.
*
* @var string
*/
public $type;
/**
* The properties / methods that should not be exposed to the component template.
*
* @var array
*/
protected $except = ['type'];
}

Component Attributes

We've already examined how to pass data attributes to a component; however, sometimes you may need to specify
additional HTML attributes, such as class , that are not part of the data required for a component to function. Typically,
you want to pass these additional attributes down to the root element of the component template. For example, imagine we
want to render an alert component like so:
<x-alert type="error" :message="$message" class="mt-4"/>

Page 186 of 1307

Laravel 9.x

All of the attributes that are not part of the component's constructor will automatically be added to the component's
"attribute bag". This attribute bag is automatically made available to the component via the $attributes variable. All of
the attributes may be rendered within the component by echoing this variable:
<div {{ $attributes }}>
<!-- Component content -->
</div>

Using directives such as @env within component tags is not supported at this time. For example,
<x-alert :live="@env('production')"/> will not be compiled.
Default / Merged Attributes
Sometimes you may need to specify default values for attributes or merge additional values into some of the component's
attributes. To accomplish this, you may use the attribute bag's merge method. This method is particularly useful for
defining a set of default CSS classes that should always be applied to a component:
<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>
{{ $message }}
</div>

If we assume this component is utilized like so:
<x-alert type="error" :message="$message" class="mb-4"/>

The final, rendered HTML of the component will appear like the following:
<div class="alert alert-error mb-4">
<!-- Contents of the $message variable -->
</div>

Conditionally Merge Classes
Sometimes you may wish to merge classes if a given condition is true . You can accomplish this via the class method,
which accepts an array of classes where the array key contains the class or classes you wish to add, while the value is a
boolean expression. If the array element has a numeric key, it will always be included in the rendered class list:
<div {{ $attributes->class(['p-4', 'bg-red' => $hasError]) }}>
{{ $message }}
</div>

If you need to merge other attributes onto your component, you can chain the merge method onto the class method:
<button {{ $attributes->class(['p-4'])->merge(['type' => 'button']) }}>
{{ $slot }}
</button>

Page 187 of 1307

Laravel 9.x

If you need to conditionally compile classes on other HTML elements that shouldn't receive merged
attributes, you can use the @class directive.
Non-Class Attribute Merging
When merging attributes that are not class attributes, the values provided to the merge method will be considered the
"default" values of the attribute. However, unlike the class attribute, these attributes will not be merged with injected
attribute values. Instead, they will be overwritten. For example, a button component's implementation may look like the
following:
<button {{ $attributes->merge(['type' => 'button']) }}>
{{ $slot }}
</button>

To render the button component with a custom type , it may be specified when consuming the component. If no type is
specified, the button type will be used:
<x-button type="submit">
Submit
</x-button>

The rendered HTML of the button component in this example would be:
<button type="submit">
Submit
</button>

If you would like an attribute other than class to have its default value and injected values joined together, you may use
the prepends method. In this example, the data-controller attribute will always begin with profile-controller
and any additional injected data-controller values will be placed after this default value:
<div {{ $attributes->merge(['data-controller' => $attributes->prepends('profile-controller')])
}}>
{{ $slot }}
</div>

Retrieving & Filtering Attributes
You may filter attributes using the filter method. This method accepts a closure which should return true if you wish
to retain the attribute in the attribute bag:
{{ $attributes->filter(fn ($value, $key) => $key == 'foo') }}

For convenience, you may use the whereStartsWith method to retrieve all attributes whose keys begin with a given
string:
{{ $attributes->whereStartsWith('wire:model') }}

Conversely, the whereDoesntStartWith method may be used to exclude all attributes whose keys begin with a given
string:
Page 188 of 1307

Laravel 9.x

{{ $attributes->whereDoesntStartWith('wire:model') }}

Using the first method, you may render the first attribute in a given attribute bag:
{{ $attributes->whereStartsWith('wire:model')->first() }}

If you would like to check if an attribute is present on the component, you may use the has method. This method accepts
the attribute name as its only argument and returns a boolean indicating whether or not the attribute is present:
@if ($attributes->has('class'))
<div>Class attribute is present</div>
@endif

You may retrieve a specific attribute's value using the get method:
{{ $attributes->get('class') }}

Reserved Keywords

By default, some keywords are reserved for Blade's internal use in order to render components. The following keywords
cannot be defined as public properties or method names within your components:
data
render
resolveView
shouldRender
view
withAttributes
withName

Slots

You will often need to pass additional content to your component via "slots". Component slots are rendered by echoing the
$slot variable. To explore this concept, let's imagine that an alert component has the following markup:
<!-- /resources/views/components/alert.blade.php -->
<div class="alert alert-danger">
{{ $slot }}
</div>

We may pass content to the slot by injecting content into the component:
<x-alert>
<strong>Whoops!</strong> Something went wrong!
</x-alert>

Sometimes a component may need to render multiple different slots in different locations within the component. Let's
modify our alert component to allow for the injection of a "title" slot:

Page 189 of 1307

Laravel 9.x

<!-- /resources/views/components/alert.blade.php -->
<span class="alert-title">{{ $title }}</span>
<div class="alert alert-danger">
{{ $slot }}
</div>

You may define the content of the named slot using the x-slot tag. Any content not within an explicit x-slot tag will
be passed to the component in the $slot variable:
<x-alert>
<x-slot:title>
Server Error
</x-slot>
<strong>Whoops!</strong> Something went wrong!
</x-alert>

Scoped Slots
If you have used a JavaScript framework such as Vue, you may be familiar with "scoped slots", which allow you to access
data or methods from the component within your slot. You may achieve similar behavior in Laravel by defining public
methods or properties on your component and accessing the component within your slot via the $component variable. In
this example, we will assume that the x-alert component has a public formatAlert method defined on its component
class:
<x-alert>
<x-slot:title>
{{ $component->formatAlert('Server Error') }}
</x-slot>
<strong>Whoops!</strong> Something went wrong!
</x-alert>

Slot Attributes
Like Blade components, you may assign additional attributes to slots such as CSS class names:
<x-card class="shadow-sm">
<x-slot:heading class="font-bold">
Heading
</x-slot>
Content
<x-slot:footer class="text-sm">
Footer
</x-slot>
</x-card>

To interact with slot attributes, you may access the attributes property of the slot's variable. For more information on
how to interact with attributes, please consult the documentation on component attributes:

Page 190 of 1307

Laravel 9.x

@props([
'heading',
'footer',
])
<div {{ $attributes->class(['border']) }}>
<h1 {{ $heading->attributes->class(['text-lg']) }}>
{{ $heading }}
</h1>
{{ $slot }}
<footer {{ $footer->attributes->class(['text-gray-700']) }}>
{{ $footer }}
</footer>
</div>

Inline Component Views

For very small components, it may feel cumbersome to manage both the component class and the component's view
template. For this reason, you may return the component's markup directly from the render method:
/**
* Get the view / contents that represent the component.
*
* @return \Illuminate\View\View|\Closure|string
*/
public function render()
{
return <<<'blade'
<div class="alert alert-danger">
{{ $slot }}
</div>
blade;
}

Generating Inline View Components
To create a component that renders an inline view, you may use the inline option when executing the
make:component command:
php artisan make:component Alert --inline

Dynamic Components

Sometimes you may need to render a component but not know which component should be rendered until runtime. In this
situation, you may use Laravel's built-in dynamic-component component to render the component based on a runtime
value or variable:
<x-dynamic-component :component="$componentName" class="mt-4" />

Manually Registering Components

Page 191 of 1307

Laravel 9.x

The following documentation on manually registering components is primarily applicable to those
who are writing Laravel packages that include view components. If you are not writing a package,
this portion of the component documentation may not be relevant to you.
When writing components for your own application, components are automatically discovered within the
app/View/Components directory and resources/views/components directory.
However, if you are building a package that utilizes Blade components or placing components in non-conventional
directories, you will need to manually register your component class and its HTML tag alias so that Laravel knows where to
find the component. You should typically register your components in the boot method of your package's service
provider:
use Illuminate\Support\Facades\Blade;
use VendorPackage\View\Components\AlertComponent;
/**
* Bootstrap your package's services.
*
* @return void
*/
public function boot()
{
Blade::component('package-alert', AlertComponent::class);
}

Once your component has been registered, it may be rendered using its tag alias:
<x-package-alert/>

Autoloading Package Components
Alternatively, you may use the componentNamespace method to autoload component classes by convention. For
example, a Nightshade package might have Calendar and ColorPicker components that reside within the
Package\Views\Components namespace:
use Illuminate\Support\Facades\Blade;
/**
* Bootstrap your package's services.
*
* @return void
*/
public function boot()
{
Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');
}

This will allow the usage of package components by their vendor namespace using the package-name:: syntax:
<x-nightshade::calendar />
<x-nightshade::color-picker />

Page 192 of 1307

Laravel 9.x

Blade will automatically detect the class that's linked to this component by pascal-casing the component name.
Subdirectories are also supported using "dot" notation.

Anonymous Components

Similar to inline components, anonymous components provide a mechanism for managing a component via a single file.
However, anonymous components utilize a single view file and have no associated class. To define an anonymous
component, you only need to place a Blade template within your resources/views/components directory. For example,
assuming you have defined a component at resources/views/components/alert.blade.php , you may simply render
it like so:
<x-alert/>

You may use the . character to indicate if a component is nested deeper inside the components directory. For example,
assuming the component is defined at resources/views/components/inputs/button.blade.php , you may render it
like so:
<x-inputs.button/>

Anonymous Index Components

Sometimes, when a component is made up of many Blade templates, you may wish to group the given component's
templates within a single directory. For example, imagine an "accordion" component with the following directory structure:
/resources/views/components/accordion.blade.php
/resources/views/components/accordion/item.blade.php

This directory structure allows you to render the accordion component and its item like so:
<x-accordion>
<x-accordion.item>
...
</x-accordion.item>
</x-accordion>

However, in order to render the accordion component via x-accordion , we were forced to place the "index" accordion
component template in the resources/views/components directory instead of nesting it within the accordion
directory with the other accordion related templates.
Thankfully, Blade allows you to place an index.blade.php file within a component's template directory. When an
index.blade.php template exists for the component, it will be rendered as the "root" node of the component. So, we
can continue to use the same Blade syntax given in the example above; however, we will adjust our directory structure like
so:
/resources/views/components/accordion/index.blade.php
/resources/views/components/accordion/item.blade.php

Data Properties / Attributes

Since anonymous components do not have any associated class, you may wonder how you may differentiate which data
should be passed to the component as variables and which attributes should be placed in the component's attribute bag.
You may specify which attributes should be considered data variables using the @props directive at the top of your
component's Blade template. All other attributes on the component will be available via the component's attribute bag. If
Page 193 of 1307

Laravel 9.x

you wish to give a data variable a default value, you may specify the variable's name as the array key and the default value
as the array value:
<!-- /resources/views/components/alert.blade.php -->
@props(['type' => 'info', 'message'])
<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>
{{ $message }}
</div>

Given the component definition above, we may render the component like so:
<x-alert type="error" :message="$message" class="mb-4"/>

Accessing Parent Data

Sometimes you may want to access data from a parent component inside a child component. In these cases, you may use
the @aware directive. For example, imagine we are building a complex menu component consisting of a parent <xmenu> and child <x-menu.item> :
<x-menu color="purple">
<x-menu.item>...</x-menu.item>
<x-menu.item>...</x-menu.item>
</x-menu>

The <x-menu> component may have an implementation like the following:
<!-- /resources/views/components/menu/index.blade.php -->
@props(['color' => 'gray'])
<ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}>
{{ $slot }}
</ul>

Because the color prop was only passed into the parent ( <x-menu> ), it won't be available inside <x-menu.item> .
However, if we use the @aware directive, we can make it available inside <x-menu.item> as well:
<!-- /resources/views/components/menu/item.blade.php -->
@aware(['color' => 'gray'])
<li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}>
{{ $slot }}
</li>

Page 194 of 1307

Laravel 9.x

The @aware directive can not access parent data that is not explicitly passed to the parent
component via HTML attributes. Default @props values that are not explicitly passed to the
parent component can not be accessed by the @aware directive.

Anonymous Component Paths

As previously discussed, anonymous components are typically defined by placing a Blade template within your
resources/views/components directory. However, you may occasionally want to register other anonymous component
paths with Laravel in addition to the default path.
The anonymousComponentPath method accepts the "path" to the anonymous component location as its first argument
and an optional "namespace" that components should be placed under as its second argument. Typically, this method
should be called from the boot method of one of your application's service providers:
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Blade::anonymousComponentPath(__DIR__.'/../components');
}

When component paths are registered without a specified prefix as in the example above, they may be rendered in your
Blade components without a corresponding prefix as well. For example, if a panel.blade.php component exists in the
path registered above, it may be rendered like so:
<x-panel />

Prefix "namespaces" may be provided as the second argument to the anonymousComponentPath method:
Blade::anonymousComponentPath(__DIR__.'/../components', 'dashboard');

When a prefix is provided, components within that "namespace" may be rendered by prefixing to the component's
namespace to the component name when the component is rendered:
<x-dashboard::panel />

Building Layouts

Layouts Using Components

Most web applications maintain the same general layout across various pages. It would be incredibly cumbersome and
hard to maintain our application if we had to repeat the entire layout HTML in every view we create. Thankfully, it's
convenient to define this layout as a single Blade component and then use it throughout our application.
Defining The Layout Component
For example, imagine we are building a "todo" list application. We might define a layout component that looks like the
following:
Page 195 of 1307

Laravel 9.x

<!-- resources/views/components/layout.blade.php -->
<html>
<head>
<title>{{ $title ?? 'Todo Manager' }}</title>
</head>
<body>
<h1>Todos</h1>
<hr/>
{{ $slot }}
</body>
</html>

Applying The Layout Component
Once the layout component has been defined, we may create a Blade view that utilizes the component. In this example,
we will define a simple view that displays our task list:
<!-- resources/views/tasks.blade.php -->
<x-layout>
@foreach ($tasks as $task)
{{ $task }}
@endforeach
</x-layout>

Remember, content that is injected into a component will be supplied to the default $slot variable within our layout
component. As you may have noticed, our layout also respects a $title slot if one is provided; otherwise, a default
title is shown. We may inject a custom title from our task list view using the standard slot syntax discussed in the
component documentation:
<!-- resources/views/tasks.blade.php -->
<x-layout>
<x-slot:title>
Custom Title
</x-slot>
@foreach ($tasks as $task)
{{ $task }}
@endforeach
</x-layout>

Now that we have defined our layout and task list views, we just need to return the task view from a route:
use App\Models\Task;
Route::get('/tasks', function () {
return view('tasks', ['tasks' => Task::all()]);
});

Layouts Using Template Inheritance
Defining A Layout

Page 196 of 1307

Laravel 9.x

Layouts may also be created via "template inheritance". This was the primary way of building applications prior to the
introduction of components.
To get started, let's take a look at a simple example. First, we will examine a page layout. Since most web applications
maintain the same general layout across various pages, it's convenient to define this layout as a single Blade view:
<!-- resources/views/layouts/app.blade.php -->
<html>
<head>
<title>App Name - @yield('title')</title>
</head>
<body>
@section('sidebar')
This is the master sidebar.
@show
<div class="container">
@yield('content')
</div>
</body>
</html>

As you can see, this file contains typical HTML mark-up. However, take note of the @section and @yield directives.
The @section directive, as the name implies, defines a section of content, while the @yield directive is used to display
the contents of a given section.
Now that we have defined a layout for our application, let's define a child page that inherits the layout.
Extending A Layout
When defining a child view, use the @extends Blade directive to specify which layout the child view should "inherit".
Views which extend a Blade layout may inject content into the layout's sections using @section directives. Remember, as
seen in the example above, the contents of these sections will be displayed in the layout using @yield :
<!-- resources/views/child.blade.php -->
@extends('layouts.app')
@section('title', 'Page Title')
@section('sidebar')
@@parent
<p>This is appended to the master sidebar.</p>
@endsection
@section('content')
<p>This is my body content.</p>
@endsection

In this example, the sidebar section is utilizing the @@parent directive to append (rather than overwriting) content to
the layout's sidebar. The @@parent directive will be replaced by the content of the layout when the view is rendered.

Page 197 of 1307

Laravel 9.x

Contrary to the previous example, this sidebar section ends with @endsection instead of
@show . The @endsection directive will only define a section while @show will define and
immediately yield the section.
The @yield directive also accepts a default value as its second parameter. This value will be rendered if the section
being yielded is undefined:
@yield('content', 'Default content')

Forms

CSRF Field

Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the
CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field:
<form method="POST" action="/profile">
@csrf
...
</form>

Method Field

Since HTML forms can't make PUT , PATCH , or DELETE requests, you will need to add a hidden _method field to
spoof these HTTP verbs. The @method Blade directive can create this field for you:
<form action="/foo/bar" method="POST">
@method('PUT')
...
</form>

Validation Errors

The @error directive may be used to quickly check if validation error messages exist for a given attribute. Within an
@error directive, you may echo the $message variable to display the error message:
<!-- /resources/views/post/create.blade.php -->
<label for="title">Post Title</label>
<input id="title"
type="text"
class="@error('title') is-invalid @enderror">
@error('title')
<div class="alert alert-danger">{{ $message }}</div>
@enderror

Page 198 of 1307

Laravel 9.x

Since the @error directive compiles to an "if" statement, you may use the @else directive to render content when
there is not an error for an attribute:
<!-- /resources/views/auth.blade.php -->
<label for="email">Email address</label>
<input id="email"
type="email"
class="@error('email') is-invalid @else is-valid @enderror">

You may pass the name of a specific error bag as the second parameter to the @error directive to retrieve validation
error messages on pages containing multiple forms:
<!-- /resources/views/auth.blade.php -->
<label for="email">Email address</label>
<input id="email"
type="email"
class="@error('email', 'login') is-invalid @enderror">
@error('email', 'login')
<div class="alert alert-danger">{{ $message }}</div>
@enderror

Stacks

Blade allows you to push to named stacks which can be rendered somewhere else in another view or layout. This can be
particularly useful for specifying any JavaScript libraries required by your child views:
@push('scripts')
<script src="/example.js"></script>
@endpush

If you would like to @push content if a given boolean expression evaluates to true , you may use the @pushIf
directive:
@pushIf($shouldPush, 'scripts')
<script src="/example.js"></script>
@endPushIf

You may push to a stack as many times as needed. To render the complete stack contents, pass the name of the stack to
the @stack directive:
<head>
<!-- Head Contents -->
@stack('scripts')
</head>

If you would like to prepend content onto the beginning of a stack, you should use the @prepend directive:

Page 199 of 1307

Laravel 9.x

@push('scripts')
This will be second...
@endpush
// Later...
@prepend('scripts')
This will be first...
@endprepend

Service Injection

The @inject directive may be used to retrieve a service from the Laravel service container. The first argument passed to
@inject is the name of the variable the service will be placed into, while the second argument is the class or interface
name of the service you wish to resolve:
@inject('metrics', 'App\Services\MetricsService')
<div>
Monthly Revenue: {{ $metrics->monthlyRevenue() }}.
</div>

Rendering Inline Blade Templates

Sometimes you may need to transform a raw Blade template string into valid HTML. You may accomplish this using the
render method provided by the Blade facade. The render method accepts the Blade template string and an
optional array of data to provide to the template:
use Illuminate\Support\Facades\Blade;
return Blade::render('Hello, {{ $name }}', ['name' => 'Julian Bashir']);

Laravel renders inline Blade templates by writing them to the storage/framework/views directory. If you would like
Laravel to remove these temporary files after rendering the Blade template, you may provide the deleteCachedView
argument to the method:
return Blade::render(
'Hello, {{ $name }}',
['name' => 'Julian Bashir'],
deleteCachedView: true
);

Rendering Blade Fragments

When using frontend frameworks such as Turbo and htmx, you may occasionally need to only return a portion of a Blade
template within your HTTP response. Blade "fragments" allow you to do just that. To get started, place a portion of your
Blade template within @fragment and @endfragment directives:

Page 200 of 1307

Laravel 9.x

@fragment('user-list')
<ul>
@foreach ($users as $user)
<li>{{ $user->name }}</li>
@endforeach
</ul>
@endfragment

Then, when rendering the view that utilizes this template, you may invoke the fragment method to specify that only the
specified fragment should be included in the outgoing HTTP response:
return view('dashboard', ['users' => $users])->fragment('user-list');

The fragmentIf method allows you to conditionally return a fragment of a view based on a given condition. Otherwise,
the entire view will be returned:
return view('dashboard', ['users' => $users])
->fragmentIf($request->hasHeader('HX-Request'), 'user-list');

The fragments and fragmentsIf methods allow you to return multiple view fragments in the response. The fragments
will be concatenated together:
view('dashboard', ['users' => $users])
->fragments(['user-list', 'comment-list']);
view('dashboard', ['users' => $users])
->fragmentsIf(
$request->hasHeader('HX-Request'),
['user-list', 'comment-list']
);

Extending Blade

Blade allows you to define your own custom directives using the directive method. When the Blade compiler
encounters the custom directive, it will call the provided callback with the expression that the directive contains.
The following example creates a @datetime($var) directive which formats a given $var , which should be an instance
of DateTime :

Page 201 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\Blade;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Blade::directive('datetime', function ($expression) {
return "<?php echo ($expression)->format('m/d/Y H:i'); ?>";
});
}
}

As you can see, we will chain the format method onto whatever expression is passed into the directive. So, in this
example, the final PHP generated by this directive will be:
<?php echo ($var)->format('m/d/Y H:i'); ?>

After updating the logic of a Blade directive, you will need to delete all of the cached Blade views.
The cached Blade views may be removed using the view:clear Artisan command.

Custom Echo Handlers

If you attempt to "echo" an object using Blade, the object's __toString method will be invoked. The __toString
method is one of PHP's built-in "magic methods". However, sometimes you may not have control over the __toString
method of a given class, such as when the class that you are interacting with belongs to a third-party library.
In these cases, Blade allows you to register a custom echo handler for that particular type of object. To accomplish this,
you should invoke Blade's stringable method. The stringable method accepts a closure. This closure should typehint the type of object that it is responsible for rendering. Typically, the stringable method should be invoked within the
boot method of your application's AppServiceProvider class:

Page 202 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Blade;
use Money\Money;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Blade::stringable(function (Money $money) {
return $money->formatTo('en_GB');
});
}

Once your custom echo handler has been defined, you may simply echo the object in your Blade template:
Cost: {{ $money }}

Custom If Statements

Programming a custom directive is sometimes more complex than necessary when defining simple, custom conditional
statements. For that reason, Blade provides a Blade::if method which allows you to quickly define custom conditional
directives using closures. For example, let's define a custom conditional that checks the configured default "disk" for the
application. We may do this in the boot method of our AppServiceProvider :
use Illuminate\Support\Facades\Blade;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Blade::if('disk', function ($value) {
return config('filesystems.default') === $value;
});
}

Once the custom conditional has been defined, you can use it within your templates:
@disk('local')
<!-- The application is using the local disk... -->
@elsedisk('s3')
<!-- The application is using the s3 disk... -->
@else
<!-- The application is using some other disk... -->
@enddisk
@unlessdisk('local')
<!-- The application is not using the local disk... -->
@enddisk

Page 203 of 1307

Laravel 9.x

Asset Bundling (Vite)

Introduction
Installation & Setup
Installing Node
Installing Vite And The Laravel Plugin
Configuring Vite
Loading Your Scripts And Styles
Running Vite
Working With JavaScript
Aliases
Vue
React
Inertia
URL Processing
Working With Stylesheets
Working With Blade & Routes
Processing Static Assets With Vite
Refreshing On Save
Aliases
Custom Base URLs
Environment Variables
Disabling Vite In Tests
Server-Side Rendering (SSR)
Script & Style Tag Attributes
Content Security Policy (CSP) Nonce
Subresource Integrity (SRI)
Arbitrary Attributes
Advanced Customization
Correcting Dev Server URLs

Introduction

Vite is a modern frontend build tool that provides an extremely fast development environment and bundles your code for
production. When building applications with Laravel, you will typically use Vite to bundle your application's CSS and
JavaScript files into production ready assets.
Laravel integrates seamlessly with Vite by providing an official plugin and Blade directive to load your assets for
development and production.
Are you running Laravel Mix? Vite has replaced Laravel Mix in new Laravel installations. For Mix
documentation, please visit the Laravel Mix website. If you would like to switch to Vite, please see
our migration guide.
Choosing Between Vite And Laravel Mix
Before transitioning to Vite, new Laravel applications utilized Mix, which is powered by webpack, when bundling assets.
Vite focuses on providing a faster and more productive experience when building rich JavaScript applications. If you are
developing a Single Page Application (SPA), including those developed with tools like Inertia, Vite will be the perfect fit.
Page 204 of 1307

Laravel 9.x

Vite also works well with traditional server-side rendered applications with JavaScript "sprinkles", including those using
Livewire. However, it lacks some features that Laravel Mix supports, such as the ability to copy arbitrary assets into the
build that are not referenced directly in your JavaScript application.
Migrating Back To Mix
Have you started a new Laravel application using our Vite scaffolding but need to move back to Laravel Mix and webpack?
No problem. Please consult our official guide on migrating from Vite to Mix.

Installation & Setup
The following documentation discusses how to manually install and configure the Laravel Vite
plugin. However, Laravel's starter kits already include all of this scaffolding and are the fastest way
to get started with Laravel and Vite.

Installing Node

You must ensure that Node.js (16+) and NPM are installed before running Vite and the Laravel plugin:
node -v
npm -v

You can easily install the latest version of Node and NPM using simple graphical installers from the official Node website.
Or, if you are using Laravel Sail, you may invoke Node and NPM through Sail:
./vendor/bin/sail node -v
./vendor/bin/sail npm -v

Installing Vite And The Laravel Plugin

Within a fresh installation of Laravel, you will find a package.json file in the root of your application's directory
structure. The default package.json file already includes everything you need to get started using Vite and the Laravel
plugin. You may install your application's frontend dependencies via NPM:
npm install

Configuring Vite

Vite is configured via a vite.config.js file in the root of your project. You are free to customize this file based on your
needs, and you may also install any other plugins your application requires, such as @vitejs/plugin-vue or
@vitejs/plugin-react .
The Laravel Vite plugin requires you to specify the entry points for your application. These may be JavaScript or CSS files,
and include preprocessed languages such as TypeScript, JSX, TSX, and Sass.

Page 205 of 1307

Laravel 9.x

import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel([
'resources/css/app.css',
'resources/js/app.js',
]),
],
});

If you are building an SPA, including applications built using Inertia, Vite works best without CSS entry points:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel([
-

'resources/css/app.css',
'resources/js/app.js',
]),
],

});

Instead, you should import your CSS via JavaScript. Typically, this would be done in your application's
resources/js/app.js file:
import './bootstrap';
+ import '../css/app.css';

The Laravel plugin also supports multiple entry points and advanced configuration options such as SSR entry points.
Working With A Secure Development Server
If your local development web server is serving your application via HTTPS, you may run into issues connecting to the Vite
development server.
If you are using Laravel Valet for local development and have run the secure command against your application, you may
configure the Vite development server to automatically use Valet's generated TLS certificates:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel({
// ...
+

valetTls: 'my-app.test',
}),
],

});

Page 206 of 1307

Laravel 9.x

When using another web server, you should generate a trusted certificate and manually configure Vite to use the
generated certificates:
// ...
+ import fs from 'fs';
+ const host = 'my-app.test';
export default defineConfig({
// ...
+

server: {

+

host,

+

hmr: { host },

+

https: {

+

key: fs.readFileSync(`/path/to/${host}.key`),

+

cert: fs.readFileSync(`/path/to/${host}.crt`),

+

},

+

},

});

If you are unable to generate a trusted certificate for your system, you may install and configure the @vitejs/pluginbasic-ssl plugin. When using untrusted certificates, you will need to accept the certificate warning for Vite's
development server in your browser by following the "Local" link in your console when running the npm run dev
command.

Loading Your Scripts And Styles

With your Vite entry points configured, you only need reference them in a @vite() Blade directive that you add to the
<head> of your application's root template:
<!doctype html>
<head>
{{-- ... --}}
@vite(['resources/css/app.css', 'resources/js/app.js'])
</head>

If you're importing your CSS via JavaScript, you only need to include the JavaScript entry point:
<!doctype html>
<head>
{{-- ... --}}
@vite('resources/js/app.js')
</head>

The @vite directive will automatically detect the Vite development server and inject the Vite client to enable Hot Module
Replacement. In build mode, the directive will load your compiled and versioned assets, including any imported CSS.
If needed, you may also specify the build path of your compiled assets when invoking the @vite directive:

Page 207 of 1307

Laravel 9.x

<!doctype html>
<head>
{{-- Given build path is relative to public path. --}}
@vite('resources/js/app.js', 'vendor/courier/build')
</head>

Running Vite

There are two ways you can run Vite. You may run the development server via the dev command, which is useful while
developing locally. The development server will automatically detect changes to your files and instantly reflect them in any
open browser windows.
Or, running the build command will version and bundle your application's assets and get them ready for you to deploy to
production:
# Run the Vite development server...
npm run dev
# Build and version the assets for production...
npm run build

Working With JavaScript
Aliases

By default, The Laravel plugin provides a common alias to help you hit the ground running and conveniently import your
application's assets:
{
'@' => '/resources/js'
}

You may overwrite the '@' alias by adding your own to the vite.config.js configuration file:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel(['resources/ts/app.tsx']),
],
resolve: {
alias: {
'@': '/resources/ts',
},
},
});

Vue

If you would like to build your front-end using the Vue framework, then you will also need to install the @vitejs/pluginvue plugin:
Page 208 of 1307

Laravel 9.x

npm install --save-dev @vitejs/plugin-vue

You may then include the plugin in your vite.config.js configuration file. There are a few additional options you will
need when using the Vue plugin with Laravel:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
import vue from '@vitejs/plugin-vue';
export default defineConfig({
plugins: [
laravel(['resources/js/app.js']),
vue({
template: {
transformAssetUrls: {
// The Vue plugin will re-write asset URLs, when referenced
// in Single File Components, to point to the Laravel web
// server. Setting this to `null` allows the Laravel plugin
// to instead re-write asset URLs to point to the Vite
// server instead.
base: null,
// The Vue plugin will parse absolute URLs and treat them
// as absolute paths to files on disk. Setting this to
// `false` will leave absolute URLs un-touched so they can
// reference assets in the public directory as expected.
includeAbsolute: false,
},
},
}),
],
});

Laravel's starter kits already include the proper Laravel, Vue, and Vite configuration. Check out
Laravel Breeze for the fastest way to get started with Laravel, Vue, and Vite.

React

If you would like to build your front-end using the React framework, then you will also need to install the
@vitejs/plugin-react plugin:
npm install --save-dev @vitejs/plugin-react

You may then include the plugin in your vite.config.js configuration file:

Page 209 of 1307

Laravel 9.x

import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
import react from '@vitejs/plugin-react';
export default defineConfig({
plugins: [
laravel(['resources/js/app.jsx']),
react(),
],
});

You will need to ensure that any files containing JSX have a .jsx or .tsx extension, remembering to update your entry
point, if required, as shown above.
You will also need to include the additional @viteReactRefresh Blade directive alongside your existing @vite
directive.
@viteReactRefresh
@vite('resources/js/app.jsx')

The @viteReactRefresh directive must be called before the @vite directive.
Laravel's starter kits already include the proper Laravel, React, and Vite configuration. Check out
Laravel Breeze for the fastest way to get started with Laravel, React, and Vite.

Inertia

The Laravel Vite plugin provides a convenient resolvePageComponent function to help you resolve your Inertia page
components. Below is an example of the helper in use with Vue 3; however, you may also utilize the function in other
frameworks such as React:
import { createApp, h } from 'vue';
import { createInertiaApp } from '@inertiajs/vue3';
import { resolvePageComponent } from 'laravel-vite-plugin/inertia-helpers';
createInertiaApp({
resolve: (name) => resolvePageComponent(`./Pages/${name}.vue`,
import.meta.glob('./Pages/**/*.vue')),
setup({ el, App, props, plugin }) {
return createApp({ render: () => h(App, props) })
.use(plugin)
.mount(el)
},
});

Laravel's starter kits already include the proper Laravel, Inertia, and Vite configuration. Check out
Laravel Breeze for the fastest way to get started with Laravel, Inertia, and Vite.

Page 210 of 1307

Laravel 9.x

URL Processing

When using Vite and referencing assets in your application's HTML, CSS, or JS, there are a couple of caveats to consider.
First, if you reference assets with an absolute path, Vite will not include the asset in the build; therefore, you should ensure
that the asset is available in your public directory.
When referencing relative asset paths, you should remember that the paths are relative to the file where they are
referenced. Any assets referenced via a relative path will be re-written, versioned, and bundled by Vite.
Consider the following project structure:
public/
taylor.png
resources/
js/
Pages/
Welcome.vue
images/
abigail.png

The following example demonstrates how Vite will treat relative and absolute URLs:
<!-- This asset is not handled by Vite and will not be included in the build -->
<img src="/taylor.png">
<!-- This asset will be re-written, versioned, and bundled by Vite -->
<img src="../../images/abigail.png">

Working With Stylesheets

You can learn more about Vite's CSS support within the Vite documentation. If you are using PostCSS plugins such as
Tailwind, you may create a postcss.config.js file in the root of your project and Vite will automatically apply it:
module.exports = {
plugins: {
tailwindcss: {},
autoprefixer: {},
},
};

Working With Blade & Routes
Processing Static Assets With Vite

When referencing assets in your JavaScript or CSS, Vite automatically processes and versions them. In addition, when
building Blade based applications, Vite can also process and version static assets that you reference solely in Blade
templates.
However, in order to accomplish this, you need to make Vite aware of your assets by importing the static assets into the
application's entry point. For example, if you want to process and version all images stored in resources/images and all
fonts stored in resources/fonts , you should add the following in your application's resources/js/app.js entry
point:

Page 211 of 1307

Laravel 9.x

import.meta.glob([
'../images/**',
'../fonts/**',
]);

These assets will now be processed by Vite when running npm run build . You can then reference these assets in Blade
templates using the Vite::asset method, which will return the versioned URL for a given asset:
<img src="{{ Vite::asset('resources/images/logo.png') }}">

Refreshing On Save

When your application is built using traditional server-side rendering with Blade, Vite can improve your development
workflow by automatically refreshing the browser when you make changes to view files in your application. To get started,
you can simply specify the refresh option as true .
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel({
// ...
refresh: true,
}),
],
});

When the refresh option is true , saving files in the following directories will trigger the browser to perform a full page
refresh while you are running npm run dev :
app/View/Components/**
lang/**
resources/lang/**
resources/views/**
routes/**

Watching the routes/** directory is useful if you are utilizing Ziggy to generate route links within your application's
frontend.
If these default paths do not suit your needs, you can specify your own list of paths to watch:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel({
// ...
refresh: ['resources/views/**'],
}),
],
});

Page 212 of 1307

Laravel 9.x

Under the hood, the Laravel Vite plugin uses the vite-plugin-full-reload package, which offers some advanced
configuration options to fine-tune this feature's behavior. If you need this level of customization, you may provide a
config definition:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel({
// ...
refresh: [{
paths: ['path/to/watch/**'],
config: { delay: 300 }
}],
}),
],
});

Aliases

It is common in JavaScript applications to create aliases to regularly referenced directories. But, you may also create
aliases to use in Blade by using the macro method on the Illuminate\Support\Facades\Vite class. Typically,
"macros" should be defined within the boot method of a service provider:
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Vite::macro('image', fn ($asset) => $this->asset("resources/images/{$asset}"));
}

Once a macro has been defined, it can be invoked within your templates. For example, we can use the image macro
defined above to reference an asset located at resources/images/logo.png :
<img src="{{ Vite::image('logo.png') }}" alt="Laravel Logo">

Custom Base URLs

If your Vite compiled assets are deployed to a domain separate from your application, such as via a CDN, you must specify
the ASSET_URL environment variable within your application's .env file:
ASSET_URL=https://cdn.example.com

After configuring the asset URL, all re-written URLs to your assets will be prefixed with the configured value:
https://cdn.example.com/build/assets/app.9dce8d17.js

Remember that absolute URLs are not re-written by Vite, so they will not be prefixed.

Page 213 of 1307

Laravel 9.x

Environment Variables

You may inject environment variables into your JavaScript by prefixing them with VITE_ in your application's .env file:
VITE_SENTRY_DSN_PUBLIC=http://example.com

You may access injected environment variables via the import.meta.env object:
import.meta.env.VITE_SENTRY_DSN_PUBLIC

Disabling Vite In Tests

Laravel's Vite integration will attempt to resolve your assets while running your tests, which requires you to either run the
Vite development server or build your assets.
If you would prefer to mock Vite during testing, you may call the withoutVite method, which is is available for any tests
that extend Laravel's TestCase class:
use Tests\TestCase;
class ExampleTest extends TestCase
{
public function test_without_vite_example()
{
$this->withoutVite();
// ...
}
}

If you would like to disable Vite for all tests, you may call the withoutVite method from the setUp method on your
base TestCase class:
<?php
namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase
{
use CreatesApplication;
+

protected function setUp(): void
{
parent::setUp();
$this->withoutVite();
}

}

Server-Side Rendering (SSR)
Page 214 of 1307

Laravel 9.x

The Laravel Vite plugin makes it painless to set up server-side rendering with Vite. To get started, create an SSR entry
point at resources/js/ssr.js and specify the entry point by passing a configuration option to the Laravel plugin:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel({
input: 'resources/js/app.js',
ssr: 'resources/js/ssr.js',
}),
],
});

To ensure you don't forget to rebuild the SSR entry point, we recommend augmenting the "build" script in your
application's package.json to create your SSR build:
"scripts": {
"dev": "vite",
-

"build": "vite build"

+

"build": "vite build && vite build --ssr"

}

Then, to build and start the SSR server, you may run the following commands:
npm run build
node bootstrap/ssr/ssr.mjs

Laravel's starter kits already include the proper Laravel, Inertia SSR, and Vite configuration. Check
out Laravel Breeze for the fastest way to get started with Laravel, Inertia SSR, and Vite.

Script & Style Tag Attributes

Content Security Policy (CSP) Nonce

If you wish to include a nonce attribute on your script and style tags as part of your Content Security Policy, you may
generate or specify a nonce using the useCspNonce method within a custom middleware:

Page 215 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\Vite;
class AddContentSecurityPolicyHeaders
{
/**
* Handle an incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

$request

$next

* @return mixed
*/
public function handle($request, Closure $next)
{
Vite::useCspNonce();
return $next($request)->withHeaders([
'Content-Security-Policy' => "script-src 'nonce-".Vite::cspNonce()."'",
]);
}
}

After invoking the useCspNonce method, Laravel will automatically include the nonce attributes on all generated script
and style tags.
If you need to specify the nonce elsewhere, including the Ziggy @route directive included with Laravel's starter kits, you
may retrieve it using the cspNonce method:
@routes(nonce: Vite::cspNonce())

If you already have a nonce that you would like to instruct Laravel to use, you may pass the nonce to the useCspNonce
method:
Vite::useCspNonce($nonce);

Subresource Integrity (SRI)

If your Vite manifest includes integrity hashes for your assets, Laravel will automatically add the integrity attribute
on any script and style tags it generates in order to enforce Subresource Integrity. By default, Vite does not include the
integrity hash in its manifest, but you may enable it by installing the vite-plugin-manifest-sri NPM plugin:
npm install --save-dev vite-plugin-manifest-sri

You may then enable this plugin in your vite.config.js file:

Page 216 of 1307

Laravel 9.x

import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
+ import manifestSRI from 'vite-plugin-manifest-sri';
export default defineConfig({
plugins: [
laravel({
// ...
}),
+

manifestSRI(),
],

});

If required, you may also customize the manifest key where the integrity hash can be found:
use Illuminate\Support\Facades\Vite;
Vite::useIntegrityKey('custom-integrity-key');

If you would like to disable this auto-detection completely, you may pass false to the useIntegrityKey method:
Vite::useIntegrityKey(false);

Arbitrary Attributes

If you need to include additional attributes on your script and style tags, such as the data-turbo-track attribute, you
may specify them via the useScriptTagAttributes and useStyleTagAttributes methods. Typically, this methods
should be invoked from a service provider:
use Illuminate\Support\Facades\Vite;
Vite::useScriptTagAttributes([
'data-turbo-track' => 'reload', // Specify a value for the attribute...
'async' => true, // Specify an attribute without a value...
'integrity' => false, // Exclude an attribute that would otherwise be included...
]);
Vite::useStyleTagAttributes([
'data-turbo-track' => 'reload',
]);

If you need to conditionally add attributes, you may pass a callback that will receive the asset source path, its URL, its
manifest chunk, and the entire manifest:

Page 217 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Vite;
Vite::useScriptTagAttributes(fn (string $src, string $url, array|null $chunk, array|null
$manifest) => [
'data-turbo-track' => $src === 'resources/js/app.js' ? 'reload' : false,
]);
Vite::useStyleTagAttributes(fn (string $src, string $url, array|null $chunk, array|null
$manifest) => [
'data-turbo-track' => $chunk && $chunk['isEntry'] ? 'reload' : false,
]);

The $chunk and $manifest arguments will be null while the Vite development server is
running.

Advanced Customization

Out of the box, Laravel's Vite plugin uses sensible conventions that should work for the majority of applications; however,
sometimes you may need to customize Vite's behavior. To enable additional customization options, we offer the following
methods and options which can be used in place of the @vite Blade directive:
<!doctype html>
<head>
{{-- ... --}}
{{
Vite::useHotFile(storage_path('vite.hot')) // Customize the "hot" file...
->useBuildDirectory('bundle') // Customize the build directory...
->useManifestFilename('assets.json') // Customize the manifest filename...
->withEntryPoints(['resources/js/app.js']) // Specify the entry points...
}}
</head>

Within the vite.config.js file, you should then specify the same configuration:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
plugins: [
laravel({
hotFile: 'storage/vite.hot', // Customize the "hot" file...
buildDirectory: 'bundle', // Customize the build directory...
input: ['resources/js/app.js'], // Specify the entry points...
}),
],
build: {
manifest: 'assets.json', // Customize the manifest filename...
},
});

Page 218 of 1307

Laravel 9.x

Correcting Dev Server URLs

Some plugins within the Vite ecosystem assume that URLs which begin with a forward-slash will always point to the Vite
dev server. However, due to the nature of the Laravel integration, this is not the case.
For example, the vite-imagetools plugin outputs URLs like the following while Vite is serving your assets:
<img src="/@imagetools/f0b2f404b13f052c604e632f2fb60381bf61a520">

The vite-imagetools plugin is expecting that the output URL will be intercepted by Vite and the plugin may then handle
all URLs that start with /@imagetools . If you are using plugins that are expecting this behaviour, you will need to
manually correct the URLs. You can do this in your vite.config.js file by using the transformOnServe option.
In this particular example, we will append the dev server URL to all occurrences of /@imagetools within the generated
code:
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
import { imagetools } from 'vite-imagetools';
export default defineConfig({
plugins: [
laravel({
// ...
transformOnServe: (code, devServerUrl) => code.replaceAll('/@imagetools',
devServerUrl+'/@imagetools'),
}),
imagetools(),
],
});

Now, while Vite is serving Assets, it will output URLs that point to the Vite dev server:
- <img src="/@imagetools/f0b2f404b13f052c604e632f2fb60381bf61a520"><!-- [tl! remove] -->
+ <img src="http://[::1]:5173/@imagetools/f0b2f404b13f052c604e632f2fb60381bf61a520"><!-- [tl!
add] -->

Page 219 of 1307

Laravel 9.x

URL Generation

Introduction
The Basics
Generating URLs
Accessing The Current URL
URLs For Named Routes
Signed URLs
URLs For Controller Actions
Default Values

Introduction

Laravel provides several helpers to assist you in generating URLs for your application. These helpers are primarily helpful
when building links in your templates and API responses, or when generating redirect responses to another part of your
application.

The Basics

Generating URLs

The url helper may be used to generate arbitrary URLs for your application. The generated URL will automatically use
the scheme (HTTP or HTTPS) and host from the current request being handled by the application:
$post = App\Models\Post::find(1);
echo url("/posts/{$post->id}");
// http://example.com/posts/1

Accessing The Current URL

If no path is provided to the url helper, an Illuminate\Routing\UrlGenerator instance is returned, allowing you to
access information about the current URL:
// Get the current URL without the query string...
echo url()->current();
// Get the current URL including the query string...
echo url()->full();
// Get the full URL for the previous request...
echo url()->previous();

Each of these methods may also be accessed via the URL facade:
use Illuminate\Support\Facades\URL;
echo URL::current();

URLs For Named Routes
Page 220 of 1307

Laravel 9.x

The route helper may be used to generate URLs to named routes. Named routes allow you to generate URLs without
being coupled to the actual URL defined on the route. Therefore, if the route's URL changes, no changes need to be made
to your calls to the route function. For example, imagine your application contains a route defined like the following:
Route::get('/post/{post}', function (Post $post) {
//
})->name('post.show');

To generate a URL to this route, you may use the route helper like so:
echo route('post.show', ['post' => 1]);
// http://example.com/post/1

Of course, the route helper may also be used to generate URLs for routes with multiple parameters:
Route::get('/post/{post}/comment/{comment}', function (Post $post, Comment $comment) {
//
})->name('comment.show');
echo route('comment.show', ['post' => 1, 'comment' => 3]);
// http://example.com/post/1/comment/3

Any additional array elements that do not correspond to the route's definition parameters will be added to the URL's query
string:
echo route('post.show', ['post' => 1, 'search' => 'rocket']);
// http://example.com/post/1?search=rocket

Eloquent Models
You will often be generating URLs using the route key (typically the primary key) of Eloquent models. For this reason, you
may pass Eloquent models as parameter values. The route helper will automatically extract the model's route key:
echo route('post.show', ['post' => $post]);

Signed URLs

Laravel allows you to easily create "signed" URLs to named routes. These URLs have a "signature" hash appended to the
query string which allows Laravel to verify that the URL has not been modified since it was created. Signed URLs are
especially useful for routes that are publicly accessible yet need a layer of protection against URL manipulation.
For example, you might use signed URLs to implement a public "unsubscribe" link that is emailed to your customers. To
create a signed URL to a named route, use the signedRoute method of the URL facade:
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);

If you would like to generate a temporary signed route URL that expires after a specified amount of time, you may use the
temporarySignedRoute method. When Laravel validates a temporary signed route URL, it will ensure that the expiration
Page 221 of 1307

Laravel 9.x

timestamp that is encoded into the signed URL has not elapsed:
use Illuminate\Support\Facades\URL;
return URL::temporarySignedRoute(
'unsubscribe', now()->addMinutes(30), ['user' => 1]
);

Validating Signed Route Requests
To verify that an incoming request has a valid signature, you should call the hasValidSignature method on the
incoming Illuminate\Http\Request instance:
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
if (! $request->hasValidSignature()) {
abort(401);
}
// ...
})->name('unsubscribe');

Sometimes, you may need to allow your application's frontend to append data to a signed URL, such as when performing
client-side pagination. Therefore, you can specify request query parameters that should be ignored when validating a
signed URL using the hasValidSignatureWhileIgnoring method. Remember, ignoring parameters allows anyone to
modify those parameters on the request:
if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {
abort(401);
}

Instead of validating signed URLs using the incoming request instance, you may assign the
Illuminate\Routing\Middleware\ValidateSignature middleware to the route. If it is not already present, you should
assign this middleware a key in your HTTP kernel's routeMiddleware array:
/**
* The application's route middleware.
*
* These middleware may be assigned to groups or used individually.
*
* @var array
*/
protected $routeMiddleware = [
'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
];

Once you have registered the middleware in your kernel, you may attach it to a route. If the incoming request does not have
a valid signature, the middleware will automatically return a 403 HTTP response:
Route::post('/unsubscribe/{user}', function (Request $request) {
// ...
})->name('unsubscribe')->middleware('signed');

Page 222 of 1307

Laravel 9.x

Responding To Invalid Signed Routes
When someone visits a signed URL that has expired, they will receive a generic error page for the 403 HTTP status code.
However, you can customize this behavior by defining a custom "renderable" closure for the
InvalidSignatureException exception in your exception handler. This closure should return an HTTP response:
use Illuminate\Routing\Exceptions\InvalidSignatureException;
/**
* Register the exception handling callbacks for the application.
*
* @return void
*/
public function register()
{
$this->renderable(function (InvalidSignatureException $e) {
return response()->view('error.link-expired', [], 403);
});
}

URLs For Controller Actions

The action function generates a URL for the given controller action:
use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);

If the controller method accepts route parameters, you may pass an associative array of route parameters as the second
argument to the function:
$url = action([UserController::class, 'profile'], ['id' => 1]);

Default Values

For some applications, you may wish to specify request-wide default values for certain URL parameters. For example,
imagine many of your routes define a {locale} parameter:
Route::get('/{locale}/posts', function () {
//
})->name('post.index');

It is cumbersome to always pass the locale every time you call the route helper. So, you may use the
URL::defaults method to define a default value for this parameter that will always be applied during the current
request. You may wish to call this method from a route middleware so that you have access to the current request:

Page 223 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\URL;
class SetDefaultLocaleForUrls
{
/**
* Handle the incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

$request

$next

* @return \Illuminate\Http\Response
*/
public function handle($request, Closure $next)
{
URL::defaults(['locale' => $request->user()->locale]);
return $next($request);
}
}

Once the default value for the locale parameter has been set, you are no longer required to pass its value when
generating URLs via the route helper.
URL Defaults & Middleware Priority
Setting URL default values can interfere with Laravel's handling of implicit model bindings. Therefore, you should prioritize
your middleware that set URL defaults to be executed before Laravel's own SubstituteBindings middleware. You can
accomplish this by making sure your middleware occurs before the SubstituteBindings middleware within the
$middlewarePriority property of your application's HTTP kernel.
The $middlewarePriority property is defined in the base Illuminate\Foundation\Http\Kernel class. You may
copy its definition from that class and overwrite it in your application's HTTP kernel in order to modify it:
/**
* The priority-sorted list of middleware.
*
* This forces non-global middleware to always be in the given order.
*
* @var array
*/
protected $middlewarePriority = [
// ...
\App\Http\Middleware\SetDefaultLocaleForUrls::class,
\Illuminate\Routing\Middleware\SubstituteBindings::class,
// ...
];

Page 224 of 1307

Laravel 9.x

HTTP Session

Introduction
Configuration
Driver Prerequisites
Interacting With The Session
Retrieving Data
Storing Data
Flash Data
Deleting Data
Regenerating The Session ID
Session Blocking
Adding Custom Session Drivers
Implementing The Driver
Registering The Driver

Introduction

Since HTTP driven applications are stateless, sessions provide a way to store information about the user across multiple
requests. That user information is typically placed in a persistent store / backend that can be accessed from subsequent
requests.
Laravel ships with a variety of session backends that are accessed through an expressive, unified API. Support for popular
backends such as Memcached, Redis, and databases is included.

Configuration

Your application's session configuration file is stored at config/session.php . Be sure to review the options available to
you in this file. By default, Laravel is configured to use the file session driver, which will work well for many
applications. If your application will be load balanced across multiple web servers, you should choose a centralized store
that all servers can access, such as Redis or a database.
The session driver configuration option defines where session data will be stored for each request. Laravel ships with
several great drivers out of the box:
file - sessions are stored in storage/framework/sessions .
cookie - sessions are stored in secure, encrypted cookies.
database - sessions are stored in a relational database.
memcached / redis - sessions are stored in one of these fast, cache based stores.
dynamodb - sessions are stored in AWS DynamoDB.
array - sessions are stored in a PHP array and will not be persisted.
The array driver is primarily used during testing and prevents the data stored in the session from
being persisted.

Driver Prerequisites

Database
When using the database session driver, you will need to create a table to contain the session records. An example
Schema declaration for the table may be found below:
Page 225 of 1307

Laravel 9.x

Schema::create('sessions', function ($table) {
$table->string('id')->primary();
$table->foreignId('user_id')->nullable()->index();
$table->string('ip_address', 45)->nullable();
$table->text('user_agent')->nullable();
$table->text('payload');
$table->integer('last_activity')->index();
});

You may use the session:table Artisan command to generate this migration. To learn more about database migrations,
you may consult the complete migration documentation:
php artisan session:table
php artisan migrate

Redis
Before using Redis sessions with Laravel, you will need to either install the PhpRedis PHP extension via PECL or install the
predis/predis package (~1.0) via Composer. For more information on configuring Redis, consult Laravel's Redis
documentation.
In the session configuration file, the connection option may be used to specify which Redis
connection is used by the session.

Interacting With The Session
Retrieving Data

There are two primary ways of working with session data in Laravel: the global session helper and via a Request
instance. First, let's look at accessing the session via a Request instance, which can be type-hinted on a route closure or
controller method. Remember, controller method dependencies are automatically injected via the Laravel service container:

Page 226 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
class UserController extends Controller
{
/**
* Show the profile for the given user.
*
* @param

Request

* @param

int

$request

$id

* @return Response
*/
public function show(Request $request, $id)
{
$value = $request->session()->get('key');
//
}
}

When you retrieve an item from the session, you may also pass a default value as the second argument to the get
method. This default value will be returned if the specified key does not exist in the session. If you pass a closure as the
default value to the get method and the requested key does not exist, the closure will be executed and its result
returned:
$value = $request->session()->get('key', 'default');
$value = $request->session()->get('key', function () {
return 'default';
});

The Global Session Helper
You may also use the global session PHP function to retrieve and store data in the session. When the session helper
is called with a single, string argument, it will return the value of that session key. When the helper is called with an array of
key / value pairs, those values will be stored in the session:
Route::get('/home', function () {
// Retrieve a piece of data from the session...
$value = session('key');
// Specifying a default value...
$value = session('key', 'default');
// Store a piece of data in the session...
session(['key' => 'value']);
});

Page 227 of 1307

Laravel 9.x

There is little practical difference between using the session via an HTTP request instance versus
using the global session helper. Both methods are testable via the assertSessionHas method
which is available in all of your test cases.
Retrieving All Session Data
If you would like to retrieve all the data in the session, you may use the all method:
$data = $request->session()->all();

Determining If An Item Exists In The Session
To determine if an item is present in the session, you may use the has method. The has method returns true if the
item is present and is not null :
if ($request->session()->has('users')) {
//
}

To determine if an item is present in the session, even if its value is null , you may use the exists method:
if ($request->session()->exists('users')) {
//
}

To determine if an item is not present in the session, you may use the missing method. The missing method returns
true if the item is not present:
if ($request->session()->missing('users')) {
//
}

Storing Data

To store data in the session, you will typically use the request instance's put method or the global session helper:
// Via a request instance...
$request->session()->put('key', 'value');
// Via the global "session" helper...
session(['key' => 'value']);

Pushing To Array Session Values
The push method may be used to push a new value onto a session value that is an array. For example, if the
user.teams key contains an array of team names, you may push a new value onto the array like so:
$request->session()->push('user.teams', 'developers');

Retrieving & Deleting An Item
Page 228 of 1307

Laravel 9.x

The pull method will retrieve and delete an item from the session in a single statement:
$value = $request->session()->pull('key', 'default');

Incrementing & Decrementing Session Values
If your session data contains an integer you wish to increment or decrement, you may use the increment and
decrement methods:
$request->session()->increment('count');
$request->session()->increment('count', $incrementBy = 2);
$request->session()->decrement('count');
$request->session()->decrement('count', $decrementBy = 2);

Flash Data

Sometimes you may wish to store items in the session for the next request. You may do so using the flash method. Data
stored in the session using this method will be available immediately and during the subsequent HTTP request. After the
subsequent HTTP request, the flashed data will be deleted. Flash data is primarily useful for short-lived status messages:
$request->session()->flash('status', 'Task was successful!');

If you need to persist your flash data for several requests, you may use the reflash method, which will keep all of the
flash data for an additional request. If you only need to keep specific flash data, you may use the keep method:
$request->session()->reflash();
$request->session()->keep(['username', 'email']);

To persist your flash data only for the current request, you may use the now method:
$request->session()->now('status', 'Task was successful!');

Deleting Data

The forget method will remove a piece of data from the session. If you would like to remove all data from the session,
you may use the flush method:
// Forget a single key...
$request->session()->forget('name');
// Forget multiple keys...
$request->session()->forget(['name', 'status']);
$request->session()->flush();

Regenerating The Session ID

Regenerating the session ID is often done in order to prevent malicious users from exploiting a session fixation attack on
your application.
Page 229 of 1307

Laravel 9.x

Laravel automatically regenerates the session ID during authentication if you are using one of the Laravel application
starter kits or Laravel Fortify; however, if you need to manually regenerate the session ID, you may use the regenerate
method:
$request->session()->regenerate();

If you need to regenerate the session ID and remove all data from the session in a single statement, you may use the
invalidate method:
$request->session()->invalidate();

Session Blocking
To utilize session blocking, your application must be using a cache driver that supports atomic
locks. Currently, those cache drivers include the memcached , dynamodb , redis , and
database drivers. In addition, you may not use the cookie session driver.
By default, Laravel allows requests using the same session to execute concurrently. So, for example, if you use a JavaScript
HTTP library to make two HTTP requests to your application, they will both execute at the same time. For many
applications, this is not a problem; however, session data loss can occur in a small subset of applications that make
concurrent requests to two different application endpoints which both write data to the session.
To mitigate this, Laravel provides functionality that allows you to limit concurrent requests for a given session. To get
started, you may simply chain the block method onto your route definition. In this example, an incoming request to the
/profile endpoint would acquire a session lock. While this lock is being held, any incoming requests to the /profile
or /order endpoints which share the same session ID will wait for the first request to finish executing before continuing
their execution:
Route::post('/profile', function () {
//
})->block($lockSeconds = 10, $waitSeconds = 10)
Route::post('/order', function () {
//
})->block($lockSeconds = 10, $waitSeconds = 10)

The block method accepts two optional arguments. The first argument accepted by the block method is the maximum
number of seconds the session lock should be held for before it is released. Of course, if the request finishes executing
before this time the lock will be released earlier.
The second argument accepted by the block method is the number of seconds a request should wait while attempting
to obtain a session lock. An Illuminate\Contracts\Cache\LockTimeoutException will be thrown if the request is
unable to obtain a session lock within the given number of seconds.
If neither of these arguments is passed, the lock will be obtained for a maximum of 10 seconds and requests will wait a
maximum of 10 seconds while attempting to obtain a lock:
Route::post('/profile', function () {
//
})->block()

Page 230 of 1307

Laravel 9.x

Adding Custom Session Drivers

Implementing The Driver
If none of the existing session drivers fit your application's needs, Laravel makes it possible to write your own session
handler. Your custom session driver should implement PHP's built-in SessionHandlerInterface . This interface
contains just a few simple methods. A stubbed MongoDB implementation looks like the following:
<?php
namespace App\Extensions;
class MongoSessionHandler implements \SessionHandlerInterface
{
public function open($savePath, $sessionName) {}
public function close() {}
public function read($sessionId) {}
public function write($sessionId, $data) {}
public function destroy($sessionId) {}
public function gc($lifetime) {}
}

Laravel does not ship with a directory to contain your extensions. You are free to place them
anywhere you like. In this example, we have created an Extensions directory to house the
MongoSessionHandler .
Since the purpose of these methods is not readily understandable, let's quickly cover what each of the methods do:
The open method would typically be used in file based session store systems. Since Laravel ships with a file
session driver, you will rarely need to put anything in this method. You can simply leave this method empty.
The close method, like the open method, can also usually be disregarded. For most drivers, it is not needed.
The read method should return the string version of the session data associated with the given $sessionId .
There is no need to do any serialization or other encoding when retrieving or storing session data in your driver, as
Laravel will perform the serialization for you.
The write method should write the given $data string associated with the $sessionId to some persistent
storage system, such as MongoDB or another storage system of your choice. Again, you should not perform any
serialization - Laravel will have already handled that for you.
The destroy method should remove the data associated with the $sessionId from persistent storage.
The gc method should destroy all session data that is older than the given $lifetime , which is a UNIX
timestamp. For self-expiring systems like Memcached and Redis, this method may be left empty.
Registering The Driver
Once your driver has been implemented, you are ready to register it with Laravel. To add additional drivers to Laravel's
session backend, you may use the extend method provided by the Session facade. You should call the extend
method from the boot method of a service provider. You may do this from the existing
App\Providers\AppServiceProvider or create an entirely new provider:

Page 231 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use App\Extensions\MongoSessionHandler;
use Illuminate\Support\Facades\Session;
use Illuminate\Support\ServiceProvider;
class SessionServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Session::extend('mongo', function ($app) {
// Return an implementation of SessionHandlerInterface...
return new MongoSessionHandler;
});
}
}

Once the session driver has been registered, you may use the mongo driver in your config/session.php configuration
file.

Page 232 of 1307

Laravel 9.x

Validation

Introduction
Validation Quickstart
Defining The Routes
Creating The Controller
Writing The Validation Logic
Displaying The Validation Errors
Repopulating Forms
A Note On Optional Fields
Validation Error Response Format
Form Request Validation
Creating Form Requests
Authorizing Form Requests
Customizing The Error Messages
Preparing Input For Validation
Manually Creating Validators
Automatic Redirection
Named Error Bags
Customizing The Error Messages
After Validation Hook
Working With Validated Input
Working With Error Messages
Specifying Custom Messages In Language Files
Specifying Attributes In Language Files
Specifying Values In Language Files
Available Validation Rules
Conditionally Adding Rules
Validating Arrays
Validating Nested Array Input
Error Message Indexes & Positions
Validating Files
Validating Passwords
Custom Validation Rules
Using Rule Objects
Using Closures
Implicit Rules

Introduction

Laravel provides several different approaches to validate your application's incoming data. It is most common to use the
validate method available on all incoming HTTP requests. However, we will discuss other approaches to validation as
well.
Laravel includes a wide variety of convenient validation rules that you may apply to data, even providing the ability to
validate if values are unique in a given database table. We'll cover each of these validation rules in detail so that you are
familiar with all of Laravel's validation features.

Validation Quickstart

To learn about Laravel's powerful validation features, let's look at a complete example of validating a form and displaying
the error messages back to the user. By reading this high-level overview, you'll be able to gain a good general
Page 233 of 1307

Laravel 9.x

understanding of how to validate incoming request data using Laravel:

Defining The Routes

First, let's assume we have the following routes defined in our routes/web.php file:
use App\Http\Controllers\PostController;
Route::get('/post/create', [PostController::class, 'create']);
Route::post('/post', [PostController::class, 'store']);

The GET route will display a form for the user to create a new blog post, while the POST route will store the new blog
post in the database.

Creating The Controller

Next, let's take a look at a simple controller that handles incoming requests to these routes. We'll leave the store
method empty for now:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
class PostController extends Controller
{
/**
* Show the form to create a new blog post.
*
* @return \Illuminate\View\View
*/
public function create()
{
return view('post.create');
}
/**
* Store a new blog post.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
// Validate and store the blog post...
}
}

Writing The Validation Logic

Now we are ready to fill in our store method with the logic to validate the new blog post. To do this, we will use the
validate method provided by the Illuminate\Http\Request object. If the validation rules pass, your code will keep
executing normally; however, if validation fails, an Illuminate\Validation\ValidationException exception will be
thrown and the proper error response will automatically be sent back to the user.
Page 234 of 1307

Laravel 9.x

If validation fails during a traditional HTTP request, a redirect response to the previous URL will be generated. If the
incoming request is an XHR request, a JSON response containing the validation error messages will be returned.
To get a better understanding of the validate method, let's jump back into the store method:
/**
* Store a new blog post.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$validated = $request->validate([
'title' => 'required|unique:posts|max:255',
'body' => 'required',
]);
// The blog post is valid...
}

As you can see, the validation rules are passed into the validate method. Don't worry - all available validation rules are
documented. Again, if the validation fails, the proper response will automatically be generated. If the validation passes, our
controller will continue executing normally.
Alternatively, validation rules may be specified as arrays of rules instead of a single | delimited string:
$validatedData = $request->validate([
'title' => ['required', 'unique:posts', 'max:255'],
'body' => ['required'],
]);

In addition, you may use the validateWithBag method to validate a request and store any error messages within a
named error bag:
$validatedData = $request->validateWithBag('post', [
'title' => ['required', 'unique:posts', 'max:255'],
'body' => ['required'],
]);

Stopping On First Validation Failure
Sometimes you may wish to stop running validation rules on an attribute after the first validation failure. To do so, assign
the bail rule to the attribute:
$request->validate([
'title' => 'bail|required|unique:posts|max:255',
'body' => 'required',
]);

In this example, if the unique rule on the title attribute fails, the max rule will not be checked. Rules will be
validated in the order they are assigned.
A Note On Nested Attributes

Page 235 of 1307

Laravel 9.x

If the incoming HTTP request contains "nested" field data, you may specify these fields in your validation rules using "dot"
syntax:
$request->validate([
'title' => 'required|unique:posts|max:255',
'author.name' => 'required',
'author.description' => 'required',
]);

On the other hand, if your field name contains a literal period, you can explicitly prevent this from being interpreted as
"dot" syntax by escaping the period with a backslash:
$request->validate([
'title' => 'required|unique:posts|max:255',
'v1\.0' => 'required',
]);

Displaying The Validation Errors

So, what if the incoming request fields do not pass the given validation rules? As mentioned previously, Laravel will
automatically redirect the user back to their previous location. In addition, all of the validation errors and request input will
automatically be flashed to the session.
An $errors variable is shared with all of your application's views by the
Illuminate\View\Middleware\ShareErrorsFromSession middleware, which is provided by the web middleware
group. When this middleware is applied an $errors variable will always be available in your views, allowing you to
conveniently assume the $errors variable is always defined and can be safely used. The $errors variable will be an
instance of Illuminate\Support\MessageBag . For more information on working with this object, check out its
documentation.
So, in our example, the user will be redirected to our controller's create method when validation fails, allowing us to
display the error messages in the view:
<!-- /resources/views/post/create.blade.php -->
<h1>Create Post</h1>
@if ($errors->any())
<div class="alert alert-danger">
<ul>
@foreach ($errors->all() as $error)
<li>{{ $error }}</li>
@endforeach
</ul>
</div>
@endif
<!-- Create Post Form -->

Customizing The Error Messages
Laravel's built-in validation rules each have an error message that is located in your application's
lang/en/validation.php file. Within this file, you will find a translation entry for each validation rule. You are free to
change or modify these messages based on the needs of your application.

Page 236 of 1307

Laravel 9.x

In addition, you may copy this file to another translation language directory to translate the messages for your application's
language. To learn more about Laravel localization, check out the complete localization documentation.
XHR Requests & Validation
In this example, we used a traditional form to send data to the application. However, many applications receive XHR
requests from a JavaScript powered frontend. When using the validate method during an XHR request, Laravel will not
generate a redirect response. Instead, Laravel generates a JSON response containing all of the validation errors. This
JSON response will be sent with a 422 HTTP status code.
The @error Directive
You may use the @error Blade directive to quickly determine if validation error messages exist for a given attribute.
Within an @error directive, you may echo the $message variable to display the error message:
<!-- /resources/views/post/create.blade.php -->
<label for="title">Post Title</label>
<input id="title"
type="text"
name="title"
class="@error('title') is-invalid @enderror">
@error('title')
<div class="alert alert-danger">{{ $message }}</div>
@enderror

If you are using named error bags, you may pass the name of the error bag as the second argument to the @error
directive:
<input ... class="@error('title', 'post') is-invalid @enderror">

Repopulating Forms

When Laravel generates a redirect response due to a validation error, the framework will automatically flash all of the
request's input to the session. This is done so that you may conveniently access the input during the next request and
repopulate the form that the user attempted to submit.
To retrieve flashed input from the previous request, invoke the old method on an instance of
Illuminate\Http\Request . The old method will pull the previously flashed input data from the session:
$title = $request->old('title');

Laravel also provides a global old helper. If you are displaying old input within a Blade template, it is more convenient to
use the old helper to repopulate the form. If no old input exists for the given field, null will be returned:
<input type="text" name="title" value="{{ old('title') }}">

A Note On Optional Fields

By default, Laravel includes the TrimStrings and ConvertEmptyStringsToNull middleware in your application's
global middleware stack. These middleware are listed in the stack by the App\Http\Kernel class. Because of this, you
will often need to mark your "optional" request fields as nullable if you do not want the validator to consider null
values as invalid. For example:
Page 237 of 1307

Laravel 9.x

$request->validate([
'title' => 'required|unique:posts|max:255',
'body' => 'required',
'publish_at' => 'nullable|date',
]);

In this example, we are specifying that the publish_at field may be either null or a valid date representation. If the
nullable modifier is not added to the rule definition, the validator would consider null an invalid date.

Validation Error Response Format

When your application throws a Illuminate\Validation\ValidationException exception and the incoming HTTP
request is expecting a JSON response, Laravel will automatically format the error messages for you and return a 422
Unprocessable Entity HTTP response.
Below, you can review an example of the JSON response format for validation errors. Note that nested error keys are
flattened into "dot" notation format:
{
"message": "The team name must be a string. (and 4 more errors)",
"errors": {
"team_name": [
"The team name must be a string.",
"The team name must be at least 1 characters."
],
"authorization.role": [
"The selected authorization.role is invalid."
],
"users.0.email": [
"The users.0.email field is required."
],
"users.2.email": [
"The users.2.email must be a valid email address."
]
}
}

Form Request Validation
Creating Form Requests

For more complex validation scenarios, you may wish to create a "form request". Form requests are custom request
classes that encapsulate their own validation and authorization logic. To create a form request class, you may use the
make:request Artisan CLI command:
php artisan make:request StorePostRequest

The generated form request class will be placed in the app/Http/Requests directory. If this directory does not exist, it
will be created when you run the make:request command. Each form request generated by Laravel has two methods:
authorize and rules .
As you might have guessed, the authorize method is responsible for determining if the currently authenticated user can
perform the action represented by the request, while the rules method returns the validation rules that should apply to
the request's data:
Page 238 of 1307

Laravel 9.x

/**
* Get the validation rules that apply to the request.
*
* @return array
*/
public function rules()
{
return [
'title' => 'required|unique:posts|max:255',
'body' => 'required',
];
}

You may type-hint any dependencies you require within the rules method's signature. They will
automatically be resolved via the Laravel service container.
So, how are the validation rules evaluated? All you need to do is type-hint the request on your controller method. The
incoming form request is validated before the controller method is called, meaning you do not need to clutter your
controller with any validation logic:
/**
* Store a new blog post.
*
* @param

\App\Http\Requests\StorePostRequest

$request

* @return Illuminate\Http\Response
*/
public function store(StorePostRequest $request)
{
// The incoming request is valid...
// Retrieve the validated input data...
$validated = $request->validated();
// Retrieve a portion of the validated input data...
$validated = $request->safe()->only(['name', 'email']);
$validated = $request->safe()->except(['name', 'email']);
}

If validation fails, a redirect response will be generated to send the user back to their previous location. The errors will also
be flashed to the session so they are available for display. If the request was an XHR request, an HTTP response with a 422
status code will be returned to the user including a JSON representation of the validation errors.
Adding After Hooks To Form Requests
If you would like to add an "after" validation hook to a form request, you may use the withValidator method. This
method receives the fully constructed validator, allowing you to call any of its methods before the validation rules are
actually evaluated:

Page 239 of 1307

Laravel 9.x

/**
* Configure the validator instance.
*
* @param

\Illuminate\Validation\Validator

$validator

* @return void
*/
public function withValidator($validator)
{
$validator->after(function ($validator) {
if ($this->somethingElseIsInvalid()) {
$validator->errors()->add('field', 'Something is wrong with this field!');
}
});
}

Stopping On First Validation Failure Attribute
By adding a stopOnFirstFailure property to your request class, you may inform the validator that it should stop
validating all attributes once a single validation failure has occurred:
/**
* Indicates if the validator should stop on the first rule failure.
*
* @var bool
*/
protected $stopOnFirstFailure = true;

Customizing The Redirect Location
As previously discussed, a redirect response will be generated to send the user back to their previous location when form
request validation fails. However, you are free to customize this behavior. To do so, define a $redirect property on your
form request:
/**
* The URI that users should be redirected to if validation fails.
*
* @var string
*/
protected $redirect = '/dashboard';

Or, if you would like to redirect users to a named route, you may define a $redirectRoute property instead:
/**
* The route that users should be redirected to if validation fails.
*
* @var string
*/
protected $redirectRoute = 'dashboard';

Authorizing Form Requests

The form request class also contains an authorize method. Within this method, you may determine if the authenticated
user actually has the authority to update a given resource. For example, you may determine if a user actually owns a blog

Page 240 of 1307

Laravel 9.x

comment they are attempting to update. Most likely, you will interact with your authorization gates and policies within this
method:
use App\Models\Comment;
/**
* Determine if the user is authorized to make this request.
*
* @return bool
*/
public function authorize()
{
$comment = Comment::find($this->route('comment'));
return $comment && $this->user()->can('update', $comment);
}

Since all form requests extend the base Laravel request class, we may use the user method to access the currently
authenticated user. Also, note the call to the route method in the example above. This method grants you access to the
URI parameters defined on the route being called, such as the {comment} parameter in the example below:
Route::post('/comment/{comment}');

Therefore, if your application is taking advantage of route model binding, your code may be made even more succinct by
accessing the resolved model as a property of the request:
return $this->user()->can('update', $this->comment);

If the authorize method returns false , an HTTP response with a 403 status code will automatically be returned and
your controller method will not execute.
If you plan to handle authorization logic for the request in another part of your application, you may simply return true
from the authorize method:
/**
* Determine if the user is authorized to make this request.
*
* @return bool
*/
public function authorize()
{
return true;
}

You may type-hint any dependencies you need within the authorize method's signature. They
will automatically be resolved via the Laravel service container.

Customizing The Error Messages

You may customize the error messages used by the form request by overriding the messages method. This method
should return an array of attribute / rule pairs and their corresponding error messages:
Page 241 of 1307

Laravel 9.x

/**
* Get the error messages for the defined validation rules.
*
* @return array
*/
public function messages()
{
return [
'title.required' => 'A title is required',
'body.required' => 'A message is required',
];
}

Customizing The Validation Attributes
Many of Laravel's built-in validation rule error messages contain an :attribute placeholder. If you would like the
:attribute placeholder of your validation message to be replaced with a custom attribute name, you may specify the
custom names by overriding the attributes method. This method should return an array of attribute / name pairs:
/**
* Get custom attributes for validator errors.
*
* @return array
*/
public function attributes()
{
return [
'email' => 'email address',
];
}

Preparing Input For Validation

If you need to prepare or sanitize any data from the request before you apply your validation rules, you may use the
prepareForValidation method:
use Illuminate\Support\Str;
/**
* Prepare the data for validation.
*
* @return void
*/
protected function prepareForValidation()
{
$this->merge([
'slug' => Str::slug($this->slug),
]);
}

Likewise, if you need to normalize any request data after validation is complete, you may use the passedValidation
method:

Page 242 of 1307

Laravel 9.x

use Illuminate\Support\Str;
/**
* Handle a passed validation attempt.
*
* @return void
*/
protected function passedValidation()
{
$this->replace(['name' => 'Taylor']);
}

Manually Creating Validators

If you do not want to use the validate method on the request, you may create a validator instance manually using the
Validator facade. The make method on the facade generates a new validator instance:

Page 243 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;
class PostController extends Controller
{
/**
* Store a new blog post.
*
* @param

Request

$request

* @return Response
*/
public function store(Request $request)
{
$validator = Validator::make($request->all(), [
'title' => 'required|unique:posts|max:255',
'body' => 'required',
]);
if ($validator->fails()) {
return redirect('post/create')
->withErrors($validator)
->withInput();
}
// Retrieve the validated input...
$validated = $validator->validated();
// Retrieve a portion of the validated input...
$validated = $validator->safe()->only(['name', 'email']);
$validated = $validator->safe()->except(['name', 'email']);
// Store the blog post...
}
}

The first argument passed to the make method is the data under validation. The second argument is an array of the
validation rules that should be applied to the data.
After determining whether the request validation failed, you may use the withErrors method to flash the error
messages to the session. When using this method, the $errors variable will automatically be shared with your views
after redirection, allowing you to easily display them back to the user. The withErrors method accepts a validator, a
MessageBag , or a PHP array .
Stopping On First Validation Failure
The stopOnFirstFailure method will inform the validator that it should stop validating all attributes once a single
validation failure has occurred:

Page 244 of 1307

Laravel 9.x

if ($validator->stopOnFirstFailure()->fails()) {
// ...
}

Automatic Redirection

If you would like to create a validator instance manually but still take advantage of the automatic redirection offered by the
HTTP request's validate method, you may call the validate method on an existing validator instance. If validation
fails, the user will automatically be redirected or, in the case of an XHR request, a JSON response will be returned:
Validator::make($request->all(), [
'title' => 'required|unique:posts|max:255',
'body' => 'required',
])->validate();

You may use the validateWithBag method to store the error messages in a named error bag if validation fails:
Validator::make($request->all(), [
'title' => 'required|unique:posts|max:255',
'body' => 'required',
])->validateWithBag('post');

Named Error Bags

If you have multiple forms on a single page, you may wish to name the MessageBag containing the validation errors,
allowing you to retrieve the error messages for a specific form. To achieve this, pass a name as the second argument to
withErrors :
return redirect('register')->withErrors($validator, 'login');

You may then access the named MessageBag instance from the $errors variable:
{{ $errors->login->first('email') }}

Customizing The Error Messages

If needed, you may provide custom error messages that a validator instance should use instead of the default error
messages provided by Laravel. There are several ways to specify custom messages. First, you may pass the custom
messages as the third argument to the Validator::make method:
$validator = Validator::make($input, $rules, $messages = [
'required' => 'The :attribute field is required.',
]);

In this example, the :attribute placeholder will be replaced by the actual name of the field under validation. You may
also utilize other placeholders in validation messages. For example:

Page 245 of 1307

Laravel 9.x

$messages = [
'same' => 'The :attribute and :other must match.',
'size' => 'The :attribute must be exactly :size.',
'between' => 'The :attribute value :input is not between :min - :max.',
'in' => 'The :attribute must be one of the following types: :values',
];

Specifying A Custom Message For A Given Attribute
Sometimes you may wish to specify a custom error message only for a specific attribute. You may do so using "dot"
notation. Specify the attribute's name first, followed by the rule:
$messages = [
'email.required' => 'We need to know your email address!',
];

Specifying Custom Attribute Values
Many of Laravel's built-in error messages include an :attribute placeholder that is replaced with the name of the field
or attribute under validation. To customize the values used to replace these placeholders for specific fields, you may pass
an array of custom attributes as the fourth argument to the Validator::make method:
$validator = Validator::make($input, $rules, $messages, [
'email' => 'email address',
]);

After Validation Hook

You may also attach callbacks to be run after validation is completed. This allows you to easily perform further validation
and even add more error messages to the message collection. To get started, call the after method on a validator
instance:
$validator = Validator::make(/* ... */);
$validator->after(function ($validator) {
if ($this->somethingElseIsInvalid()) {
$validator->errors()->add(
'field', 'Something is wrong with this field!'
);
}
});
if ($validator->fails()) {
//
}

Working With Validated Input

After validating incoming request data using a form request or a manually created validator instance, you may wish to
retrieve the incoming request data that actually underwent validation. This can be accomplished in several ways. First, you
may call the validated method on a form request or validator instance. This method returns an array of the data that
was validated:

Page 246 of 1307

Laravel 9.x

$validated = $request->validated();
$validated = $validator->validated();

Alternatively, you may call the safe method on a form request or validator instance. This method returns an instance of
Illuminate\Support\ValidatedInput . This object exposes only , except , and all methods to retrieve a subset
of the validated data or the entire array of validated data:
$validated = $request->safe()->only(['name', 'email']);
$validated = $request->safe()->except(['name', 'email']);
$validated = $request->safe()->all();

In addition, the Illuminate\Support\ValidatedInput instance may be iterated over and accessed like an array:
// Validated data may be iterated...
foreach ($request->safe() as $key => $value) {
//
}
// Validated data may be accessed as an array...
$validated = $request->safe();
$email = $validated['email'];

If you would like to add additional fields to the validated data, you may call the merge method:
$validated = $request->safe()->merge(['name' => 'Taylor Otwell']);

If you would like to retrieve the validated data as a collection instance, you may call the collect method:
$collection = $request->safe()->collect();

Working With Error Messages

After calling the errors method on a Validator instance, you will receive an Illuminate\Support\MessageBag
instance, which has a variety of convenient methods for working with error messages. The $errors variable that is
automatically made available to all views is also an instance of the MessageBag class.
Retrieving The First Error Message For A Field
To retrieve the first error message for a given field, use the first method:
$errors = $validator->errors();
echo $errors->first('email');

Retrieving All Error Messages For A Field
If you need to retrieve an array of all the messages for a given field, use the get method:

Page 247 of 1307

Laravel 9.x

foreach ($errors->get('email') as $message) {
//
}

If you are validating an array form field, you may retrieve all of the messages for each of the array elements using the *
character:
foreach ($errors->get('attachments.*') as $message) {
//
}

Retrieving All Error Messages For All Fields
To retrieve an array of all messages for all fields, use the all method:
foreach ($errors->all() as $message) {
//
}

Determining If Messages Exist For A Field
The has method may be used to determine if any error messages exist for a given field:
if ($errors->has('email')) {
//
}

Specifying Custom Messages In Language Files

Laravel's built-in validation rules each have an error message that is located in your application's
lang/en/validation.php file. Within this file, you will find a translation entry for each validation rule. You are free to
change or modify these messages based on the needs of your application.
In addition, you may copy this file to another translation language directory to translate the messages for your application's
language. To learn more about Laravel localization, check out the complete localization documentation.
Custom Messages For Specific Attributes
You may customize the error messages used for specified attribute and rule combinations within your application's
validation language files. To do so, add your message customizations to the custom array of your application's
lang/xx/validation.php language file:
'custom' => [
'email' => [
'required' => 'We need to know your email address!',
'max' => 'Your email address is too long!'
],
],

Specifying Attributes In Language Files

Many of Laravel's built-in error messages include an :attribute placeholder that is replaced with the name of the field
or attribute under validation. If you would like the :attribute portion of your validation message to be replaced with a

Page 248 of 1307

Laravel 9.x

custom value, you may specify the custom attribute name in the attributes array of your lang/xx/validation.php
language file:
'attributes' => [
'email' => 'email address',
],

Specifying Values In Language Files

Some of Laravel's built-in validation rule error messages contain a :value placeholder that is replaced with the current
value of the request attribute. However, you may occasionally need the :value portion of your validation message to be
replaced with a custom representation of the value. For example, consider the following rule that specifies that a credit
card number is required if the payment_type has a value of cc :
Validator::make($request->all(), [
'credit_card_number' => 'required_if:payment_type,cc'
]);

If this validation rule fails, it will produce the following error message:
The credit card number field is required when payment type is cc.

Instead of displaying cc as the payment type value, you may specify a more user-friendly value representation in your
lang/xx/validation.php language file by defining a values array:
'values' => [
'payment_type' => [
'cc' => 'credit card'
],
],

After defining this value, the validation rule will produce the following error message:
The credit card number field is required when payment type is credit card.

Available Validation Rules

Below is a list of all available validation rules and their function:
Accepted
Boolean
Accepted If
Confirmed
Active URL
Current Password
After (Date)
Date
After Or Equal (Date)
Date Equals
Alpha
Date Format
Alpha Dash
Decimal
Alpha Numeric
Declined
Array
Declined If
Ascii
Different
Bail
Digits
Before (Date)
Digits Between
Before Or Equal (Date)
Dimensions (Image Files)
Between
Distinct
Page 249 of 1307

Doesnt Start With
Doesnt End With
Email
Ends With
Enum
Exclude
Exclude If
Exclude Unless
Exclude With
Exclude Without
Exists (Database)
File
Filled
Greater Than

Laravel 9.x

Greater Than Or Equal
Missing If
Required Unless
Image (File)
Missing Unless
Required With
In
Missing With
Required With All
In Array
Missing With All
Required Without
Integer
Multiple Of
Required Without All
IP Address
Not In
Required Array Keys
JSON
Not Regex
Same
Less Than
Nullable
Size
Less Than Or Equal
Numeric
Sometimes
Lowercase
Password
Starts With
MAC Address
Present
String
Max
Prohibited
Timezone
Max Digits
Prohibited If
Unique (Database)
MIME Types
Prohibited Unless
Uppercase
MIME Type By File Extension
Prohibits
URL
Min
Regular Expression
ULID
Min Digits
Required
UUID
Missing
Required If
accepted
The field under validation must be "yes" , "on" , 1 , or true . This is useful for validating "Terms of Service"
acceptance or similar fields.
accepted_if:anotherfield,value,...
The field under validation must be "yes" , "on" , 1 , or true if another field under validation is equal to a specified
value. This is useful for validating "Terms of Service" acceptance or similar fields.
active_url
The field under validation must have a valid A or AAAA record according to the dns_get_record PHP function. The
hostname of the provided URL is extracted using the parse_url PHP function before being passed to
dns_get_record .
after:date
The field under validation must be a value after a given date. The dates will be passed into the strtotime PHP function
in order to be converted to a valid DateTime instance:
'start_date' => 'required|date|after:tomorrow'

Instead of passing a date string to be evaluated by strtotime , you may specify another field to compare against the
date:
'finish_date' => 'required|date|after:start_date'

after_or_equal:date
The field under validation must be a value after or equal to the given date. For more information, see the after rule.
alpha
The field under validation must be entirely Unicode alphabetic characters contained in \p{L} and \p{M} .
To restrict this validation rule to characters in the ASCII range ( a-z and A-Z ), you may provide the ascii option to
the validation rule:

Page 250 of 1307

Laravel 9.x

'username' => 'alpha:ascii',

alpha_dash
The field under validation must be entirely Unicode alpha-numeric characters contained in \p{L} , \p{M} , \p{N} , as
well as ASCII dashes ( - ) and ASCII underscores ( _ ).
To restrict this validation rule to characters in the ASCII range ( a-z and A-Z ), you may provide the ascii option to
the validation rule:
'username' => 'alpha_dash:ascii',

alpha_num
The field under validation must be entirely Unicode alpha-numeric characters contained in \p{L} , \p{M} , and \p{N} .
To restrict this validation rule to characters in the ASCII range ( a-z and A-Z ), you may provide the ascii option to
the validation rule:
'username' => 'alpha_num:ascii',

array
The field under validation must be a PHP array .
When additional values are provided to the array rule, each key in the input array must be present within the list of
values provided to the rule. In the following example, the admin key in the input array is invalid since it is not contained in
the list of values provided to the array rule:
use Illuminate\Support\Facades\Validator;
$input = [
'user' => [
'name' => 'Taylor Otwell',
'username' => 'taylorotwell',
'admin' => true,
],
];
Validator::make($input, [
'user' => 'array:name,username',
]);

In general, you should always specify the array keys that are allowed to be present within your array.
ascii
The field under validation must be entirely 7-bit ASCII characters.
bail
Stop running validation rules for the field after the first validation failure.
While the bail rule will only stop validating a specific field when it encounters a validation failure, the
stopOnFirstFailure method will inform the validator that it should stop validating all attributes once a single validation
failure has occurred:

Page 251 of 1307

Laravel 9.x

if ($validator->stopOnFirstFailure()->fails()) {
// ...
}

before:date
The field under validation must be a value preceding the given date. The dates will be passed into the PHP strtotime
function in order to be converted into a valid DateTime instance. In addition, like the after rule, the name of another
field under validation may be supplied as the value of date .
before_or_equal:date
The field under validation must be a value preceding or equal to the given date. The dates will be passed into the PHP
strtotime function in order to be converted into a valid DateTime instance. In addition, like the after rule, the name
of another field under validation may be supplied as the value of date .
between:min,max
The field under validation must have a size between the given min and max (inclusive). Strings, numerics, arrays, and files
are evaluated in the same fashion as the size rule.
boolean
The field under validation must be able to be cast as a boolean. Accepted input are true , false , 1 , 0 , "1" , and
"0" .
confirmed
The field under validation must have a matching field of {field}_confirmation . For example, if the field under
validation is password , a matching password_confirmation field must be present in the input.
current_password
The field under validation must match the authenticated user's password. You may specify an authentication guard using
the rule's first parameter:
'password' => 'current_password:api'

date
The field under validation must be a valid, non-relative date according to the strtotime PHP function.
date_equals:date
The field under validation must be equal to the given date. The dates will be passed into the PHP strtotime function in
order to be converted into a valid DateTime instance.
date_format:format,...
The field under validation must match one of the given formats. You should use either date or date_format when
validating a field, not both. This validation rule supports all formats supported by PHP's DateTime class.
decimal:min,max
The field under validation must be numeric and must contain the specified number of decimal places:

Page 252 of 1307

Laravel 9.x

// Must have exactly two decimal places (9.99)...
'price' => 'decimal:2'
// Must have between 2 and 4 decimal places...
'price' => 'decimal:2,4'

declined
The field under validation must be "no" , "off" , 0 , or false .
declined_if:anotherfield,value,...
The field under validation must be "no" , "off" , 0 , or false if another field under validation is equal to a specified
value.
different:field
The field under validation must have a different value than field.
digits:value
The integer under validation must have an exact length of value.
digits_between:min,max
The integer validation must have a length between the given min and max.
dimensions
The file under validation must be an image meeting the dimension constraints as specified by the rule's parameters:
'avatar' => 'dimensions:min_width=100,min_height=200'

Available constraints are: min_width, max_width, min_height, max_height, width, height, ratio.
A ratio constraint should be represented as width divided by height. This can be specified either by a fraction like 3/2 or
a float like 1.5 :
'avatar' => 'dimensions:ratio=3/2'

Since this rule requires several arguments, you may use the Rule::dimensions method to fluently construct the rule:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
Validator::make($data, [
'avatar' => [
'required',
Rule::dimensions()->maxWidth(1000)->maxHeight(500)->ratio(3 / 2),
],
]);

distinct
When validating arrays, the field under validation must not have any duplicate values:
'foo.*.id' => 'distinct'

Page 253 of 1307

Laravel 9.x

Distinct uses loose variable comparisons by default. To use strict comparisons, you may add the strict parameter to
your validation rule definition:
'foo.*.id' => 'distinct:strict'

You may add ignore_case to the validation rule's arguments to make the rule ignore capitalization differences:
'foo.*.id' => 'distinct:ignore_case'

doesnt_start_with:foo,bar,...
The field under validation must not start with one of the given values.
doesnt_end_with:foo,bar,...
The field under validation must not end with one of the given values.
email
The field under validation must be formatted as an email address. This validation rule utilizes the egulias/emailvalidator package for validating the email address. By default, the RFCValidation validator is applied, but you can
apply other validation styles as well:
'email' => 'email:rfc,dns'

The example above will apply the RFCValidation and DNSCheckValidation validations. Here's a full list of validation
styles you can apply:
rfc : RFCValidation
strict : NoRFCWarningsValidation
dns : DNSCheckValidation
spoof : SpoofCheckValidation
filter : FilterEmailValidation
filter_unicode : FilterEmailValidation::unicode()
The filter validator, which uses PHP's filter_var function, ships with Laravel and was Laravel's default email
validation behavior prior to Laravel version 5.8.
The dns and spoof validators require the PHP intl extension.
ends_with:foo,bar,...
The field under validation must end with one of the given values.
enum
The Enum rule is a class based rule that validates whether the field under validation contains a valid enum value. The
Enum rule accepts the name of the enum as its only constructor argument:

Page 254 of 1307

Laravel 9.x

use App\Enums\ServerStatus;
use Illuminate\Validation\Rules\Enum;
$request->validate([
'status' => [new Enum(ServerStatus::class)],
]);

Enums are only available on PHP 8.1+.
exclude
The field under validation will be excluded from the request data returned by the validate and validated methods.
exclude_if:anotherfield,value
The field under validation will be excluded from the request data returned by the validate and validated methods if
the anotherfield field is equal to value.
If complex conditional exclusion logic is required, you may utilize the Rule::excludeIf method. This method accepts a
boolean or a closure. When given a closure, the closure should return true or false to indicate if the field under
validation should be excluded:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
Validator::make($request->all(), [
'role_id' => Rule::excludeIf($request->user()->is_admin),
]);
Validator::make($request->all(), [
'role_id' => Rule::excludeIf(fn () => $request->user()->is_admin),
]);

exclude_unless:anotherfield,value
The field under validation will be excluded from the request data returned by the validate and validated methods
unless anotherfield's field is equal to value. If value is null ( exclude_unless:name,null ), the field under validation
will be excluded unless the comparison field is null or the comparison field is missing from the request data.
exclude_with:anotherfield
The field under validation will be excluded from the request data returned by the validate and validated methods if
the anotherfield field is present.
exclude_without:anotherfield
The field under validation will be excluded from the request data returned by the validate and validated methods if
the anotherfield field is not present.
exists:table,column
The field under validation must exist in a given database table.
Basic Usage Of Exists Rule
Page 255 of 1307

Laravel 9.x

'state' => 'exists:states'

If the column option is not specified, the field name will be used. So, in this case, the rule will validate that the states
database table contains a record with a state column value matching the request's state attribute value.
Specifying A Custom Column Name
You may explicitly specify the database column name that should be used by the validation rule by placing it after the
database table name:
'state' => 'exists:states,abbreviation'

Occasionally, you may need to specify a specific database connection to be used for the exists query. You can
accomplish this by prepending the connection name to the table name:
'email' => 'exists:connection.staff,email'

Instead of specifying the table name directly, you may specify the Eloquent model which should be used to determine the
table name:
'user_id' => 'exists:App\Models\User,id'

If you would like to customize the query executed by the validation rule, you may use the Rule class to fluently define the
rule. In this example, we'll also specify the validation rules as an array instead of using the | character to delimit them:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
Validator::make($data, [
'email' => [
'required',
Rule::exists('staff')->where(function ($query) {
return $query->where('account_id', 1);
}),
],
]);

You may explicitly specify the database column name that should be used by the exists rule generated by the
Rule::exists method by providing the column name as the second argument to the exists method:
'state' => Rule::exists('states', 'abbreviation'),

file
The field under validation must be a successfully uploaded file.
filled
The field under validation must not be empty when it is present.
gt:field
The field under validation must be greater than the given field. The two fields must be of the same type. Strings, numerics,
arrays, and files are evaluated using the same conventions as the size rule.
Page 256 of 1307

Laravel 9.x

gte:field
The field under validation must be greater than or equal to the given field. The two fields must be of the same type.
Strings, numerics, arrays, and files are evaluated using the same conventions as the size rule.
image
The file under validation must be an image (jpg, jpeg, png, bmp, gif, svg, or webp).
in:foo,bar,...
The field under validation must be included in the given list of values. Since this rule often requires you to implode an
array, the Rule::in method may be used to fluently construct the rule:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
Validator::make($data, [
'zones' => [
'required',
Rule::in(['first-zone', 'second-zone']),
],
]);

When the in rule is combined with the array rule, each value in the input array must be present within the list of
values provided to the in rule. In the following example, the LAS airport code in the input array is invalid since it is not
contained in the list of airports provided to the in rule:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
$input = [
'airports' => ['NYC', 'LAS'],
];
Validator::make($input, [
'airports' => [
'required',
'array',
],
'airports.*' => Rule::in(['NYC', 'LIT']),
]);

in_array:anotherfield.*
The field under validation must exist in anotherfield's values.
integer
The field under validation must be an integer.
This validation rule does not verify that the input is of the "integer" variable type, only that the
input is of a type accepted by PHP's FILTER_VALIDATE_INT rule. If you need to validate the input
as being a number please use this rule in combination with the numeric validation rule.

Page 257 of 1307

Laravel 9.x

ip
The field under validation must be an IP address.
ipv4
The field under validation must be an IPv4 address.
ipv6
The field under validation must be an IPv6 address.
json
The field under validation must be a valid JSON string.
lt:field
The field under validation must be less than the given field. The two fields must be of the same type. Strings, numerics,
arrays, and files are evaluated using the same conventions as the size rule.
lte:field
The field under validation must be less than or equal to the given field. The two fields must be of the same type. Strings,
numerics, arrays, and files are evaluated using the same conventions as the size rule.
lowercase
The field under validation must be lowercase.
mac_address
The field under validation must be a MAC address.
max:value
The field under validation must be less than or equal to a maximum value. Strings, numerics, arrays, and files are evaluated
in the same fashion as the size rule.
max_digits:value
The integer under validation must have a maximum length of value.
mimetypes:text/plain,...
The file under validation must match one of the given MIME types:
'video' => 'mimetypes:video/avi,video/mpeg,video/quicktime'

To determine the MIME type of the uploaded file, the file's contents will be read and the framework will attempt to guess
the MIME type, which may be different from the client's provided MIME type.
mimes:foo,bar,...
The file under validation must have a MIME type corresponding to one of the listed extensions.
Basic Usage Of MIME Rule
'photo' => 'mimes:jpg,bmp,png'

Even though you only need to specify the extensions, this rule actually validates the MIME type of the file by reading the
file's contents and guessing its MIME type. A full listing of MIME types and their corresponding extensions may be found at
the following location:
Page 258 of 1307

Laravel 9.x

https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
min:value
The field under validation must have a minimum value. Strings, numerics, arrays, and files are evaluated in the same
fashion as the size rule.
min_digits:value
The integer under validation must have a minimum length of value.
multiple_of:value
The field under validation must be a multiple of value.
missing
The field under validation must not be present in the input data.
missing_if:anotherfield,value,...
The field under validation must not be present if the anotherfield field is equal to any value.
missing_unless:anotherfield,value
The field under validation must not be present unless the anotherfield field is equal to any value.
missing_with:foo,bar,...
The field under validation must not be present only if any of the other specified fields are present.
missing_with_all:foo,bar,...
The field under validation must not be present only if all of the other specified fields are present.
not_in:foo,bar,...
The field under validation must not be included in the given list of values. The Rule::notIn method may be used to
fluently construct the rule:
use Illuminate\Validation\Rule;
Validator::make($data, [
'toppings' => [
'required',
Rule::notIn(['sprinkles', 'cherries']),
],
]);

not_regex:pattern
The field under validation must not match the given regular expression.
Internally, this rule uses the PHP preg_match function. The pattern specified should obey the same formatting required
by preg_match and thus also include valid delimiters. For example: 'email' => 'not_regex:/^.+$/i' .
When using the regex / not_regex patterns, it may be necessary to specify your validation
rules using an array instead of using | delimiters, especially if the regular expression contains a
| character.

Page 259 of 1307

Laravel 9.x

nullable
The field under validation may be null .
numeric
The field under validation must be numeric.
password
The field under validation must match the authenticated user's password.
This rule was renamed to current_password with the intention of removing it in Laravel 9. Please
use the Current Password rule instead.
present
The field under validation must exist in the input data.
prohibited
The field under validation must be missing or empty. A field is "empty" if it meets one of the following criteria:
The value is null .
The value is an empty string.
The value is an empty array or empty Countable object.
The value is an uploaded file with an empty path.
prohibited_if:anotherfield,value,...
The field under validation must be missing or empty if the anotherfield field is equal to any value. A field is "empty" if it
meets one of the following criteria:
The value is null .
The value is an empty string.
The value is an empty array or empty Countable object.
The value is an uploaded file with an empty path.
If complex conditional prohibition logic is required, you may utilize the Rule::prohibitedIf method. This method
accepts a boolean or a closure. When given a closure, the closure should return true or false to indicate if the field
under validation should be prohibited:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
Validator::make($request->all(), [
'role_id' => Rule::prohibitedIf($request->user()->is_admin),
]);
Validator::make($request->all(), [
'role_id' => Rule::prohibitedIf(fn () => $request->user()->is_admin),
]);

prohibited_unless:anotherfield,value,...
The field under validation must be missing or empty unless the anotherfield field is equal to any value. A field is "empty" if
it meets one of the following criteria:
Page 260 of 1307

Laravel 9.x

The value is null .
The value is an empty string.
The value is an empty array or empty Countable object.
The value is an uploaded file with an empty path.
prohibits:anotherfield,...
If the field under validation is not missing or empty, all fields in anotherfield must be missing or empty. A field is "empty" if
it meets one of the following criteria:
The value is null .
The value is an empty string.
The value is an empty array or empty Countable object.
The value is an uploaded file with an empty path.
regex:pattern
The field under validation must match the given regular expression.
Internally, this rule uses the PHP preg_match function. The pattern specified should obey the same formatting required
by preg_match and thus also include valid delimiters. For example: 'email' => 'regex:/^.+@.+$/i' .
When using the regex / not_regex patterns, it may be necessary to specify rules in an array
instead of using | delimiters, especially if the regular expression contains a | character.
required
The field under validation must be present in the input data and not empty. A field is "empty" if it meets one of the
following criteria:
The value is null .
The value is an empty string.
The value is an empty array or empty Countable object.
The value is an uploaded file with no path.
required_if:anotherfield,value,...
The field under validation must be present and not empty if the anotherfield field is equal to any value.
If you would like to construct a more complex condition for the required_if rule, you may use the Rule::requiredIf
method. This method accepts a boolean or a closure. When passed a closure, the closure should return true or false
to indicate if the field under validation is required:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
Validator::make($request->all(), [
'role_id' => Rule::requiredIf($request->user()->is_admin),
]);
Validator::make($request->all(), [
'role_id' => Rule::requiredIf(fn () => $request->user()->is_admin),
]);

required_unless:anotherfield,value,...

Page 261 of 1307

Laravel 9.x

The field under validation must be present and not empty unless the anotherfield field is equal to any value. This also
means anotherfield must be present in the request data unless value is null . If value is null
( required_unless:name,null ), the field under validation will be required unless the comparison field is null or the
comparison field is missing from the request data.
required_with:foo,bar,...
The field under validation must be present and not empty only if any of the other specified fields are present and not
empty.
required_with_all:foo,bar,...
The field under validation must be present and not empty only if all of the other specified fields are present and not empty.
required_without:foo,bar,...
The field under validation must be present and not empty only when any of the other specified fields are empty or not
present.
required_without_all:foo,bar,...
The field under validation must be present and not empty only when all of the other specified fields are empty or not
present.
required_array_keys:foo,bar,...
The field under validation must be an array and must contain at least the specified keys.
same:field
The given field must match the field under validation.
size:value
The field under validation must have a size matching the given value. For string data, value corresponds to the number of
characters. For numeric data, value corresponds to a given integer value (the attribute must also have the numeric or
integer rule). For an array, size corresponds to the count of the array. For files, size corresponds to the file size in
kilobytes. Let's look at some examples:
// Validate that a string is exactly 12 characters long...
'title' => 'size:12';
// Validate that a provided integer equals 10...
'seats' => 'integer|size:10';
// Validate that an array has exactly 5 elements...
'tags' => 'array|size:5';
// Validate that an uploaded file is exactly 512 kilobytes...
'image' => 'file|size:512';

starts_with:foo,bar,...
The field under validation must start with one of the given values.
string
The field under validation must be a string. If you would like to allow the field to also be null , you should assign the
nullable rule to the field.
timezone
Page 262 of 1307

Laravel 9.x

The field under validation must be a valid timezone identifier according to the timezone_identifiers_list PHP
function.
unique:table,column
The field under validation must not exist within the given database table.
Specifying A Custom Table / Column Name:
Instead of specifying the table name directly, you may specify the Eloquent model which should be used to determine the
table name:
'email' => 'unique:App\Models\User,email_address'

The column option may be used to specify the field's corresponding database column. If the column option is not
specified, the name of the field under validation will be used.
'email' => 'unique:users,email_address'

Specifying A Custom Database Connection
Occasionally, you may need to set a custom connection for database queries made by the Validator. To accomplish this,
you may prepend the connection name to the table name:
'email' => 'unique:connection.users,email_address'

Forcing A Unique Rule To Ignore A Given ID:
Sometimes, you may wish to ignore a given ID during unique validation. For example, consider an "update profile" screen
that includes the user's name, email address, and location. You will probably want to verify that the email address is
unique. However, if the user only changes the name field and not the email field, you do not want a validation error to be
thrown because the user is already the owner of the email address in question.
To instruct the validator to ignore the user's ID, we'll use the Rule class to fluently define the rule. In this example, we'll
also specify the validation rules as an array instead of using the | character to delimit the rules:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
Validator::make($data, [
'email' => [
'required',
Rule::unique('users')->ignore($user->id),
],
]);

You should never pass any user controlled request input into the ignore method. Instead, you
should only pass a system generated unique ID such as an auto-incrementing ID or UUID from an
Eloquent model instance. Otherwise, your application will be vulnerable to an SQL injection attack.
Instead of passing the model key's value to the ignore method, you may also pass the entire model instance. Laravel will
automatically extract the key from the model:
Page 263 of 1307

Laravel 9.x

Rule::unique('users')->ignore($user)

If your table uses a primary key column name other than id , you may specify the name of the column when calling the
ignore method:
Rule::unique('users')->ignore($user->id, 'user_id')

By default, the unique rule will check the uniqueness of the column matching the name of the attribute being validated.
However, you may pass a different column name as the second argument to the unique method:
Rule::unique('users', 'email_address')->ignore($user->id),

Adding Additional Where Clauses:
You may specify additional query conditions by customizing the query using the where method. For example, let's add a
query condition that scopes the query to only search records that have an account_id column value of 1 :
'email' => Rule::unique('users')->where(fn ($query) => $query->where('account_id', 1))

uppercase
The field under validation must be uppercase.
url
The field under validation must be a valid URL.
ulid
The field under validation must be a valid Universally Unique Lexicographically Sortable Identifier (ULID).
uuid
The field under validation must be a valid RFC 4122 (version 1, 3, 4, or 5) universally unique identifier (UUID).

Conditionally Adding Rules

Skipping Validation When Fields Have Certain Values
You may occasionally wish to not validate a given field if another field has a given value. You may accomplish this using the
exclude_if validation rule. In this example, the appointment_date and doctor_name fields will not be validated if
the has_appointment field has a value of false :
use Illuminate\Support\Facades\Validator;
$validator = Validator::make($data, [
'has_appointment' => 'required|boolean',
'appointment_date' => 'exclude_if:has_appointment,false|required|date',
'doctor_name' => 'exclude_if:has_appointment,false|required|string',
]);

Alternatively, you may use the exclude_unless rule to not validate a given field unless another field has a given value:

Page 264 of 1307

Laravel 9.x

$validator = Validator::make($data, [
'has_appointment' => 'required|boolean',
'appointment_date' => 'exclude_unless:has_appointment,true|required|date',
'doctor_name' => 'exclude_unless:has_appointment,true|required|string',
]);

Validating When Present
In some situations, you may wish to run validation checks against a field only if that field is present in the data being
validated. To quickly accomplish this, add the sometimes rule to your rule list:
$v = Validator::make($data, [
'email' => 'sometimes|required|email',
]);

In the example above, the email field will only be validated if it is present in the $data array.
If you are attempting to validate a field that should always be present but may be empty, check out
this note on optional fields.
Complex Conditional Validation
Sometimes you may wish to add validation rules based on more complex conditional logic. For example, you may wish to
require a given field only if another field has a greater value than 100. Or, you may need two fields to have a given value
only when another field is present. Adding these validation rules doesn't have to be a pain. First, create a Validator
instance with your static rules that never change:
use Illuminate\Support\Facades\Validator;
$validator = Validator::make($request->all(), [
'email' => 'required|email',
'games' => 'required|numeric',
]);

Let's assume our web application is for game collectors. If a game collector registers with our application and they own
more than 100 games, we want them to explain why they own so many games. For example, perhaps they run a game
resale shop, or maybe they just enjoy collecting games. To conditionally add this requirement, we can use the sometimes
method on the Validator instance.
$validator->sometimes('reason', 'required|max:500', function ($input) {
return $input->games >= 100;
});

The first argument passed to the sometimes method is the name of the field we are conditionally validating. The second
argument is a list of the rules we want to add. If the closure passed as the third argument returns true , the rules will be
added. This method makes it a breeze to build complex conditional validations. You may even add conditional validations
for several fields at once:

Page 265 of 1307

Laravel 9.x

$validator->sometimes(['reason', 'cost'], 'required', function ($input) {
return $input->games >= 100;
});

The $input parameter passed to your closure will be an instance of
Illuminate\Support\Fluent and may be used to access your input and files under validation.
Complex Conditional Array Validation
Sometimes you may want to validate a field based on another field in the same nested array whose index you do not know.
In these situations, you may allow your closure to receive a second argument which will be the current individual item in the
array being validated:
$input = [
'channels' => [
[
'type' => 'email',
'address' => 'abigail@example.com',
],
[
'type' => 'url',
'address' => 'https://example.com',
],
],
];
$validator->sometimes('channels.*.address', 'email', function ($input, $item) {
return $item->type === 'email';
});
$validator->sometimes('channels.*.address', 'url', function ($input, $item) {
return $item->type !== 'email';
});

Like the $input parameter passed to the closure, the $item parameter is an instance of
Illuminate\Support\Fluent when the attribute data is an array; otherwise, it is a string.

Validating Arrays

As discussed in the array validation rule documentation, the array rule accepts a list of allowed array keys. If any
additional keys are present within the array, validation will fail:

Page 266 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Validator;
$input = [
'user' => [
'name' => 'Taylor Otwell',
'username' => 'taylorotwell',
'admin' => true,
],
];
Validator::make($input, [
'user' => 'array:username,locale',
]);

In general, you should always specify the array keys that are allowed to be present within your array. Otherwise, the
validator's validate and validated methods will return all of the validated data, including the array and all of its keys,
even if those keys were not validated by other nested array validation rules.

Validating Nested Array Input

Validating nested array based form input fields doesn't have to be a pain. You may use "dot notation" to validate attributes
within an array. For example, if the incoming HTTP request contains a photos[profile] field, you may validate it like so:
use Illuminate\Support\Facades\Validator;
$validator = Validator::make($request->all(), [
'photos.profile' => 'required|image',
]);

You may also validate each element of an array. For example, to validate that each email in a given array input field is
unique, you may do the following:
$validator = Validator::make($request->all(), [
'person.*.email' => 'email|unique:users',
'person.*.first_name' => 'required_with:person.*.last_name',
]);

Likewise, you may use the * character when specifying custom validation messages in your language files, making it a
breeze to use a single validation message for array based fields:
'custom' => [
'person.*.email' => [
'unique' => 'Each person must have a unique email address',
]
],

Accessing Nested Array Data
Sometimes you may need to access the value for a given nested array element when assigning validation rules to the
attribute. You may accomplish this using the Rule::forEach method. The forEach method accepts a closure that will
be invoked for each iteration of the array attribute under validation and will receive the attribute's value and explicit, fullyexpanded attribute name. The closure should return an array of rules to assign to the array element:

Page 267 of 1307

Laravel 9.x

use App\Rules\HasPermission;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
$validator = Validator::make($request->all(), [
'companies.*.id' => Rule::forEach(function ($value, $attribute) {
return [
Rule::exists(Company::class, 'id'),
new HasPermission('manage-company', $value),
];
}),
]);

Error Message Indexes & Positions

When validating arrays, you may want to reference the index or position of a particular item that failed validation within the
error message displayed by your application. To accomplish this, you may include the :index (starts from 0 ) and
:position (starts from 1 ) placeholders within your custom validation message:
use Illuminate\Support\Facades\Validator;
$input = [
'photos' => [
[
'name' => 'BeachVacation.jpg',
'description' => 'A photo of my beach vacation!',
],
[
'name' => 'GrandCanyon.jpg',
'description' => '',
],
],
];
Validator::validate($input, [
'photos.*.description' => 'required',
], [
'photos.*.description.required' => 'Please describe photo #:position.',
]);

Given the example above, validation will fail and the user will be presented with the following error of "Please describe
photo #2."

Validating Files

Laravel provides a variety of validation rules that may be used to validate uploaded files, such as mimes , image , min ,
and max . While you are free to specify these rules individually when validating files, Laravel also offers a fluent file
validation rule builder that you may find convenient:

Page 268 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rules\File;
Validator::validate($input, [
'attachment' => [
'required',
File::types(['mp3', 'wav'])
->min(1024)
->max(12 * 1024),
],
]);

If your application accepts images uploaded by your users, you may use the File rule's image constructor method to
indicate that the uploaded file should be an image. In addition, the dimensions rule may be used to limit the dimensions
of the image:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rules\File;
Validator::validate($input, [
'photo' => [
'required',
File::image()
->min(1024)
->max(12 * 1024)
->dimensions(Rule::dimensions()->maxWidth(1000)->maxHeight(500)),
],
]);

More information regarding validating image dimensions may be found in the dimension rule
documentation.
File Types
Even though you only need to specify the extensions when invoking the types method, this method actually validates the
MIME type of the file by reading the file's contents and guessing its MIME type. A full listing of MIME types and their
corresponding extensions may be found at the following location:
https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types

Validating Passwords

To ensure that passwords have an adequate level of complexity, you may use Laravel's Password rule object:
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rules\Password;
$validator = Validator::make($request->all(), [
'password' => ['required', 'confirmed', Password::min(8)],
]);

Page 269 of 1307

Laravel 9.x

The Password rule object allows you to easily customize the password complexity requirements for your application,
such as specifying that passwords require at least one letter, number, symbol, or characters with mixed casing:
// Require at least 8 characters...
Password::min(8)
// Require at least one letter...
Password::min(8)->letters()
// Require at least one uppercase and one lowercase letter...
Password::min(8)->mixedCase()
// Require at least one number...
Password::min(8)->numbers()
// Require at least one symbol...
Password::min(8)->symbols()

In addition, you may ensure that a password has not been compromised in a public password data breach leak using the
uncompromised method:
Password::min(8)->uncompromised()

Internally, the Password rule object uses the k-Anonymity model to determine if a password has been leaked via the
haveibeenpwned.com service without sacrificing the user's privacy or security.
By default, if a password appears at least once in a data leak, it will be considered compromised. You can customize this
threshold using the first argument of the uncompromised method:
// Ensure the password appears less than 3 times in the same data leak...
Password::min(8)->uncompromised(3);

Of course, you may chain all the methods in the examples above:
Password::min(8)
->letters()
->mixedCase()
->numbers()
->symbols()
->uncompromised()

Defining Default Password Rules
You may find it convenient to specify the default validation rules for passwords in a single location of your application. You
can easily accomplish this using the Password::defaults method, which accepts a closure. The closure given to the
defaults method should return the default configuration of the Password rule. Typically, the defaults rule should be
called within the boot method of one of your application's service providers:

Page 270 of 1307

Laravel 9.x

use Illuminate\Validation\Rules\Password;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Password::defaults(function () {
$rule = Password::min(8);
return $this->app->isProduction()
? $rule->mixedCase()->uncompromised()
: $rule;
});
}

Then, when you would like to apply the default rules to a particular password undergoing validation, you may invoke the
defaults method with no arguments:
'password' => ['required', Password::defaults()],

Occasionally, you may want to attach additional validation rules to your default password validation rules. You may use the
rules method to accomplish this:
use App\Rules\ZxcvbnRule;
Password::defaults(function () {
$rule = Password::min(8)->rules([new ZxcvbnRule]);
// ...
});

Custom Validation Rules
Using Rule Objects

Laravel provides a variety of helpful validation rules; however, you may wish to specify some of your own. One method of
registering custom validation rules is using rule objects. To generate a new rule object, you may use the make:rule
Artisan command. Let's use this command to generate a rule that verifies a string is uppercase. Laravel will place the new
rule in the app/Rules directory. If this directory does not exist, Laravel will create it when you execute the Artisan
command to create your rule:
php artisan make:rule Uppercase --invokable

Once the rule has been created, we are ready to define its behavior. A rule object contains a single method: __invoke .
This method receives the attribute name, its value, and a callback that should be invoked on failure with the validation error
message:

Page 271 of 1307

Laravel 9.x

<?php
namespace App\Rules;
use Illuminate\Contracts\Validation\InvokableRule;
class Uppercase implements InvokableRule
{
/**
* Run the validation rule.
*
* @param

string

$attribute

* @param

mixed

$value

* @param

\Closure

$fail

* @return void
*/
public function __invoke($attribute, $value, $fail)
{
if (strtoupper($value) !== $value) {
$fail('The :attribute must be uppercase.');
}
}
}

Once the rule has been defined, you may attach it to a validator by passing an instance of the rule object with your other
validation rules:
use App\Rules\Uppercase;
$request->validate([
'name' => ['required', 'string', new Uppercase],
]);

Translating Validation Messages
Instead of providing a literal error message to the $fail closure, you may also provide a translation string key and
instruct Laravel to translate the error message:
if (strtoupper($value) !== $value) {
$fail('validation.uppercase')->translate();
}

If necessary, you may provide placeholder replacements and the preferred language as the first and second arguments to
the translate method:
$fail('validation.location')->translate([
'value' => $this->value,
], 'fr')

Accessing Additional Data
If your custom validation rule class needs to access all of the other data undergoing validation, your rule class may
implement the Illuminate\Contracts\Validation\DataAwareRule interface. This interface requires your class to

Page 272 of 1307

Laravel 9.x

define a setData method. This method will automatically be invoked by Laravel (before validation proceeds) with all of
the data under validation:
<?php
namespace App\Rules;
use Illuminate\Contracts\Validation\DataAwareRule;
use Illuminate\Contracts\Validation\InvokableRule;
class Uppercase implements DataAwareRule, InvokableRule
{
/**
* All of the data under validation.
*
* @var array
*/
protected $data = [];
// ...
/**
* Set the data under validation.
*
* @param

array

$data

* @return $this
*/
public function setData($data)
{
$this->data = $data;
return $this;
}
}

Or, if your validation rule requires access to the validator instance performing the validation, you may implement the
ValidatorAwareRule interface:

Page 273 of 1307

Laravel 9.x

<?php
namespace App\Rules;
use Illuminate\Contracts\Validation\InvokableRule;
use Illuminate\Contracts\Validation\ValidatorAwareRule;
class Uppercase implements InvokableRule, ValidatorAwareRule
{
/**
* The validator instance.
*
* @var \Illuminate\Validation\Validator
*/
protected $validator;
// ...
/**
* Set the current validator.
*
* @param

\Illuminate\Validation\Validator

$validator

* @return $this
*/
public function setValidator($validator)
{
$this->validator = $validator;
return $this;
}
}

Using Closures

If you only need the functionality of a custom rule once throughout your application, you may use a closure instead of a
rule object. The closure receives the attribute's name, the attribute's value, and a $fail callback that should be called if
validation fails:
use Illuminate\Support\Facades\Validator;
$validator = Validator::make($request->all(), [
'title' => [
'required',
'max:255',
function ($attribute, $value, $fail) {
if ($value === 'foo') {
$fail('The '.$attribute.' is invalid.');
}
},
],
]);

Implicit Rules

Page 274 of 1307

Laravel 9.x

By default, when an attribute being validated is not present or contains an empty string, normal validation rules, including
custom rules, are not run. For example, the unique rule will not be run against an empty string:
use Illuminate\Support\Facades\Validator;
$rules = ['name' => 'unique:users,name'];
$input = ['name' => ''];
Validator::make($input, $rules)->passes(); // true

For a custom rule to run even when an attribute is empty, the rule must imply that the attribute is required. To quickly
generate a new implicit rule object, you may use the make:rule Artisan command with the --implicit option:
php artisan make:rule Uppercase --invokable --implicit

An "implicit" rule only implies that the attribute is required. Whether it actually invalidates a missing
or empty attribute is up to you.

Page 275 of 1307

Laravel 9.x

Error Handling
Introduction
Configuration
The Exception Handler
Reporting Exceptions
Exception Log Levels
Ignoring Exceptions By Type
Rendering Exceptions
Reportable & Renderable Exceptions
HTTP Exceptions
Custom HTTP Error Pages

Introduction

When you start a new Laravel project, error and exception handling is already configured for you. The
App\Exceptions\Handler class is where all exceptions thrown by your application are logged and then rendered to the
user. We'll dive deeper into this class throughout this documentation.

Configuration

The debug option in your config/app.php configuration file determines how much information about an error is
actually displayed to the user. By default, this option is set to respect the value of the APP_DEBUG environment variable,
which is stored in your .env file.
During local development, you should set the APP_DEBUG environment variable to true . In your production
environment, this value should always be false . If the value is set to true in production, you risk exposing
sensitive configuration values to your application's end users.

The Exception Handler
Reporting Exceptions

All exceptions are handled by the App\Exceptions\Handler class. This class contains a register method where you
may register custom exception reporting and rendering callbacks. We'll examine each of these concepts in detail.
Exception reporting is used to log exceptions or send them to an external service like Flare, Bugsnag or Sentry. By default,
exceptions will be logged based on your logging configuration. However, you are free to log exceptions however you wish.
For example, if you need to report different types of exceptions in different ways, you may use the reportable method
to register a closure that should be executed when an exception of a given type needs to be reported. Laravel will deduce
what type of exception the closure reports by examining the type-hint of the closure:

Page 276 of 1307

Laravel 9.x

use App\Exceptions\InvalidOrderException;
/**
* Register the exception handling callbacks for the application.
*
* @return void
*/
public function register()
{
$this->reportable(function (InvalidOrderException $e) {
//
});
}

When you register a custom exception reporting callback using the reportable method, Laravel will still log the
exception using the default logging configuration for the application. If you wish to stop the propagation of the exception
to the default logging stack, you may use the stop method when defining your reporting callback or return false from
the callback:
$this->reportable(function (InvalidOrderException $e) {
//
})->stop();
$this->reportable(function (InvalidOrderException $e) {
return false;
});

To customize the exception reporting for a given exception, you may also utilize reportable
exceptions.
Global Log Context
If available, Laravel automatically adds the current user's ID to every exception's log message as contextual data. You may
define your own global contextual data by overriding the context method of your application's
App\Exceptions\Handler class. This information will be included in every exception's log message written by your
application:
/**
* Get the default context variables for logging.
*
* @return array
*/
protected function context()
{
return array_merge(parent::context(), [
'foo' => 'bar',
]);
}

Exception Log Context
Page 277 of 1307

Laravel 9.x

While adding context to every log message can be useful, sometimes a particular exception may have unique context that
you would like to include in your logs. By defining a context method on one of your application's custom exceptions, you
may specify any data relevant to that exception that should be added to the exception's log entry:
<?php
namespace App\Exceptions;
use Exception;
class InvalidOrderException extends Exception
{
// ...
/**
* Get the exception's context information.
*
* @return array
*/
public function context()
{
return ['order_id' => $this->orderId];
}
}

The report Helper
Sometimes you may need to report an exception but continue handling the current request. The report helper function
allows you to quickly report an exception via the exception handler without rendering an error page to the user:
public function isValid($value)
{
try {
// Validate the value...
} catch (Throwable $e) {
report($e);
return false;
}
}

Exception Log Levels

When messages are written to your application's logs, the messages are written at a specified log level, which indicates
the severity or importance of the message being logged.
As noted above, even when you register a custom exception reporting callback using the reportable method, Laravel
will still log the exception using the default logging configuration for the application; however, since the log level can
sometimes influence the channels on which a message is logged, you may wish to configure the log level that certain
exceptions are logged at.
To accomplish this, you may define an array of exception types and their associated log levels within the $levels
property of your application's exception handler:

Page 278 of 1307

Laravel 9.x

use PDOException;
use Psr\Log\LogLevel;
/**
* A list of exception types with their corresponding custom log levels.
*
* @var array<class-string<\Throwable>, \Psr\Log\LogLevel::*>
*/
protected $levels = [
PDOException::class => LogLevel::CRITICAL,
];

Ignoring Exceptions By Type

When building your application, there will be some types of exceptions you simply want to ignore and never report. Your
application's exception handler contains a $dontReport property which is initialized to an empty array. Any classes that
you add to this property will never be reported; however, they may still have custom rendering logic:
use App\Exceptions\InvalidOrderException;
/**
* A list of the exception types that are not reported.
*
* @var array<int, class-string<\Throwable>>
*/
protected $dontReport = [
InvalidOrderException::class,
];

Behind the scenes, Laravel already ignores some types of errors for you, such as exceptions
resulting from 404 HTTP "not found" errors or 419 HTTP responses generated by invalid CSRF
tokens.

Rendering Exceptions

By default, the Laravel exception handler will convert exceptions into an HTTP response for you. However, you are free to
register a custom rendering closure for exceptions of a given type. You may accomplish this via the renderable method
of your exception handler.
The closure passed to the renderable method should return an instance of Illuminate\Http\Response , which may
be generated via the response helper. Laravel will deduce what type of exception the closure renders by examining the
type-hint of the closure:

Page 279 of 1307

Laravel 9.x

use App\Exceptions\InvalidOrderException;
/**
* Register the exception handling callbacks for the application.
*
* @return void
*/
public function register()
{
$this->renderable(function (InvalidOrderException $e, $request) {
return response()->view('errors.invalid-order', [], 500);
});
}

You may also use the renderable method to override the rendering behavior for built-in Laravel or Symfony exceptions
such as NotFoundHttpException . If the closure given to the renderable method does not return a value, Laravel's
default exception rendering will be utilized:
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
/**
* Register the exception handling callbacks for the application.
*
* @return void
*/
public function register()
{
$this->renderable(function (NotFoundHttpException $e, $request) {
if ($request->is('api/*')) {
return response()->json([
'message' => 'Record not found.'
], 404);
}
});
}

Reportable & Renderable Exceptions

Instead of type-checking exceptions in the exception handler's register method, you may define report and
render methods directly on your custom exceptions. When these methods exist, they will be automatically called by the
framework:

Page 280 of 1307

Laravel 9.x

<?php
namespace App\Exceptions;
use Exception;
class InvalidOrderException extends Exception
{
/**
* Report the exception.
*
* @return bool|null
*/
public function report()
{
//
}
/**
* Render the exception into an HTTP response.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function render($request)
{
return response(/* ... */);
}
}

If your exception extends an exception that is already renderable, such as a built-in Laravel or Symfony exception, you may
return false from the exception's render method to render the exception's default HTTP response:
/**
* Render the exception into an HTTP response.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function render($request)
{
// Determine if the exception needs custom rendering...
return false;
}

If your exception contains custom reporting logic that is only necessary when certain conditions are met, you may need to
instruct Laravel to sometimes report the exception using the default exception handling configuration. To accomplish this,
you may return false from the exception's report method:

Page 281 of 1307

Laravel 9.x

/**
* Report the exception.
*
* @return bool|null
*/
public function report()
{
// Determine if the exception needs custom reporting...
return false;
}

You may type-hint any required dependencies of the report method and they will automatically
be injected into the method by Laravel's service container.

HTTP Exceptions

Some exceptions describe HTTP error codes from the server. For example, this may be a "page not found" error (404), an
"unauthorized error" (401) or even a developer generated 500 error. In order to generate such a response from anywhere
in your application, you may use the abort helper:
abort(404);

Custom HTTP Error Pages

Laravel makes it easy to display custom error pages for various HTTP status codes. For example, if you wish to customize
the error page for 404 HTTP status codes, create a resources/views/errors/404.blade.php view template. This
view will be rendered on all 404 errors generated by your application. The views within this directory should be named to
match the HTTP status code they correspond to. The Symfony\Component\HttpKernel\Exception\HttpException
instance raised by the abort function will be passed to the view as an $exception variable:
<h2>{{ $exception->getMessage() }}</h2>

You may publish Laravel's default error page templates using the vendor:publish Artisan command. Once the
templates have been published, you may customize them to your liking:
php artisan vendor:publish --tag=laravel-errors

Fallback HTTP Error Pages
You may also define a "fallback" error page for a given series of HTTP status codes. This page will be rendered if there is
not a corresponding page for the specific HTTP status code that occurred. To accomplish this, define a 4xx.blade.php
template and a 5xx.blade.php template in your application's resources/views/errors directory.

Page 282 of 1307

Laravel 9.x

Logging

Introduction
Configuration
Available Channel Drivers
Channel Prerequisites
Logging Deprecation Warnings
Building Log Stacks
Writing Log Messages
Contextual Information
Writing To Specific Channels
Monolog Channel Customization
Customizing Monolog For Channels
Creating Monolog Handler Channels
Creating Custom Channels Via Factories

Introduction

To help you learn more about what's happening within your application, Laravel provides robust logging services that allow
you to log messages to files, the system error log, and even to Slack to notify your entire team.
Laravel logging is based on "channels". Each channel represents a specific way of writing log information. For example, the
single channel writes log files to a single log file, while the slack channel sends log messages to Slack. Log
messages may be written to multiple channels based on their severity.
Under the hood, Laravel utilizes the Monolog library, which provides support for a variety of powerful log handlers. Laravel
makes it a cinch to configure these handlers, allowing you to mix and match them to customize your application's log
handling.

Configuration

All of the configuration options for your application's logging behavior is housed in the config/logging.php
configuration file. This file allows you to configure your application's log channels, so be sure to review each of the
available channels and their options. We'll review a few common options below.
By default, Laravel will use the stack channel when logging messages. The stack channel is used to aggregate
multiple log channels into a single channel. For more information on building stacks, check out the documentation below.
Configuring The Channel Name
By default, Monolog is instantiated with a "channel name" that matches the current environment, such as production or
local . To change this value, add a name option to your channel's configuration:
'stack' => [
'driver' => 'stack',
'name' => 'channel-name',
'channels' => ['single', 'slack'],
],

Available Channel Drivers

Each log channel is powered by a "driver". The driver determines how and where the log message is actually recorded. The
following log channel drivers are available in every Laravel application. An entry for most of these drivers is already present

Page 283 of 1307

Laravel 9.x

in your application's config/logging.php configuration file, so be sure to review this file to become familiar with its
contents:
Name

Description
A driver that calls a specified factory to create a channel
A RotatingFileHandler based Monolog driver which rotates daily
An ErrorLogHandler based Monolog driver
A Monolog factory driver that may use any supported Monolog handler
A driver that discards all log messages
A SyslogUdpHandler based Monolog driver
A single file or path based logger channel (StreamHandler)
A SlackWebhookHandler based Monolog driver
A wrapper to facilitate creating "multi-channel" channels
A SyslogHandler based Monolog driver

custom
daily
errorlog
monolog
null
papertrail
single
slack
stack
syslog

Check out the documentation on advanced channel customization to learn more about the
monolog and custom drivers.

Channel Prerequisites

Configuring The Single and Daily Channels
The single and daily channels have three optional configuration options: bubble , permission , and locking .
Name
bubble
locking
permission

Description
Indicates if messages should bubble up to other channels after being handled
Attempt to lock the log file before writing to it
The log file's permissions

Default
true
false
0644

Additionally, the retention policy for the daily channel can be configured via the days option:
Name
days

Description
The number of days that daily log files should be retained

Default
7

Configuring The Papertrail Channel
The papertrail channel requires the host and port configuration options. You can obtain these values from
Papertrail.
Configuring The Slack Channel

Page 284 of 1307

Laravel 9.x

The slack channel requires a url configuration option. This URL should match a URL for an incoming webhook that
you have configured for your Slack team.
By default, Slack will only receive logs at the critical level and above; however, you can adjust this in your
config/logging.php configuration file by modifying the level configuration option within your Slack log channel's
configuration array.

Logging Deprecation Warnings

PHP, Laravel, and other libraries often notify their users that some of their features have been deprecated and will be
removed in a future version. If you would like to log these deprecation warnings, you may specify your preferred
deprecations log channel in your application's config/logging.php configuration file:
'deprecations' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),
'channels' => [
...
]

Or, you may define a log channel named deprecations . If a log channel with this name exists, it will always be used to
log deprecations:
'channels' => [
'deprecations' => [
'driver' => 'single',
'path' => storage_path('logs/php-deprecation-warnings.log'),
],
],

Building Log Stacks

As mentioned previously, the stack driver allows you to combine multiple channels into a single log channel for
convenience. To illustrate how to use log stacks, let's take a look at an example configuration that you might see in a
production application:
'channels' => [
'stack' => [
'driver' => 'stack',
'channels' => ['syslog', 'slack'],
],
'syslog' => [
'driver' => 'syslog',
'level' => 'debug',
],
'slack' => [
'driver' => 'slack',
'url' => env('LOG_SLACK_WEBHOOK_URL'),
'username' => 'Laravel Log',
'emoji' => ':boom:',
'level' => 'critical',
],
],

Page 285 of 1307

Laravel 9.x

Let's dissect this configuration. First, notice our stack channel aggregates two other channels via its channels option:
syslog and slack . So, when logging messages, both of these channels will have the opportunity to log the message.
However, as we will see below, whether these channels actually log the message may be determined by the message's
severity / "level".
Log Levels
Take note of the level configuration option present on the syslog and slack channel configurations in the example
above. This option determines the minimum "level" a message must be in order to be logged by the channel. Monolog,
which powers Laravel's logging services, offers all of the log levels defined in the RFC 5424 specification. In descending
order of severity, these log levels are: emergency, alert, critical, error, warning, notice, info, and debug.
So, imagine we log a message using the debug method:
Log::debug('An informational message.');

Given our configuration, the syslog channel will write the message to the system log; however, since the error message
is not critical or above, it will not be sent to Slack. However, if we log an emergency message, it will be sent to both
the system log and Slack since the emergency level is above our minimum level threshold for both channels:
Log::emergency('The system is down!');

Writing Log Messages

You may write information to the logs using the Log facade. As previously mentioned, the logger provides the eight
logging levels defined in the RFC 5424 specification: emergency, alert, critical, error, warning, notice, info and debug:
use Illuminate\Support\Facades\Log;
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

You may call any of these methods to log a message for the corresponding level. By default, the message will be written to
the default log channel as configured by your logging configuration file:

Page 286 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Support\Facades\Log;
class UserController extends Controller
{
/**
* Show the profile for the given user.
*
* @param

int

$id

* @return \Illuminate\Http\Response
*/
public function show($id)
{
Log::info('Showing the user profile for user: '.$id);
return view('user.profile', [
'user' => User::findOrFail($id)
]);
}
}

Contextual Information

An array of contextual data may be passed to the log methods. This contextual data will be formatted and displayed with
the log message:
use Illuminate\Support\Facades\Log;
Log::info('User failed to login.', ['id' => $user->id]);

Occasionally, you may wish to specify some contextual information that should be included with all subsequent log entries
in a particular channel. For example, you may wish to log a request ID that is associated with each incoming request to your
application. To accomplish this, you may call the Log facade's withContext method:

Page 287 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
class AssignRequestId
{
/**
* Handle an incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

$request

$next

* @return mixed
*/
public function handle($request, Closure $next)
{
$requestId = (string) Str::uuid();
Log::withContext([
'request-id' => $requestId
]);
return $next($request)->header('Request-Id', $requestId);
}
}

If you would like to share contextual information across all logging channels, you may call the Log::shareContext()
method. This method will provide the contextual information to all created channels and any channels that are created
subsequently. Typically, the shareContext method should be called from the boot method of an application service
provider:
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
class AppServiceProvider
{
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Log::shareContext([
'invocation-id' => (string) Str::uuid(),
]);
}
}

Writing To Specific Channels
Page 288 of 1307

Laravel 9.x

Sometimes you may wish to log a message to a channel other than your application's default channel. You may use the
channel method on the Log facade to retrieve and log to any channel defined in your configuration file:
use Illuminate\Support\Facades\Log;
Log::channel('slack')->info('Something happened!');

If you would like to create an on-demand logging stack consisting of multiple channels, you may use the stack method:
Log::stack(['single', 'slack'])->info('Something happened!');

On-Demand Channels
It is also possible to create an on-demand channel by providing the configuration at runtime without that configuration
being present in your application's logging configuration file. To accomplish this, you may pass a configuration array to
the Log facade's build method:
use Illuminate\Support\Facades\Log;
Log::build([
'driver' => 'single',
'path' => storage_path('logs/custom.log'),
])->info('Something happened!');

You may also wish to include an on-demand channel in an on-demand logging stack. This can be achieved by including
your on-demand channel instance in the array passed to the stack method:
use Illuminate\Support\Facades\Log;
$channel = Log::build([
'driver' => 'single',
'path' => storage_path('logs/custom.log'),
]);
Log::stack(['slack', $channel])->info('Something happened!');

Monolog Channel Customization
Customizing Monolog For Channels

Sometimes you may need complete control over how Monolog is configured for an existing channel. For example, you may
want to configure a custom Monolog FormatterInterface implementation for Laravel's built-in single channel.
To get started, define a tap array on the channel's configuration. The tap array should contain a list of classes that
should have an opportunity to customize (or "tap" into) the Monolog instance after it is created. There is no conventional
location where these classes should be placed, so you are free to create a directory within your application to contain
these classes:

Page 289 of 1307

Laravel 9.x

'single' => [
'driver' => 'single',
'tap' => [App\Logging\CustomizeFormatter::class],
'path' => storage_path('logs/laravel.log'),
'level' => 'debug',
],

Once you have configured the tap option on your channel, you're ready to define the class that will customize your
Monolog instance. This class only needs a single method: __invoke , which receives an Illuminate\Log\Logger
instance. The Illuminate\Log\Logger instance proxies all method calls to the underlying Monolog instance:
<?php
namespace App\Logging;
use Monolog\Formatter\LineFormatter;
class CustomizeFormatter
{
/**
* Customize the given logger instance.
*
* @param

\Illuminate\Log\Logger

$logger

* @return void
*/
public function __invoke($logger)
{
foreach ($logger->getHandlers() as $handler) {
$handler->setFormatter(new LineFormatter(
'[%datetime%] %channel%.%level_name%: %message% %context% %extra%'
));
}
}
}

All of your "tap" classes are resolved by the service container, so any constructor dependencies
they require will automatically be injected.

Creating Monolog Handler Channels

Monolog has a variety of available handlers and Laravel does not include a built-in channel for each one. In some cases,
you may wish to create a custom channel that is merely an instance of a specific Monolog handler that does not have a
corresponding Laravel log driver. These channels can be easily created using the monolog driver.
When using the monolog driver, the handler configuration option is used to specify which handler will be instantiated.
Optionally, any constructor parameters the handler needs may be specified using the with configuration option:

Page 290 of 1307

Laravel 9.x

'logentries' => [
'driver'

=> 'monolog',

'handler' => Monolog\Handler\SyslogUdpHandler::class,
'with' => [
'host' => 'my.logentries.internal.datahubhost.company.com',
'port' => '10000',
],
],

Monolog Formatters
When using the monolog driver, the Monolog LineFormatter will be used as the default formatter. However, you may
customize the type of formatter passed to the handler using the formatter and formatter_with configuration
options:
'browser' => [
'driver' => 'monolog',
'handler' => Monolog\Handler\BrowserConsoleHandler::class,
'formatter' => Monolog\Formatter\HtmlFormatter::class,
'formatter_with' => [
'dateFormat' => 'Y-m-d',
],
],

If you are using a Monolog handler that is capable of providing its own formatter, you may set the value of the formatter
configuration option to default :
'newrelic' => [
'driver' => 'monolog',
'handler' => Monolog\Handler\NewRelicHandler::class,
'formatter' => 'default',
],

Creating Custom Channels Via Factories

If you would like to define an entirely custom channel in which you have full control over Monolog's instantiation and
configuration, you may specify a custom driver type in your config/logging.php configuration file. Your configuration
should include a via option that contains the name of the factory class which will be invoked to create the Monolog
instance:
'channels' => [
'example-custom-channel' => [
'driver' => 'custom',
'via' => App\Logging\CreateCustomLogger::class,
],
],

Once you have configured the custom driver channel, you're ready to define the class that will create your Monolog
instance. This class only needs a single __invoke method which should return the Monolog logger instance. The method
will receive the channels configuration array as its only argument:

Page 291 of 1307

Laravel 9.x

<?php
namespace App\Logging;
use Monolog\Logger;
class CreateCustomLogger
{
/**
* Create a custom Monolog instance.
*
* @param

array

$config

* @return \Monolog\Logger
*/
public function __invoke(array $config)
{
return new Logger(/* ... */);
}
}

Page 292 of 1307

Laravel 9.x

Chapter 5

Digging Deeper

Page 293 of 1307

Laravel 9.x

Artisan Console

Introduction
Tinker (REPL)
Writing Commands
Generating Commands
Command Structure
Closure Commands
Isolatable Commands
Defining Input Expectations
Arguments
Options
Input Arrays
Input Descriptions
Command I/O
Retrieving Input
Prompting For Input
Writing Output
Registering Commands
Programmatically Executing Commands
Calling Commands From Other Commands
Signal Handling
Stub Customization
Events

Introduction

Artisan is the command line interface included with Laravel. Artisan exists at the root of your application as the artisan
script and provides a number of helpful commands that can assist you while you build your application. To view a list of all
available Artisan commands, you may use the list command:
php artisan list

Every command also includes a "help" screen which displays and describes the command's available arguments and
options. To view a help screen, precede the name of the command with help :
php artisan help migrate

Laravel Sail
If you are using Laravel Sail as your local development environment, remember to use the sail command line to invoke
Artisan commands. Sail will execute your Artisan commands within your application's Docker containers:
./vendor/bin/sail artisan list

Tinker (REPL)

Laravel Tinker is a powerful REPL for the Laravel framework, powered by the PsySH package.
Installation

Page 294 of 1307

Laravel 9.x

All Laravel applications include Tinker by default. However, you may install Tinker using Composer if you have previously
removed it from your application:
composer require laravel/tinker

Looking for a graphical UI for interacting with your Laravel application? Check out Tinkerwell!
Usage
Tinker allows you to interact with your entire Laravel application on the command line, including your Eloquent models,
jobs, events, and more. To enter the Tinker environment, run the tinker Artisan command:
php artisan tinker

You can publish Tinker's configuration file using the vendor:publish command:
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"

The dispatch helper function and dispatch method on the Dispatchable class depends on
garbage collection to place the job on the queue. Therefore, when using tinker, you should use
Bus::dispatch or Queue::push to dispatch jobs.
Command Allow List
Tinker utilizes an "allow" list to determine which Artisan commands are allowed to be run within its shell. By default, you
may run the clear-compiled , down , env , inspire , migrate , optimize , and up commands. If you would like
to allow more commands you may add them to the commands array in your tinker.php configuration file:
'commands' => [
// App\Console\Commands\ExampleCommand::class,
],

Classes That Should Not Be Aliased
Typically, Tinker automatically aliases classes as you interact with them in Tinker. However, you may wish to never alias
some classes. You may accomplish this by listing the classes in the dont_alias array of your tinker.php
configuration file:
'dont_alias' => [
App\Models\User::class,
],

Writing Commands

In addition to the commands provided with Artisan, you may build your own custom commands. Commands are typically
stored in the app/Console/Commands directory; however, you are free to choose your own storage location as long as
your commands can be loaded by Composer.
Page 295 of 1307

Laravel 9.x

Generating Commands

To create a new command, you may use the make:command Artisan command. This command will create a new command
class in the app/Console/Commands directory. Don't worry if this directory does not exist in your application - it will be
created the first time you run the make:command Artisan command:
php artisan make:command SendEmails

Command Structure

After generating your command, you should define appropriate values for the signature and description properties
of the class. These properties will be used when displaying your command on the list screen. The signature
property also allows you to define your command's input expectations. The handle method will be called when your
command is executed. You may place your command logic in this method.
Let's take a look at an example command. Note that we are able to request any dependencies we need via the command's
handle method. The Laravel service container will automatically inject all dependencies that are type-hinted in this
method's signature:
<?php
namespace App\Console\Commands;
use App\Models\User;
use App\Support\DripEmailer;
use Illuminate\Console\Command;
class SendEmails extends Command
{
/**
* The name and signature of the console command.
*
* @var string
*/
protected $signature = 'mail:send {user}';
/**
* The console command description.
*
* @var string
*/
protected $description = 'Send a marketing email to a user';
/**
* Execute the console command.
*
* @param

\App\Support\DripEmailer

$drip

* @return mixed
*/
public function handle(DripEmailer $drip)
{
$drip->send(User::find($this->argument('user')));
}
}

Page 296 of 1307

Laravel 9.x

For greater code reuse, it is good practice to keep your console commands light and let them defer
to application services to accomplish their tasks. In the example above, note that we inject a
service class to do the "heavy lifting" of sending the e-mails.

Closure Commands

Closure based commands provide an alternative to defining console commands as classes. In the same way that route
closures are an alternative to controllers, think of command closures as an alternative to command classes. Within the
commands method of your app/Console/Kernel.php file, Laravel loads the routes/console.php file:
/**
* Register the closure based commands for the application.
*
* @return void
*/
protected function commands()
{
require base_path('routes/console.php');
}

Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application.
Within this file, you may define all of your closure based console commands using the Artisan::command method. The
command method accepts two arguments: the command signature and a closure which receives the command's
arguments and options:
Artisan::command('mail:send {user}', function ($user) {
$this->info("Sending email to: {$user}!");
});

The closure is bound to the underlying command instance, so you have full access to all of the helper methods you would
typically be able to access on a full command class.
Type-Hinting Dependencies
In addition to receiving your command's arguments and options, command closures may also type-hint additional
dependencies that you would like resolved out of the service container:
use App\Models\User;
use App\Support\DripEmailer;
Artisan::command('mail:send {user}', function (DripEmailer $drip, $user) {
$drip->send(User::find($user));
});

Closure Command Descriptions
When defining a closure based command, you may use the purpose method to add a description to the command. This
description will be displayed when you run the php artisan list or php artisan help commands:

Page 297 of 1307

Laravel 9.x

Artisan::command('mail:send {user}', function ($user) {
// ...
})->purpose('Send a marketing email to a user');

Isolatable Commands
To utilize this feature, your application must be using the memcached , redis , dynamodb ,
database , file , or array cache driver as your application's default cache driver. In addition,
all servers must be communicating with the same central cache server.
Sometimes you may wish to ensure that only one instance of a command can run at a time. To accomplish this, you may
implement the Illuminate\Contracts\Console\Isolatable interface on your command class:
<?php
namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Contracts\Console\Isolatable;
class SendEmails extends Command implements Isolatable
{
// ...
}

When a command is marked as Isolatable , Laravel will automatically add an --isolated option to the command.
When the command is invoked with that option, Laravel will ensure that no other instances of that command are already
running. Laravel accomplishes this by attempting to acquire an atomic lock using your application's default cache driver. If
other instances of the command are running, the command will not execute; however, the command will still exit with a
successful exit status code:
php artisan mail:send 1 --isolated

If you would like to specify the exit status code that the command should return if it is not able to execute, you may provide
the desired status code via the isolated option:
php artisan mail:send 1 --isolated=12

Lock Expiration Time
By default, isolation locks expire after the command is finished. Or, if the command is interrupted and unable to finish, the
lock will expire after one hour. However, you may adjust the lock expiration time by defining a isolationLockExpiresAt
method on your command:

Page 298 of 1307

Laravel 9.x

/**
* Determine when an isolation lock expires for the command.
*
* @return \DateTimeInterface|\DateInterval
*/
public function isolationLockExpiresAt()
{
return now()->addMinutes(5);
}

Defining Input Expectations

When writing console commands, it is common to gather input from the user through arguments or options. Laravel makes
it very convenient to define the input you expect from the user using the signature property on your commands. The
signature property allows you to define the name, arguments, and options for the command in a single, expressive,
route-like syntax.

Arguments

All user supplied arguments and options are wrapped in curly braces. In the following example, the command defines one
required argument: user :
/**
* The name and signature of the console command.
*
* @var string
*/
protected $signature = 'mail:send {user}';

You may also make arguments optional or define default values for arguments:
// Optional argument...
'mail:send {user?}'
// Optional argument with default value...
'mail:send {user=foo}'

Options

Options, like arguments, are another form of user input. Options are prefixed by two hyphens ( -- ) when they are
provided via the command line. There are two types of options: those that receive a value and those that don't. Options
that don't receive a value serve as a boolean "switch". Let's take a look at an example of this type of option:
/**
* The name and signature of the console command.
*
* @var string
*/
protected $signature = 'mail:send {user} {--queue}';

In this example, the --queue switch may be specified when calling the Artisan command. If the --queue switch is
passed, the value of the option will be true . Otherwise, the value will be false :

Page 299 of 1307

Laravel 9.x

php artisan mail:send 1 --queue

Options With Values
Next, let's take a look at an option that expects a value. If the user must specify a value for an option, you should suffix the
option name with a = sign:
/**
* The name and signature of the console command.
*
* @var string
*/
protected $signature = 'mail:send {user} {--queue=}';

In this example, the user may pass a value for the option like so. If the option is not specified when invoking the command,
its value will be null :
php artisan mail:send 1 --queue=default

You may assign default values to options by specifying the default value after the option name. If no option value is passed
by the user, the default value will be used:
'mail:send {user} {--queue=default}'

Option Shortcuts
To assign a shortcut when defining an option, you may specify it before the option name and use the | character as a
delimiter to separate the shortcut from the full option name:
'mail:send {user} {--Q|queue}'

When invoking the command on your terminal, option shortcuts should be prefixed with a single hyphen:
php artisan mail:send 1 -Q

Input Arrays

If you would like to define arguments or options to expect multiple input values, you may use the * character. First, let's
take a look at an example that specifies such an argument:
'mail:send {user*}'

When calling this method, the user arguments may be passed in order to the command line. For example, the following
command will set the value of user to an array with 1 and 2 as its values:
php artisan mail:send 1 2

This * character can be combined with an optional argument definition to allow zero or more instances of an argument:
'mail:send {user?*}'

Page 300 of 1307

Laravel 9.x

Option Arrays
When defining an option that expects multiple input values, each option value passed to the command should be prefixed
with the option name:
'mail:send {--id=*}'

Such a command may be invoked by passing multiple --id arguments:
php artisan mail:send --id=1 --id=2

Input Descriptions

You may assign descriptions to input arguments and options by separating the argument name from the description using
a colon. If you need a little extra room to define your command, feel free to spread the definition across multiple lines:
/**
* The name and signature of the console command.
*
* @var string
*/
protected $signature = 'mail:send
{user : The ID of the user}
{--queue : Whether the job should be queued}';

Command I/O
Retrieving Input

While your command is executing, you will likely need to access the values for the arguments and options accepted by
your command. To do so, you may use the argument and option methods. If an argument or option does not exist,
null will be returned:
/**
* Execute the console command.
*
* @return int
*/
public function handle()
{
$userId = $this->argument('user');
//
}

If you need to retrieve all of the arguments as an array , call the arguments method:
$arguments = $this->arguments();

Options may be retrieved just as easily as arguments using the option method. To retrieve all of the options as an array,
call the options method:

Page 301 of 1307

Laravel 9.x

// Retrieve a specific option...
$queueName = $this->option('queue');
// Retrieve all options as an array...
$options = $this->options();

Prompting For Input

In addition to displaying output, you may also ask the user to provide input during the execution of your command. The
ask method will prompt the user with the given question, accept their input, and then return the user's input back to your
command:
/**
* Execute the console command.
*
* @return mixed
*/
public function handle()
{
$name = $this->ask('What is your name?');
}

The secret method is similar to ask , but the user's input will not be visible to them as they type in the console. This
method is useful when asking for sensitive information such as passwords:
$password = $this->secret('What is the password?');

Asking For Confirmation
If you need to ask the user for a simple "yes or no" confirmation, you may use the confirm method. By default, this
method will return false . However, if the user enters y or yes in response to the prompt, the method will return
true .
if ($this->confirm('Do you wish to continue?')) {
//
}

If necessary, you may specify that the confirmation prompt should return true by default by passing true as the
second argument to the confirm method:
if ($this->confirm('Do you wish to continue?', true)) {
//
}

Auto-Completion
The anticipate method can be used to provide auto-completion for possible choices. The user can still provide any
answer, regardless of the auto-completion hints:
$name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);

Alternatively, you may pass a closure as the second argument to the anticipate method. The closure will be called each
time the user types an input character. The closure should accept a string parameter containing the user's input so far, and
Page 302 of 1307

Laravel 9.x

return an array of options for auto-completion:
$name = $this->anticipate('What is your address?', function ($input) {
// Return auto-completion options...
});

Multiple Choice Questions
If you need to give the user a predefined set of choices when asking a question, you may use the choice method. You
may set the array index of the default value to be returned if no option is chosen by passing the index as the third
argument to the method:
$name = $this->choice(
'What is your name?',
['Taylor', 'Dayle'],
$defaultIndex
);

In addition, the choice method accepts optional fourth and fifth arguments for determining the maximum number of
attempts to select a valid response and whether multiple selections are permitted:
$name = $this->choice(
'What is your name?',
['Taylor', 'Dayle'],
$defaultIndex,
$maxAttempts = null,
$allowMultipleSelections = false
);

Writing Output

To send output to the console, you may use the line , info , comment , question , warn , and error methods.
Each of these methods will use appropriate ANSI colors for their purpose. For example, let's display some general
information to the user. Typically, the info method will display in the console as green colored text:
/**
* Execute the console command.
*
* @return mixed
*/
public function handle()
{
// ...
$this->info('The command was successful!');
}

To display an error message, use the error method. Error message text is typically displayed in red:
$this->error('Something went wrong!');

You may use the line method to display plain, uncolored text:

Page 303 of 1307

Laravel 9.x

$this->line('Display this on the screen');

You may use the newLine method to display a blank line:
// Write a single blank line...
$this->newLine();
// Write three blank lines...
$this->newLine(3);

Tables
The table method makes it easy to correctly format multiple rows / columns of data. All you need to do is provide the
column names and the data for the table and Laravel will automatically calculate the appropriate width and height of the
table for you:
use App\Models\User;
$this->table(
['Name', 'Email'],
User::all(['name', 'email'])->toArray()
);

Progress Bars
For long running tasks, it can be helpful to show a progress bar that informs users how complete the task is. Using the
withProgressBar method, Laravel will display a progress bar and advance its progress for each iteration over a given
iterable value:
use App\Models\User;
$users = $this->withProgressBar(User::all(), function ($user) {
$this->performTask($user);
});

Sometimes, you may need more manual control over how a progress bar is advanced. First, define the total number of
steps the process will iterate through. Then, advance the progress bar after processing each item:
$users = App\Models\User::all();
$bar = $this->output->createProgressBar(count($users));
$bar->start();
foreach ($users as $user) {
$this->performTask($user);
$bar->advance();
}
$bar->finish();

Page 304 of 1307

Laravel 9.x

For more advanced options, check out the Symfony Progress Bar component documentation.

Registering Commands

All of your console commands are registered within your application's App\Console\Kernel class, which is your
application's "console kernel". Within the commands method of this class, you will see a call to the kernel's load
method. The load method will scan the app/Console/Commands directory and automatically register each command it
contains with Artisan. You are even free to make additional calls to the load method to scan other directories for Artisan
commands:
/**
* Register the commands for the application.
*
* @return void
*/
protected function commands()
{
$this->load(__DIR__.'/Commands');
$this->load(__DIR__.'/../Domain/Orders/Commands');
// ...
}

If necessary, you may manually register commands by adding the command's class name to a $commands property within
your App\Console\Kernel class. If this property is not already defined on your kernel, you should define it manually.
When Artisan boots, all the commands listed in this property will be resolved by the service container and registered with
Artisan:
protected $commands = [
Commands\SendEmails::class
];

Programmatically Executing Commands

Sometimes you may wish to execute an Artisan command outside of the CLI. For example, you may wish to execute an
Artisan command from a route or controller. You may use the call method on the Artisan facade to accomplish this.
The call method accepts either the command's signature name or class name as its first argument, and an array of
command parameters as the second argument. The exit code will be returned:
use Illuminate\Support\Facades\Artisan;
Route::post('/user/{user}/mail', function ($user) {
$exitCode = Artisan::call('mail:send', [
'user' => $user, '--queue' => 'default'
]);
//
});

Alternatively, you may pass the entire Artisan command to the call method as a string:
Page 305 of 1307

Laravel 9.x

Artisan::call('mail:send 1 --queue=default');

Passing Array Values
If your command defines an option that accepts an array, you may pass an array of values to that option:
use Illuminate\Support\Facades\Artisan;
Route::post('/mail', function () {
$exitCode = Artisan::call('mail:send', [
'--id' => [5, 13]
]);
});

Passing Boolean Values
If you need to specify the value of an option that does not accept string values, such as the --force flag on the
migrate:refresh command, you should pass true or false as the value of the option:
$exitCode = Artisan::call('migrate:refresh', [
'--force' => true,
]);

Queueing Artisan Commands
Using the queue method on the Artisan facade, you may even queue Artisan commands so they are processed in the
background by your queue workers. Before using this method, make sure you have configured your queue and are running
a queue listener:
use Illuminate\Support\Facades\Artisan;
Route::post('/user/{user}/mail', function ($user) {
Artisan::queue('mail:send', [
'user' => $user, '--queue' => 'default'
]);
//
});

Using the onConnection and onQueue methods, you may specify the connection or queue the Artisan command
should be dispatched to:
Artisan::queue('mail:send', [
'user' => 1, '--queue' => 'default'
])->onConnection('redis')->onQueue('commands');

Calling Commands From Other Commands

Sometimes you may wish to call other commands from an existing Artisan command. You may do so using the call
method. This call method accepts the command name and an array of command arguments / options:

Page 306 of 1307

Laravel 9.x

/**
* Execute the console command.
*
* @return mixed
*/
public function handle()
{
$this->call('mail:send', [
'user' => 1, '--queue' => 'default'
]);
//
}

If you would like to call another console command and suppress all of its output, you may use the callSilently
method. The callSilently method has the same signature as the call method:
$this->callSilently('mail:send', [
'user' => 1, '--queue' => 'default'
]);

Signal Handling

As you may know, operating systems allow signals to be sent to running processes. For example, the SIGTERM signal is
how operating systems ask a program to terminate. If you wish to listen for signals in your Artisan console commands and
execute code when they occur, you may use the trap method:
/**
* Execute the console command.
*
* @return mixed
*/
public function handle()
{
$this->trap(SIGTERM, fn () => $this->shouldKeepRunning = false);
while ($this->shouldKeepRunning) {
// ...
}
}

To listen for multiple signals at once, you may provide an array of signals to the trap method:
$this->trap([SIGTERM, SIGQUIT], function ($signal) {
$this->shouldKeepRunning = false;
dump($signal); // SIGTERM / SIGQUIT
});

Stub Customization

The Artisan console's make commands are used to create a variety of classes, such as controllers, jobs, migrations, and
tests. These classes are generated using "stub" files that are populated with values based on your input. However, you
Page 307 of 1307

Laravel 9.x

may want to make small changes to files generated by Artisan. To accomplish this, you may use the stub:publish
command to publish the most common stubs to your application so that you can customize them:
php artisan stub:publish

The published stubs will be located within a stubs directory in the root of your application. Any changes you make to
these stubs will be reflected when you generate their corresponding classes using Artisan's make commands.

Events

Artisan dispatches three events when running commands: Illuminate\Console\Events\ArtisanStarting ,
Illuminate\Console\Events\CommandStarting , and Illuminate\Console\Events\CommandFinished . The
ArtisanStarting event is dispatched immediately when Artisan starts running. Next, the CommandStarting event is
dispatched immediately before a command runs. Finally, the CommandFinished event is dispatched once a command
finishes executing.

Page 308 of 1307

Laravel 9.x

Broadcasting
Introduction
Server Side Installation
Configuration
Pusher Channels
Ably
Open Source Alternatives
Client Side Installation
Pusher Channels
Ably
Concept Overview
Using An Example Application
Defining Broadcast Events
Broadcast Name
Broadcast Data
Broadcast Queue
Broadcast Conditions
Broadcasting & Database Transactions
Authorizing Channels
Defining Authorization Routes
Defining Authorization Callbacks
Defining Channel Classes
Broadcasting Events
Only To Others
Customizing The Connection
Receiving Broadcasts
Listening For Events
Leaving A Channel
Namespaces
Presence Channels
Authorizing Presence Channels
Joining Presence Channels
Broadcasting To Presence Channels
Model Broadcasting
Model Broadcasting Conventions
Listening For Model Broadcasts
Client Events
Notifications

Introduction

In many modern web applications, WebSockets are used to implement realtime, live-updating user interfaces. When some
data is updated on the server, a message is typically sent over a WebSocket connection to be handled by the client.
WebSockets provide a more efficient alternative to continually polling your application's server for data changes that
should be reflected in your UI.
For example, imagine your application is able to export a user's data to a CSV file and email it to them. However, creating
this CSV file takes several minutes so you choose to create and mail the CSV within a queued job. When the CSV has been
created and mailed to the user, we can use event broadcasting to dispatch a App\Events\UserDataExported event that

Page 309 of 1307

Laravel 9.x

is received by our application's JavaScript. Once the event is received, we can display a message to the user that their CSV
has been emailed to them without them ever needing to refresh the page.
To assist you in building these types of features, Laravel makes it easy to "broadcast" your server-side Laravel events over
a WebSocket connection. Broadcasting your Laravel events allows you to share the same event names and data between
your server-side Laravel application and your client-side JavaScript application.
The core concepts behind broadcasting are simple: clients connect to named channels on the frontend, while your Laravel
application broadcasts events to these channels on the backend. These events can contain any additional data you wish to
make available to the frontend.
Supported Drivers
By default, Laravel includes two server-side broadcasting drivers for you to choose from: Pusher Channels and Ably.
However, community driven packages such as laravel-websockets and soketi provide additional broadcasting drivers that
do not require commercial broadcasting providers.
Before diving into event broadcasting, make sure you have read Laravel's documentation on events
and listeners.

Server Side Installation

To get started using Laravel's event broadcasting, we need to do some configuration within the Laravel application as well
as install a few packages.
Event broadcasting is accomplished by a server-side broadcasting driver that broadcasts your Laravel events so that
Laravel Echo (a JavaScript library) can receive them within the browser client. Don't worry - we'll walk through each part of
the installation process step-by-step.

Configuration

All of your application's event broadcasting configuration is stored in the config/broadcasting.php configuration file.
Laravel supports several broadcast drivers out of the box: Pusher Channels, Redis, and a log driver for local
development and debugging. Additionally, a null driver is included which allows you to totally disable broadcasting
during testing. A configuration example is included for each of these drivers in the config/broadcasting.php
configuration file.
Broadcast Service Provider
Before broadcasting any events, you will first need to register the App\Providers\BroadcastServiceProvider . In new
Laravel applications, you only need to uncomment this provider in the providers array of your config/app.php
configuration file. This BroadcastServiceProvider contains the code necessary to register the broadcast authorization
routes and callbacks.
Queue Configuration
You will also need to configure and run a queue worker. All event broadcasting is done via queued jobs so that the
response time of your application is not seriously affected by events being broadcast.

Pusher Channels

If you plan to broadcast your events using Pusher Channels, you should install the Pusher Channels PHP SDK using the
Composer package manager:
composer require pusher/pusher-php-server

Page 310 of 1307

Laravel 9.x

Next, you should configure your Pusher Channels credentials in the config/broadcasting.php configuration file. An
example Pusher Channels configuration is already included in this file, allowing you to quickly specify your key, secret, and
application ID. Typically, these values should be set via the PUSHER_APP_KEY , PUSHER_APP_SECRET , and
PUSHER_APP_ID environment variables:
PUSHER_APP_ID=your-pusher-app-id
PUSHER_APP_KEY=your-pusher-key
PUSHER_APP_SECRET=your-pusher-secret
PUSHER_APP_CLUSTER=mt1

The config/broadcasting.php file's pusher configuration also allows you to specify additional options that are
supported by Channels, such as the cluster.
Next, you will need to change your broadcast driver to pusher in your .env file:
BROADCAST_DRIVER=pusher

Finally, you are ready to install and configure Laravel Echo, which will receive the broadcast events on the client-side.
Open Source Pusher Alternatives
The laravel-websockets and soketi packages provide Pusher compatible WebSocket servers for Laravel. These packages
allow you to leverage the full power of Laravel broadcasting without a commercial WebSocket provider. For more
information on installing and using these packages, please consult our documentation on open source alternatives.

Ably

If you plan to broadcast your events using Ably, you should install the Ably PHP SDK using the Composer package
manager:
composer require ably/ably-php

Next, you should configure your Ably credentials in the config/broadcasting.php configuration file. An example Ably
configuration is already included in this file, allowing you to quickly specify your key. Typically, this value should be set via
the ABLY_KEY environment variable:
ABLY_KEY=your-ably-key

Next, you will need to change your broadcast driver to ably in your .env file:
BROADCAST_DRIVER=ably

Finally, you are ready to install and configure Laravel Echo, which will receive the broadcast events on the client-side.

Open Source Alternatives

PHP
The laravel-websockets package is a pure PHP, Pusher compatible WebSocket package for Laravel. This package allows
you to leverage the full power of Laravel broadcasting without a commercial WebSocket provider. For more information on
installing and using this package, please consult its official documentation.
Node
Soketi is a Node based, Pusher compatible WebSocket server for Laravel. Under the hood, Soketi utilizes ÂµWebSockets.js
for extreme scalability and speed. This package allows you to leverage the full power of Laravel broadcasting without a
Page 311 of 1307

Laravel 9.x

commercial WebSocket provider. For more information on installing and using this package, please consult its official
documentation.

Client Side Installation
Pusher Channels

Laravel Echo is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by your
server-side broadcasting driver. You may install Echo via the NPM package manager. In this example, we will also install the
pusher-js package since we will be using the Pusher Channels broadcaster:
npm install --save-dev laravel-echo pusher-js

Once Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do
this is at the bottom of the resources/js/bootstrap.js file that is included with the Laravel framework. By default, an
example Echo configuration is already included in this file - you simply need to uncomment it:
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
broadcaster: 'pusher',
key: import.meta.env.VITE_PUSHER_APP_KEY,
cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,
forceTLS: true
});

Once you have uncommented and adjusted the Echo configuration according to your needs, you may compile your
application's assets:
npm run dev

To learn more about compiling your application's JavaScript assets, please consult the
documentation on Vite.
Using An Existing Client Instance
If you already have a pre-configured Pusher Channels client instance that you would like Echo to utilize, you may pass it to
Echo via the client configuration option:

Page 312 of 1307

Laravel 9.x

import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
const options = {
broadcaster: 'pusher',
key: 'your-pusher-channels-key'
}
window.Echo = new Echo({
...options,
client: new Pusher(options.key, options)
});

Ably

Laravel Echo is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by your
server-side broadcasting driver. You may install Echo via the NPM package manager. In this example, we will also install the
pusher-js package.
You may wonder why we would install the pusher-js JavaScript library even though we are using Ably to broadcast our
events. Thankfully, Ably includes a Pusher compatibility mode which lets us use the Pusher protocol when listening for
events in our client-side application:
npm install --save-dev laravel-echo pusher-js

Before continuing, you should enable Pusher protocol support in your Ably application settings. You may enable
this feature within the "Protocol Adapter Settings" portion of your Ably application's settings dashboard.
Once Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do
this is at the bottom of the resources/js/bootstrap.js file that is included with the Laravel framework. By default, an
example Echo configuration is already included in this file; however, the default configuration in the bootstrap.js file is
intended for Pusher. You may copy the configuration below to transition your configuration to Ably:
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
broadcaster: 'pusher',
key: import.meta.env.VITE_ABLY_PUBLIC_KEY,
wsHost: 'realtime-pusher.ably.io',
wsPort: 443,
disableStats: true,
encrypted: true,
});

Note that our Ably Echo configuration references a VITE_ABLY_PUBLIC_KEY environment variable. This variable's value
should be your Ably public key. Your public key is the portion of your Ably key that occurs before the : character.
Once you have uncommented and adjusted the Echo configuration according to your needs, you may compile your
application's assets:
npm run dev

Page 313 of 1307

Laravel 9.x

To learn more about compiling your application's JavaScript assets, please consult the
documentation on Vite.

Concept Overview

Laravel's event broadcasting allows you to broadcast your server-side Laravel events to your client-side JavaScript
application using a driver-based approach to WebSockets. Currently, Laravel ships with Pusher Channels and Ably drivers.
The events may be easily consumed on the client-side using the Laravel Echo JavaScript package.
Events are broadcast over "channels", which may be specified as public or private. Any visitor to your application may
subscribe to a public channel without any authentication or authorization; however, in order to subscribe to a private
channel, a user must be authenticated and authorized to listen on that channel.
If you would like to explore open source alternatives to Pusher, check out the open source
alternatives.

Using An Example Application

Before diving into each component of event broadcasting, let's take a high level overview using an e-commerce store as an
example.
In our application, let's assume we have a page that allows users to view the shipping status for their orders. Let's also
assume that a OrderShipmentStatusUpdated event is fired when a shipping status update is processed by the
application:
use App\Events\OrderShipmentStatusUpdated;
OrderShipmentStatusUpdated::dispatch($order);

The ShouldBroadcast Interface
When a user is viewing one of their orders, we don't want them to have to refresh the page to view status updates. Instead,
we want to broadcast the updates to the application as they are created. So, we need to mark the
OrderShipmentStatusUpdated event with the ShouldBroadcast interface. This will instruct Laravel to broadcast the
event when it is fired:

Page 314 of 1307

Laravel 9.x

<?php
namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class OrderShipmentStatusUpdated implements ShouldBroadcast
{
/**
* The order instance.
*
* @var \App\Order
*/
public $order;
}

The ShouldBroadcast interface requires our event to define a broadcastOn method. This method is responsible for
returning the channels that the event should broadcast on. An empty stub of this method is already defined on generated
event classes, so we only need to fill in its details. We only want the creator of the order to be able to view status updates,
so we will broadcast the event on a private channel that is tied to the order:
/**
* Get the channels the event should broadcast on.
*
* @return \Illuminate\Broadcasting\PrivateChannel
*/
public function broadcastOn()
{
return new PrivateChannel('orders.'.$this->order->id);
}

Authorizing Channels
Remember, users must be authorized to listen on private channels. We may define our channel authorization rules in our
application's routes/channels.php file. In this example, we need to verify that any user attempting to listen on the
private orders.1 channel is actually the creator of the order:
use App\Models\Order;
Broadcast::channel('orders.{orderId}', function ($user, $orderId) {
return $user->id === Order::findOrNew($orderId)->user_id;
});

The channel method accepts two arguments: the name of the channel and a callback which returns true or false
indicating whether the user is authorized to listen on the channel.
All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard
parameters as their subsequent arguments. In this example, we are using the {orderId} placeholder to indicate that the
"ID" portion of the channel name is a wildcard.
Page 315 of 1307

Laravel 9.x

Listening For Event Broadcasts
Next, all that remains is to listen for the event in our JavaScript application. We can do this using Laravel Echo. First, we'll
use the private method to subscribe to the private channel. Then, we may use the listen method to listen for the
OrderShipmentStatusUpdated event. By default, all of the event's public properties will be included on the broadcast
event:
Echo.private(`orders.${orderId}`)
.listen('OrderShipmentStatusUpdated', (e) => {
console.log(e.order);
});

Defining Broadcast Events

To inform Laravel that a given event should be broadcast, you must implement the
Illuminate\Contracts\Broadcasting\ShouldBroadcast interface on the event class. This interface is already
imported into all event classes generated by the framework so you may easily add it to any of your events.
The ShouldBroadcast interface requires you to implement a single method: broadcastOn . The broadcastOn
method should return a channel or array of channels that the event should broadcast on. The channels should be instances
of Channel , PrivateChannel , or PresenceChannel . Instances of Channel represent public channels that any user
may subscribe to, while PrivateChannels and PresenceChannels represent private channels that require channel
authorization:

Page 316 of 1307

Laravel 9.x

<?php
namespace App\Events;
use App\Models\User;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class ServerCreated implements ShouldBroadcast
{
use SerializesModels;
/**
* The user that created the server.
*
* @var \App\Models\User
*/
public $user;
/**
* Create a new event instance.
*
* @param

\App\Models\User

$user

* @return void
*/
public function __construct(User $user)
{
$this->user = $user;
}
/**
* Get the channels the event should broadcast on.
*
* @return Channel|array
*/
public function broadcastOn()
{
return new PrivateChannel('user.'.$this->user->id);
}
}

After implementing the ShouldBroadcast interface, you only need to fire the event as you normally would. Once the
event has been fired, a queued job will automatically broadcast the event using your specified broadcast driver.

Broadcast Name

By default, Laravel will broadcast the event using the event's class name. However, you may customize the broadcast name
by defining a broadcastAs method on the event:

Page 317 of 1307

Laravel 9.x

/**
* The event's broadcast name.
*
* @return string
*/
public function broadcastAs()
{
return 'server.created';
}

If you customize the broadcast name using the broadcastAs method, you should make sure to register your listener with
a leading . character. This will instruct Echo to not prepend the application's namespace to the event:
.listen('.server.created', function (e) {
....
});

Broadcast Data

When an event is broadcast, all of its public properties are automatically serialized and broadcast as the event's
payload, allowing you to access any of its public data from your JavaScript application. So, for example, if your event has a
single public $user property that contains an Eloquent model, the event's broadcast payload would be:
{
"user": {
"id": 1,
"name": "Patrick Stewart"
...
}
}

However, if you wish to have more fine-grained control over your broadcast payload, you may add a broadcastWith
method to your event. This method should return the array of data that you wish to broadcast as the event payload:
/**
* Get the data to broadcast.
*
* @return array
*/
public function broadcastWith()
{
return ['id' => $this->user->id];
}

Broadcast Queue

By default, each broadcast event is placed on the default queue for the default queue connection specified in your
queue.php configuration file. You may customize the queue connection and name used by the broadcaster by defining
connection and queue properties on your event class:

Page 318 of 1307

Laravel 9.x

/**
* The name of the queue connection to use when broadcasting the event.
*
* @var string
*/
public $connection = 'redis';
/**
* The name of the queue on which to place the broadcasting job.
*
* @var string
*/
public $queue = 'default';

Alternatively, you may customize the queue name by defining a broadcastQueue method on your event:
/**
* The name of the queue on which to place the broadcasting job.
*
* @return string
*/
public function broadcastQueue()
{
return 'default';
}

If you would like to broadcast your event using the sync queue instead of the default queue driver, you can implement
the ShouldBroadcastNow interface instead of ShouldBroadcast :
<?php
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;
class OrderShipmentStatusUpdated implements ShouldBroadcastNow
{
//
}

Broadcast Conditions

Sometimes you want to broadcast your event only if a given condition is true. You may define these conditions by adding a
broadcastWhen method to your event class:
/**
* Determine if this event should broadcast.
*
* @return bool
*/
public function broadcastWhen()
{
return $this->order->value > 100;
}

Page 319 of 1307

Laravel 9.x

Broadcasting & Database Transactions
When broadcast events are dispatched within database transactions, they may be processed by the queue before the
database transaction has committed. When this happens, any updates you have made to models or database records
during the database transaction may not yet be reflected in the database. In addition, any models or database records
created within the transaction may not exist in the database. If your event depends on these models, unexpected errors
can occur when the job that broadcasts the event is processed.
If your queue connection's after_commit configuration option is set to false , you may still indicate that a particular
broadcast event should be dispatched after all open database transactions have been committed by defining an
$afterCommit property on the event class:
<?php
namespace App\Events;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class ServerCreated implements ShouldBroadcast
{
use SerializesModels;
public $afterCommit = true;
}

To learn more about working around these issues, please review the documentation regarding
queued jobs and database transactions.

Authorizing Channels

Private channels require you to authorize that the currently authenticated user can actually listen on the channel. This is
accomplished by making an HTTP request to your Laravel application with the channel name and allowing your application
to determine if the user can listen on that channel. When using Laravel Echo, the HTTP request to authorize subscriptions
to private channels will be made automatically; however, you do need to define the proper routes to respond to these
requests.

Defining Authorization Routes

Thankfully, Laravel makes it easy to define the routes to respond to channel authorization requests. In the
App\Providers\BroadcastServiceProvider included with your Laravel application, you will see a call to the
Broadcast::routes method. This method will register the /broadcasting/auth route to handle authorization
requests:
Broadcast::routes();

The Broadcast::routes method will automatically place its routes within the web middleware group; however, you
may pass an array of route attributes to the method if you would like to customize the assigned attributes:
Broadcast::routes($attributes);

Page 320 of 1307

Laravel 9.x

Customizing The Authorization Endpoint
By default, Echo will use the /broadcasting/auth endpoint to authorize channel access. However, you may specify your
own authorization endpoint by passing the authEndpoint configuration option to your Echo instance:
window.Echo = new Echo({
broadcaster: 'pusher',
// ...
authEndpoint: '/custom/endpoint/auth'
});

Customizing The Authorization Request
You can customize how Laravel Echo performs authorization requests by providing a custom authorizer when initializing
Echo:
window.Echo = new Echo({
// ...
authorizer: (channel, options) => {
return {
authorize: (socketId, callback) => {
axios.post('/api/broadcasting/auth', {
socket_id: socketId,
channel_name: channel.name
})
.then(response => {
callback(null, response.data);
})
.catch(error => {
callback(error);
});
}
};
},
})

Defining Authorization Callbacks

Next, we need to define the logic that will actually determine if the currently authenticated user can listen to a given
channel. This is done in the routes/channels.php file that is included with your application. In this file, you may use the
Broadcast::channel method to register channel authorization callbacks:
Broadcast::channel('orders.{orderId}', function ($user, $orderId) {
return $user->id === Order::findOrNew($orderId)->user_id;
});

The channel method accepts two arguments: the name of the channel and a callback which returns true or false
indicating whether the user is authorized to listen on the channel.
All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard
parameters as their subsequent arguments. In this example, we are using the {orderId} placeholder to indicate that the
"ID" portion of the channel name is a wildcard.
Authorization Callback Model Binding

Page 321 of 1307

Laravel 9.x

Just like HTTP routes, channel routes may also take advantage of implicit and explicit route model binding. For example,
instead of receiving a string or numeric order ID, you may request an actual Order model instance:
use App\Models\Order;
Broadcast::channel('orders.{order}', function ($user, Order $order) {
return $user->id === $order->user_id;
});

Unlike HTTP route model binding, channel model binding does not support automatic implicit
model binding scoping. However, this is rarely a problem because most channels can be scoped
based on a single model's unique, primary key.
Authorization Callback Authentication
Private and presence broadcast channels authenticate the current user via your application's default authentication guard.
If the user is not authenticated, channel authorization is automatically denied and the authorization callback is never
executed. However, you may assign multiple, custom guards that should authenticate the incoming request if necessary:
Broadcast::channel('channel', function () {
// ...
}, ['guards' => ['web', 'admin']]);

Defining Channel Classes

If your application is consuming many different channels, your routes/channels.php file could become bulky. So,
instead of using closures to authorize channels, you may use channel classes. To generate a channel class, use the
make:channel Artisan command. This command will place a new channel class in the App/Broadcasting directory.
php artisan make:channel OrderChannel

Next, register your channel in your routes/channels.php file:
use App\Broadcasting\OrderChannel;
Broadcast::channel('orders.{order}', OrderChannel::class);

Finally, you may place the authorization logic for your channel in the channel class' join method. This join method
will house the same logic you would have typically placed in your channel authorization closure. You may also take
advantage of channel model binding:

Page 322 of 1307

Laravel 9.x

<?php
namespace App\Broadcasting;
use App\Models\Order;
use App\Models\User;
class OrderChannel
{
/**
* Create a new channel instance.
*
* @return void
*/
public function __construct()
{
//
}
/**
* Authenticate the user's access to the channel.
*
* @param

\App\Models\User

$user

* @param

\App\Models\Order

$order

* @return array|bool
*/
public function join(User $user, Order $order)
{
return $user->id === $order->user_id;
}
}

Like many other classes in Laravel, channel classes will automatically be resolved by the service
container. So, you may type-hint any dependencies required by your channel in its constructor.

Broadcasting Events

Once you have defined an event and marked it with the ShouldBroadcast interface, you only need to fire the event using
the event's dispatch method. The event dispatcher will notice that the event is marked with the ShouldBroadcast
interface and will queue the event for broadcasting:
use App\Events\OrderShipmentStatusUpdated;
OrderShipmentStatusUpdated::dispatch($order);

Only To Others

When building an application that utilizes event broadcasting, you may occasionally need to broadcast an event to all
subscribers to a given channel except for the current user. You may accomplish this using the broadcast helper and the
toOthers method:

Page 323 of 1307

Laravel 9.x

use App\Events\OrderShipmentStatusUpdated;
broadcast(new OrderShipmentStatusUpdated($update))->toOthers();

To better understand when you may want to use the toOthers method, let's imagine a task list application where a user
may create a new task by entering a task name. To create a task, your application might make a request to a /task URL
which broadcasts the task's creation and returns a JSON representation of the new task. When your JavaScript application
receives the response from the end-point, it might directly insert the new task into its task list like so:
axios.post('/task', task)
.then((response) => {
this.tasks.push(response.data);
});

However, remember that we also broadcast the task's creation. If your JavaScript application is also listening for this event
in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the
broadcast. You may solve this by using the toOthers method to instruct the broadcaster to not broadcast the event to
the current user.
Your event must use the Illuminate\Broadcasting\InteractsWithSockets trait in order to
call the toOthers method.
Configuration
When you initialize a Laravel Echo instance, a socket ID is assigned to the connection. If you are using a global Axios
instance to make HTTP requests from your JavaScript application, the socket ID will automatically be attached to every
outgoing request as a X-Socket-ID header. Then, when you call the toOthers method, Laravel will extract the socket
ID from the header and instruct the broadcaster to not broadcast to any connections with that socket ID.
If you are not using a global Axios instance, you will need to manually configure your JavaScript application to send the XSocket-ID header with all outgoing requests. You may retrieve the socket ID using the Echo.socketId method:
var socketId = Echo.socketId();

Customizing The Connection

If your application interacts with multiple broadcast connections and you want to broadcast an event using a broadcaster
other than your default, you may specify which connection to push an event to using the via method:
use App\Events\OrderShipmentStatusUpdated;
broadcast(new OrderShipmentStatusUpdated($update))->via('pusher');

Alternatively, you may specify the event's broadcast connection by calling the broadcastVia method within the event's
constructor. However, before doing so, you should ensure that the event class uses the InteractsWithBroadcasting
trait:

Page 324 of 1307

Laravel 9.x

<?php
namespace App\Events;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithBroadcasting;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class OrderShipmentStatusUpdated implements ShouldBroadcast
{
use InteractsWithBroadcasting;
/**
* Create a new event instance.
*
* @return void
*/
public function __construct()
{
$this->broadcastVia('pusher');
}
}

Receiving Broadcasts
Listening For Events

Once you have installed and instantiated Laravel Echo, you are ready to start listening for events that are broadcast from
your Laravel application. First, use the channel method to retrieve an instance of a channel, then call the listen
method to listen for a specified event:
Echo.channel(`orders.${this.order.id}`)
.listen('OrderShipmentStatusUpdated', (e) => {
console.log(e.order.name);
});

If you would like to listen for events on a private channel, use the private method instead. You may continue to chain
calls to the listen method to listen for multiple events on a single channel:
Echo.private(`orders.${this.order.id}`)
.listen(/* ... */)
.listen(/* ... */)
.listen(/* ... */);

Stop Listening For Events
If you would like to stop listening to a given event without leaving the channel, you may use the stopListening method:

Page 325 of 1307

Laravel 9.x

Echo.private(`orders.${this.order.id}`)
.stopListening('OrderShipmentStatusUpdated')

Leaving A Channel

To leave a channel, you may call the leaveChannel method on your Echo instance:
Echo.leaveChannel(`orders.${this.order.id}`);

If you would like to leave a channel and also its associated private and presence channels, you may call the leave
method:
Echo.leave(`orders.${this.order.id}`);

Namespaces

You may have noticed in the examples above that we did not specify the full App\Events namespace for the event
classes. This is because Echo will automatically assume the events are located in the App\Events namespace. However,
you may configure the root namespace when you instantiate Echo by passing a namespace configuration option:
window.Echo = new Echo({
broadcaster: 'pusher',
// ...
namespace: 'App.Other.Namespace'
});

Alternatively, you may prefix event classes with a . when subscribing to them using Echo. This will allow you to always
specify the fully-qualified class name:
Echo.channel('orders')
.listen('.Namespace\\Event\\Class', (e) => {
//
});

Presence Channels

Presence channels build on the security of private channels while exposing the additional feature of awareness of who is
subscribed to the channel. This makes it easy to build powerful, collaborative application features such as notifying users
when another user is viewing the same page or listing the inhabitants of a chat room.

Authorizing Presence Channels

All presence channels are also private channels; therefore, users must be authorized to access them. However, when
defining authorization callbacks for presence channels, you will not return true if the user is authorized to join the
channel. Instead, you should return an array of data about the user.
The data returned by the authorization callback will be made available to the presence channel event listeners in your
JavaScript application. If the user is not authorized to join the presence channel, you should return false or null :

Page 326 of 1307

Laravel 9.x

Broadcast::channel('chat.{roomId}', function ($user, $roomId) {
if ($user->canJoinRoom($roomId)) {
return ['id' => $user->id, 'name' => $user->name];
}
});

Joining Presence Channels

To join a presence channel, you may use Echo's join method. The join method will return a PresenceChannel
implementation which, along with exposing the listen method, allows you to subscribe to the here , joining , and
leaving events.
Echo.join(`chat.${roomId}`)
.here((users) => {
//
})
.joining((user) => {
console.log(user.name);
})
.leaving((user) => {
console.log(user.name);
})
.error((error) => {
console.error(error);
});

The here callback will be executed immediately once the channel is joined successfully, and will receive an array
containing the user information for all of the other users currently subscribed to the channel. The joining method will
be executed when a new user joins a channel, while the leaving method will be executed when a user leaves the
channel. The error method will be executed when the authentication endpoint returns a HTTP status code other than
200 or if there is a problem parsing the returned JSON.

Broadcasting To Presence Channels

Presence channels may receive events just like public or private channels. Using the example of a chatroom, we may want
to broadcast NewMessage events to the room's presence channel. To do so, we'll return an instance of
PresenceChannel from the event's broadcastOn method:
/**
* Get the channels the event should broadcast on.
*
* @return Channel|array
*/
public function broadcastOn()
{
return new PresenceChannel('room.'.$this->message->room_id);
}

As with other events, you may use the broadcast helper and the toOthers method to exclude the current user from
receiving the broadcast:

Page 327 of 1307

Laravel 9.x

broadcast(new NewMessage($message));
broadcast(new NewMessage($message))->toOthers();

As typical of other types of events, you may listen for events sent to presence channels using Echo's listen method:
Echo.join(`chat.${roomId}`)
.here(/* ... */)
.joining(/* ... */)
.leaving(/* ... */)
.listen('NewMessage', (e) => {
//
});

Model Broadcasting
Before reading the following documentation about model broadcasting, we recommend you
become familiar with the general concepts of Laravel's model broadcasting services as well as how
to manually create and listen to broadcast events.
It is common to broadcast events when your application's Eloquent models are created, updated, or deleted. Of course,
this can easily be accomplished by manually defining custom events for Eloquent model state changes and marking those
events with the ShouldBroadcast interface.
However, if you are not using these events for any other purposes in your application, it can be cumbersome to create
event classes for the sole purpose of broadcasting them. To remedy this, Laravel allows you to indicate that an Eloquent
model should automatically broadcast its state changes.
To get started, your Eloquent model should use the Illuminate\Database\Eloquent\BroadcastsEvents trait. In
addition, the model should define a broadcastOn method, which will return an array of channels that the model's events
should broadcast on:

Page 328 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Database\Eloquent\BroadcastsEvents;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
class Post extends Model
{
use BroadcastsEvents, HasFactory;
/**
* Get the user that the post belongs to.
*/
public function user()
{
return $this->belongsTo(User::class);
}
/**
* Get the channels that model events should broadcast on.
*
* @param

string

$event

* @return \Illuminate\Broadcasting\Channel|array
*/
public function broadcastOn($event)
{
return [$this, $this->user];
}
}

Once your model includes this trait and defines its broadcast channels, it will begin automatically broadcasting events
when a model instance is created, updated, deleted, trashed, or restored.
In addition, you may have noticed that the broadcastOn method receives a string $event argument. This argument
contains the type of event that has occurred on the model and will have a value of created , updated , deleted ,
trashed , or restored . By inspecting the value of this variable, you may determine which channels (if any) the model
should broadcast to for a particular event:
/**
* Get the channels that model events should broadcast on.
*
* @param

string

$event

* @return \Illuminate\Broadcasting\Channel|array
*/
public function broadcastOn($event)
{
return match ($event) {
'deleted' => [],
default => [$this, $this->user],
};
}

Page 329 of 1307

Laravel 9.x

Customizing Model Broadcasting Event Creation
Occasionally, you may wish to customize how Laravel creates the underlying model broadcasting event. You may
accomplish this by defining a newBroadcastableEvent method on your Eloquent model. This method should return an
Illuminate\Database\Eloquent\BroadcastableModelEventOccurred instance:
use Illuminate\Database\Eloquent\BroadcastableModelEventOccurred;
/**
* Create a new broadcastable model event for the model.
*
* @param

string

$event

* @return \Illuminate\Database\Eloquent\BroadcastableModelEventOccurred
*/
protected function newBroadcastableEvent($event)
{
return (new BroadcastableModelEventOccurred(
$this, $event
))->dontBroadcastToCurrentUser();
}

Model Broadcasting Conventions

Channel Conventions
As you may have noticed, the broadcastOn method in the model example above did not return Channel instances.
Instead, Eloquent models were returned directly. If an Eloquent model instance is returned by your model's broadcastOn
method (or is contained in an array returned by the method), Laravel will automatically instantiate a private channel
instance for the model using the model's class name and primary key identifier as the channel name.
So, an App\Models\User model with an id of 1 would be converted into a
Illuminate\Broadcasting\PrivateChannel instance with a name of App.Models.User.1 . Of course, in addition to
returning Eloquent model instances from your model's broadcastOn method, you may return complete Channel
instances in order to have full control over the model's channel names:
use Illuminate\Broadcasting\PrivateChannel;
/**
* Get the channels that model events should broadcast on.
*
* @param

string

$event

* @return \Illuminate\Broadcasting\Channel|array
*/
public function broadcastOn($event)
{
return [new PrivateChannel('user.'.$this->id)];
}

If you plan to explicitly return a channel instance from your model's broadcastOn method, you may pass an Eloquent
model instance to the channel's constructor. When doing so, Laravel will use the model channel conventions discussed
above to convert the Eloquent model into a channel name string:
return [new Channel($this->user)];

Page 330 of 1307

Laravel 9.x

If you need to determine the channel name of a model, you may call the broadcastChannel method on any model
instance. For example, this method returns the string App.Models.User.1 for a App\Models\User model with an id
of 1 :
$user->broadcastChannel()

Event Conventions
Since model broadcast events are not associated with an "actual" event within your application's App\Events directory,
they are assigned a name and a payload based on conventions. Laravel's convention is to broadcast the event using the
class name of the model (not including the namespace) and the name of the model event that triggered the broadcast.
So, for example, an update to the App\Models\Post model would broadcast an event to your client-side application as
PostUpdated with the following payload:
{
"model": {
"id": 1,
"title": "My first post"
...
},
...
"socket": "someSocketId",
}

The deletion of the App\Models\User model would broadcast an event named UserDeleted .
If you would like, you may define a custom broadcast name and payload by adding a broadcastAs and broadcastWith
method to your model. These methods receive the name of the model event / operation that is occurring, allowing you to
customize the event's name and payload for each model operation. If null is returned from the broadcastAs method,
Laravel will use the model broadcasting event name conventions discussed above when broadcasting the event:

Page 331 of 1307

Laravel 9.x

/**
* The model event's broadcast name.
*
* @param

string

$event

* @return string|null
*/
public function broadcastAs($event)
{
return match ($event) {
'created' => 'post.created',
default => null,
};
}
/**
* Get the data to broadcast for the model.
*
* @param

string

$event

* @return array
*/
public function broadcastWith($event)
{
return match ($event) {
'created' => ['title' => $this->title],
default => ['model' => $this],
};
}

Listening For Model Broadcasts

Once you have added the BroadcastsEvents trait to your model and defined your model's broadcastOn method, you
are ready to start listening for broadcasted model events within your client-side application. Before getting started, you
may wish to consult the complete documentation on listening for events.
First, use the private method to retrieve an instance of a channel, then call the listen method to listen for a
specified event. Typically, the channel name given to the private method should correspond to Laravel's model
broadcasting conventions.
Once you have obtained a channel instance, you may use the listen method to listen for a particular event. Since model
broadcast events are not associated with an "actual" event within your application's App\Events directory, the event
name must be prefixed with a . to indicate it does not belong to a particular namespace. Each model broadcast event
has a model property which contains all of the broadcastable properties of the model:
Echo.private(`App.Models.User.${this.user.id}`)
.listen('.PostUpdated', (e) => {
console.log(e.model);
});

Client Events

Page 332 of 1307

Laravel 9.x

When using Pusher Channels, you must enable the "Client Events" option in the "App Settings"
section of your application dashboard in order to send client events.
Sometimes you may wish to broadcast an event to other connected clients without hitting your Laravel application at all.
This can be particularly useful for things like "typing" notifications, where you want to alert users of your application that
another user is typing a message on a given screen.
To broadcast client events, you may use Echo's whisper method:
Echo.private(`chat.${roomId}`)
.whisper('typing', {
name: this.user.name
});

To listen for client events, you may use the listenForWhisper method:
Echo.private(`chat.${roomId}`)
.listenForWhisper('typing', (e) => {
console.log(e.name);
});

Notifications

By pairing event broadcasting with notifications, your JavaScript application may receive new notifications as they occur
without needing to refresh the page. Before getting started, be sure to read over the documentation on using the
broadcast notification channel.
Once you have configured a notification to use the broadcast channel, you may listen for the broadcast events using
Echo's notification method. Remember, the channel name should match the class name of the entity receiving the
notifications:
Echo.private(`App.Models.User.${userId}`)
.notification((notification) => {
console.log(notification.type);
});

In this example, all notifications sent to App\Models\User instances via the broadcast channel would be received by
the callback. A channel authorization callback for the App.Models.User.{id} channel is included in the default
BroadcastServiceProvider that ships with the Laravel framework.

Page 333 of 1307

Laravel 9.x

Cache
Introduction
Configuration
Driver Prerequisites
Cache Usage
Obtaining A Cache Instance
Retrieving Items From The Cache
Storing Items In The Cache
Removing Items From The Cache
The Cache Helper
Cache Tags
Storing Tagged Cache Items
Accessing Tagged Cache Items
Removing Tagged Cache Items
Atomic Locks
Driver Prerequisites
Managing Locks
Managing Locks Across Processes
Adding Custom Cache Drivers
Writing The Driver
Registering The Driver
Events

Introduction

Some of the data retrieval or processing tasks performed by your application could be CPU intensive or take several
seconds to complete. When this is the case, it is common to cache the retrieved data for a time so it can be retrieved
quickly on subsequent requests for the same data. The cached data is usually stored in a very fast data store such as
Memcached or Redis.
Thankfully, Laravel provides an expressive, unified API for various cache backends, allowing you to take advantage of their
blazing fast data retrieval and speed up your web application.

Configuration

Your application's cache configuration file is located at config/cache.php . In this file, you may specify which cache
driver you would like to be used by default throughout your application. Laravel supports popular caching backends like
Memcached, Redis, DynamoDB, and relational databases out of the box. In addition, a file based cache driver is available,
while array and "null" cache drivers provide convenient cache backends for your automated tests.
The cache configuration file also contains various other options, which are documented within the file, so make sure to
read over these options. By default, Laravel is configured to use the file cache driver, which stores the serialized,
cached objects on the server's filesystem. For larger applications, it is recommended that you use a more robust driver
such as Memcached or Redis. You may even configure multiple cache configurations for the same driver.

Driver Prerequisites

Database
When using the database cache driver, you will need to set up a table to contain the cache items. You'll find an example
Schema declaration for the table below:

Page 334 of 1307

Laravel 9.x

Schema::create('cache', function ($table) {
$table->string('key')->unique();
$table->text('value');
$table->integer('expiration');
});

You may also use the php artisan cache:table Artisan command to generate a migration with
the proper schema.
Memcached
Using the Memcached driver requires the Memcached PECL package to be installed. You may list all of your Memcached
servers in the config/cache.php configuration file. This file already contains a memcached.servers entry to get you
started:
'memcached' => [
'servers' => [
[
'host' => env('MEMCACHED_HOST', '127.0.0.1'),
'port' => env('MEMCACHED_PORT', 11211),
'weight' => 100,
],
],
],

If needed, you may set the host option to a UNIX socket path. If you do this, the port option should be set to 0 :
'memcached' => [
[
'host' => '/var/run/memcached/memcached.sock',
'port' => 0,
'weight' => 100
],
],

Redis
Before using a Redis cache with Laravel, you will need to either install the PhpRedis PHP extension via PECL or install the
predis/predis package (~1.0) via Composer. Laravel Sail already includes this extension. In addition, official Laravel
deployment platforms such as Laravel Forge and Laravel Vapor have the PhpRedis extension installed by default.
For more information on configuring Redis, consult its Laravel documentation page.
DynamoDB
Before using the DynamoDB cache driver, you must create a DynamoDB table to store all of the cached data. Typically, this
table should be named cache . However, you should name the table based on the value of the stores.dynamodb.table
configuration value within your application's cache configuration file.
This table should also have a string partition key with a name that corresponds to the value of the
stores.dynamodb.attributes.key configuration item within your application's cache configuration file. By default,
the partition key should be named key .
Page 335 of 1307

Laravel 9.x

Cache Usage

Obtaining A Cache Instance

To obtain a cache store instance, you may use the Cache facade, which is what we will use throughout this
documentation. The Cache facade provides convenient, terse access to the underlying implementations of the Laravel
cache contracts:
<?php
namespace App\Http\Controllers;
use Illuminate\Support\Facades\Cache;
class UserController extends Controller
{
/**
* Show a list of all users of the application.
*
* @return Response
*/
public function index()
{
$value = Cache::get('key');
//
}
}

Accessing Multiple Cache Stores
Using the Cache facade, you may access various cache stores via the store method. The key passed to the store
method should correspond to one of the stores listed in the stores configuration array in your cache configuration file:
$value = Cache::store('file')->get('foo');
Cache::store('redis')->put('bar', 'baz', 600); // 10 Minutes

Retrieving Items From The Cache

The Cache facade's get method is used to retrieve items from the cache. If the item does not exist in the cache, null
will be returned. If you wish, you may pass a second argument to the get method specifying the default value you wish to
be returned if the item doesn't exist:
$value = Cache::get('key');
$value = Cache::get('key', 'default');

You may even pass a closure as the default value. The result of the closure will be returned if the specified item does not
exist in the cache. Passing a closure allows you to defer the retrieval of default values from a database or other external
service:

Page 336 of 1307

Laravel 9.x

$value = Cache::get('key', function () {
return DB::table(/* ... */)->get();
});

Checking For Item Existence
The has method may be used to determine if an item exists in the cache. This method will also return false if the item
exists but its value is null :
if (Cache::has('key')) {
//
}

Incrementing / Decrementing Values
The increment and decrement methods may be used to adjust the value of integer items in the cache. Both of these
methods accept an optional second argument indicating the amount by which to increment or decrement the item's value:
Cache::increment('key');
Cache::increment('key', $amount);
Cache::decrement('key');
Cache::decrement('key', $amount);

Retrieve & Store
Sometimes you may wish to retrieve an item from the cache, but also store a default value if the requested item doesn't
exist. For example, you may wish to retrieve all users from the cache or, if they don't exist, retrieve them from the database
and add them to the cache. You may do this using the Cache::remember method:
$value = Cache::remember('users', $seconds, function () {
return DB::table('users')->get();
});

If the item does not exist in the cache, the closure passed to the remember method will be executed and its result will be
placed in the cache.
You may use the rememberForever method to retrieve an item from the cache or store it forever if it does not exist:
$value = Cache::rememberForever('users', function () {
return DB::table('users')->get();
});

Retrieve & Delete
If you need to retrieve an item from the cache and then delete the item, you may use the pull method. Like the get
method, null will be returned if the item does not exist in the cache:
$value = Cache::pull('key');

Storing Items In The Cache

You may use the put method on the Cache facade to store items in the cache:

Page 337 of 1307

Laravel 9.x

Cache::put('key', 'value', $seconds = 10);

If the storage time is not passed to the put method, the item will be stored indefinitely:
Cache::put('key', 'value');

Instead of passing the number of seconds as an integer, you may also pass a DateTime instance representing the
desired expiration time of the cached item:
Cache::put('key', 'value', now()->addMinutes(10));

Store If Not Present
The add method will only add the item to the cache if it does not already exist in the cache store. The method will return
true if the item is actually added to the cache. Otherwise, the method will return false . The add method is an
atomic operation:
Cache::add('key', 'value', $seconds);

Storing Items Forever
The forever method may be used to store an item in the cache permanently. Since these items will not expire, they must
be manually removed from the cache using the forget method:
Cache::forever('key', 'value');

If you are using the Memcached driver, items that are stored "forever" may be removed when the
cache reaches its size limit.

Removing Items From The Cache

You may remove items from the cache using the forget method:
Cache::forget('key');

You may also remove items by providing a zero or negative number of expiration seconds:
Cache::put('key', 'value', 0);
Cache::put('key', 'value', -5);

You may clear the entire cache using the flush method:
Cache::flush();

Page 338 of 1307

Laravel 9.x

Flushing the cache does not respect your configured cache "prefix" and will remove all entries from
the cache. Consider this carefully when clearing a cache which is shared by other applications.

The Cache Helper

In addition to using the Cache facade, you may also use the global cache function to retrieve and store data via the
cache. When the cache function is called with a single, string argument, it will return the value of the given key:
$value = cache('key');

If you provide an array of key / value pairs and an expiration time to the function, it will store values in the cache for the
specified duration:
cache(['key' => 'value'], $seconds);
cache(['key' => 'value'], now()->addMinutes(10));

When the cache function is called without any arguments, it returns an instance of the
Illuminate\Contracts\Cache\Factory implementation, allowing you to call other caching methods:
cache()->remember('users', $seconds, function () {
return DB::table('users')->get();
});

When testing call to the global cache function, you may use the Cache::shouldReceive
method just as if you were testing the facade.

Cache Tags
Cache tags are not supported when using the file , dynamodb , or database cache drivers.
Furthermore, when using multiple tags with caches that are stored "forever", performance will be
best with a driver such as memcached , which automatically purges stale records.

Storing Tagged Cache Items

Cache tags allow you to tag related items in the cache and then flush all cached values that have been assigned a given
tag. You may access a tagged cache by passing in an ordered array of tag names. For example, let's access a tagged
cache and put a value into the cache:
Cache::tags(['people', 'artists'])->put('John', $john, $seconds);
Cache::tags(['people', 'authors'])->put('Anne', $anne, $seconds);

Page 339 of 1307

Laravel 9.x

Accessing Tagged Cache Items

Items stored via tags may not be accessed without also providing the tags that were used to store the value. To retrieve a
tagged cache item, pass the same ordered list of tags to the tags method and then call the get method with the key
you wish to retrieve:
$john = Cache::tags(['people', 'artists'])->get('John');
$anne = Cache::tags(['people', 'authors'])->get('Anne');

Removing Tagged Cache Items

You may flush all items that are assigned a tag or list of tags. For example, this statement would remove all caches tagged
with either people , authors , or both. So, both Anne and John would be removed from the cache:
Cache::tags(['people', 'authors'])->flush();

In contrast, this statement would remove only cached values tagged with authors , so Anne would be removed, but not
John :
Cache::tags('authors')->flush();

Atomic Locks
To utilize this feature, your application must be using the memcached , redis , dynamodb ,
database , file , or array cache driver as your application's default cache driver. In addition,
all servers must be communicating with the same central cache server.

Driver Prerequisites

Database
When using the database cache driver, you will need to setup a table to contain your application's cache locks. You'll
find an example Schema declaration for the table below:
Schema::create('cache_locks', function ($table) {
$table->string('key')->primary();
$table->string('owner');
$table->integer('expiration');
});

Managing Locks

Atomic locks allow for the manipulation of distributed locks without worrying about race conditions. For example, Laravel
Forge uses atomic locks to ensure that only one remote task is being executed on a server at a time. You may create and
manage locks using the Cache::lock method:

Page 340 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Cache;
$lock = Cache::lock('foo', 10);
if ($lock->get()) {
// Lock acquired for 10 seconds...
$lock->release();
}

The get method also accepts a closure. After the closure is executed, Laravel will automatically release the lock:
Cache::lock('foo', 10)->get(function () {
// Lock acquired for 10 seconds and automatically released...
});

If the lock is not available at the moment you request it, you may instruct Laravel to wait for a specified number of seconds.
If the lock can not be acquired within the specified time limit, an
Illuminate\Contracts\Cache\LockTimeoutException will be thrown:
use Illuminate\Contracts\Cache\LockTimeoutException;
$lock = Cache::lock('foo', 10);
try {
$lock->block(5);
// Lock acquired after waiting a maximum of 5 seconds...
} catch (LockTimeoutException $e) {
// Unable to acquire lock...
} finally {
optional($lock)->release();
}

The example above may be simplified by passing a closure to the block method. When a closure is passed to this
method, Laravel will attempt to acquire the lock for the specified number of seconds and will automatically release the lock
once the closure has been executed:
Cache::lock('foo', 10)->block(5, function () {
// Lock acquired after waiting a maximum of 5 seconds...
});

Managing Locks Across Processes

Sometimes, you may wish to acquire a lock in one process and release it in another process. For example, you may acquire
a lock during a web request and wish to release the lock at the end of a queued job that is triggered by that request. In this
scenario, you should pass the lock's scoped "owner token" to the queued job so that the job can re-instantiate the lock
using the given token.
In the example below, we will dispatch a queued job if a lock is successfully acquired. In addition, we will pass the lock's
owner token to the queued job via the lock's owner method:

Page 341 of 1307

Laravel 9.x

$podcast = Podcast::find($id);
$lock = Cache::lock('processing', 120);
if ($lock->get()) {
ProcessPodcast::dispatch($podcast, $lock->owner());
}

Within our application's ProcessPodcast job, we can restore and release the lock using the owner token:
Cache::restoreLock('processing', $this->owner)->release();

If you would like to release a lock without respecting its current owner, you may use the forceRelease method:
Cache::lock('processing')->forceRelease();

Adding Custom Cache Drivers
Writing The Driver

To create our custom cache driver, we first need to implement the Illuminate\Contracts\Cache\Store contract. So, a
MongoDB cache implementation might look something like this:
<?php
namespace App\Extensions;
use Illuminate\Contracts\Cache\Store;
class MongoStore implements Store
{
public function get($key) {}
public function many(array $keys) {}
public function put($key, $value, $seconds) {}
public function putMany(array $values, $seconds) {}
public function increment($key, $value = 1) {}
public function decrement($key, $value = 1) {}
public function forever($key, $value) {}
public function forget($key) {}
public function flush() {}
public function getPrefix() {}
}

We just need to implement each of these methods using a MongoDB connection. For an example of how to implement each
of these methods, take a look at the Illuminate\Cache\MemcachedStore in the Laravel framework source code. Once
our implementation is complete, we can finish our custom driver registration by calling the Cache facade's extend
method:
Cache::extend('mongo', function ($app) {
return Cache::repository(new MongoStore);
});

Page 342 of 1307

Laravel 9.x

If you're wondering where to put your custom cache driver code, you could create an
Extensions namespace within your app directory. However, keep in mind that Laravel does not
have a rigid application structure and you are free to organize your application according to your
preferences.

Registering The Driver

To register the custom cache driver with Laravel, we will use the extend method on the Cache facade. Since other
service providers may attempt to read cached values within their boot method, we will register our custom driver within a
booting callback. By using the booting callback, we can ensure that the custom driver is registered just before the
boot method is called on our application's service providers but after the register method is called on all of the
service providers. We will register our booting callback within the register method of our application's
App\Providers\AppServiceProvider class:
<?php
namespace App\Providers;
use App\Extensions\MongoStore;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\ServiceProvider;
class CacheServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
$this->app->booting(function () {
Cache::extend('mongo', function ($app) {
return Cache::repository(new MongoStore);
});
});
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
//
}
}

The first argument passed to the extend method is the name of the driver. This will correspond to your driver option
in the config/cache.php configuration file. The second argument is a closure that should return an

Page 343 of 1307

Laravel 9.x
Illuminate\Cache\Repository instance. The closure will be passed an $app instance, which is an instance of the
service container.
Once your extension is registered, update your config/cache.php configuration file's driver option to the name of
your extension.

Events

To execute code on every cache operation, you may listen for the events fired by the cache. Typically, you should place
these event listeners within your application's App\Providers\EventServiceProvider class:
use App\Listeners\LogCacheHit;
use App\Listeners\LogCacheMissed;
use App\Listeners\LogKeyForgotten;
use App\Listeners\LogKeyWritten;
use Illuminate\Cache\Events\CacheHit;
use Illuminate\Cache\Events\CacheMissed;
use Illuminate\Cache\Events\KeyForgotten;
use Illuminate\Cache\Events\KeyWritten;
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
CacheHit::class => [
LogCacheHit::class,
],
CacheMissed::class => [
LogCacheMissed::class,
],
KeyForgotten::class => [
LogKeyForgotten::class,
],
KeyWritten::class => [
LogKeyWritten::class,
],
];

Page 344 of 1307

Laravel 9.x

Introduction
Creating Collections
Extending Collections
Available Methods
Higher Order Messages
Lazy Collections
Introduction
Creating Lazy Collections
The Enumerable Contract
Lazy Collection Methods

Collections

Introduction

The Illuminate\Support\Collection class provides a fluent, convenient wrapper for working with arrays of data. For
example, check out the following code. We'll use the collect helper to create a new collection instance from the array,
run the strtoupper function on each element, and then remove all empty elements:
$collection = collect(['taylor', 'abigail', null])->map(function ($name) {
return strtoupper($name);
})->reject(function ($name) {
return empty($name);
});

As you can see, the Collection class allows you to chain its methods to perform fluent mapping and reducing of the
underlying array. In general, collections are immutable, meaning every Collection method returns an entirely new
Collection instance.

Creating Collections

As mentioned above, the collect helper returns a new Illuminate\Support\Collection instance for the given
array. So, creating a collection is as simple as:
$collection = collect([1, 2, 3]);

The results of Eloquent queries are always returned as Collection instances.

Extending Collections

Collections are "macroable", which allows you to add additional methods to the Collection class at run time. The
Illuminate\Support\Collection class' macro method accepts a closure that will be executed when your macro is
called. The macro closure may access the collection's other methods via $this , just as if it were a real method of the
collection class. For example, the following code adds a toUpper method to the Collection class:

Page 345 of 1307

Laravel 9.x

use Illuminate\Support\Collection;
use Illuminate\Support\Str;
Collection::macro('toUpper', function () {
return $this->map(function ($value) {
return Str::upper($value);
});
});
$collection = collect(['first', 'second']);
$upper = $collection->toUpper();
// ['FIRST', 'SECOND']

Typically, you should declare collection macros in the boot method of a service provider.
Macro Arguments
If necessary, you may define macros that accept additional arguments:
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Lang;
Collection::macro('toLocale', function ($locale) {
return $this->map(function ($value) use ($locale) {
return Lang::get($value, [], $locale);
});
});
$collection = collect(['first', 'second']);
$translated = $collection->toLocale('es');

Available Methods

For the majority of the remaining collection documentation, we'll discuss each method available on the Collection
class. Remember, all of these methods may be chained to fluently manipulate the underlying array. Furthermore, almost
every method returns a new Collection instance, allowing you to preserve the original copy of the collection when
necessary:
all
crossJoin
first
average
dd
firstOrFail
avg
diff
firstWhere
chunk
diffAssoc
flatMap
chunkWhile
diffKeys
flatten
collapse
doesntContain
flip
collect
dump
forget
combine
duplicates
forPage
concat
duplicatesStrict
get
contains
each
groupBy
containsOneItem
eachSpread
has
containsStrict
every
hasAny
count
except
implode
countBy
filter
intersect
Page 346 of 1307

Laravel 9.x

intersectByKeys
isEmpty
isNotEmpty
join
keyBy
keys
last
lazy
macro
make
map
mapInto
mapSpread
mapToGroups
mapWithKeys
max
median
merge
mergeRecursive
min
mode
nth
only
pad
partition
pipe
pipeInto
pipeThrough
pluck
pop
prepend
pull
push

Method Listing

put
random
range
reduce
reduceSpread
reject
replace
replaceRecursive
reverse
search
shift
shuffle
skip
skipUntil
skipWhile
slice
sliding
sole
some
sort
sortBy
sortByDesc
sortDesc
sortKeys
sortKeysDesc
sortKeysUsing
splice
split
splitIn
sum
take
takeUntil
takeWhile

all()

The all method returns the underlying array represented by the collection:
collect([1, 2, 3])->all();
// [1, 2, 3]

average()

Alias for the avg method.
avg()

The avg method returns the average value of a given key:

Page 347 of 1307

tap
times
toArray
toJson
transform
undot
union
unique
uniqueStrict
unless
unlessEmpty
unlessNotEmpty
unwrap
value
values
when
whenEmpty
whenNotEmpty
where
whereStrict
whereBetween
whereIn
whereInStrict
whereInstanceOf
whereNotBetween
whereNotIn
whereNotInStrict
whereNotNull
whereNull
wrap
zip

Laravel 9.x

$average = collect([
['foo' => 10],
['foo' => 10],
['foo' => 20],
['foo' => 40]
])->avg('foo');
// 20
$average = collect([1, 1, 2, 4])->avg();
// 2

chunk()

The chunk method breaks the collection into multiple, smaller collections of a given size:
$collection = collect([1, 2, 3, 4, 5, 6, 7]);
$chunks = $collection->chunk(4);
$chunks->all();
// [[1, 2, 3, 4], [5, 6, 7]]

This method is especially useful in views when working with a grid system such as Bootstrap. For example, imagine you
have a collection of Eloquent models you want to display in a grid:
@foreach ($products->chunk(3) as $chunk)
<div class="row">
@foreach ($chunk as $product)
<div class="col-xs-4">{{ $product->name }}</div>
@endforeach
</div>
@endforeach

chunkWhile()

The chunkWhile method breaks the collection into multiple, smaller collections based on the evaluation of the given
callback. The $chunk variable passed to the closure may be used to inspect the previous element:
$collection = collect(str_split('AABBCCCD'));
$chunks = $collection->chunkWhile(function ($value, $key, $chunk) {
return $value === $chunk->last();
});
$chunks->all();
// [['A', 'A'], ['B', 'B'], ['C', 'C', 'C'], ['D']]

collapse()

The collapse method collapses a collection of arrays into a single, flat collection:
Page 348 of 1307

Laravel 9.x

$collection = collect([
[1, 2, 3],
[4, 5, 6],
[7, 8, 9],
]);
$collapsed = $collection->collapse();
$collapsed->all();
// [1, 2, 3, 4, 5, 6, 7, 8, 9]

collect()

The collect method returns a new Collection instance with the items currently in the collection:
$collectionA = collect([1, 2, 3]);
$collectionB = $collectionA->collect();
$collectionB->all();
// [1, 2, 3]

The collect method is primarily useful for converting lazy collections into standard Collection instances:
$lazyCollection = LazyCollection::make(function () {
yield 1;
yield 2;
yield 3;
});
$collection = $lazyCollection->collect();
get_class($collection);
// 'Illuminate\Support\Collection'
$collection->all();
// [1, 2, 3]

The collect method is especially useful when you have an instance of Enumerable and need a
non-lazy collection instance. Since collect() is part of the Enumerable contract, you can
safely use it to get a Collection instance.
combine()

The combine method combines the values of the collection, as keys, with the values of another array or collection:

Page 349 of 1307

Laravel 9.x

$collection = collect(['name', 'age']);
$combined = $collection->combine(['George', 29]);
$combined->all();
// ['name' => 'George', 'age' => 29]

concat()

The concat method appends the given array or collection's values onto the end of another collection:
$collection = collect(['John Doe']);
$concatenated = $collection->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']);
$concatenated->all();
// ['John Doe', 'Jane Doe', 'Johnny Doe']

The concat method numerically reindexes keys for items concatenated onto the original collection. To maintain keys in
associative collections, see the merge method.
contains()

The contains method determines whether the collection contains a given item. You may pass a closure to the
contains method to determine if an element exists in the collection matching a given truth test:
$collection = collect([1, 2, 3, 4, 5]);
$collection->contains(function ($value, $key) {
return $value > 5;
});
// false

Alternatively, you may pass a string to the contains method to determine whether the collection contains a given item
value:
$collection = collect(['name' => 'Desk', 'price' => 100]);
$collection->contains('Desk');
// true
$collection->contains('New York');
// false

You may also pass a key / value pair to the contains method, which will determine if the given pair exists in the
collection:

Page 350 of 1307

Laravel 9.x

$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 100],
]);
$collection->contains('product', 'Bookcase');
// false

The contains method uses "loose" comparisons when checking item values, meaning a string with an integer value will
be considered equal to an integer of the same value. Use the containsStrict method to filter using "strict"
comparisons.
For the inverse of contains , see the doesntContain method.
containsOneItem()

The containsOneItem method determines whether the collection contains a single item:
collect([])->containsOneItem();
// false
collect(['1'])->containsOneItem();
// true
collect(['1', '2'])->containsOneItem();
// false

containsStrict()

This method has the same signature as the contains method; however, all values are compared using "strict"
comparisons.
This method's behavior is modified when using Eloquent Collections.
count()

The count method returns the total number of items in the collection:
$collection = collect([1, 2, 3, 4]);
$collection->count();
// 4

countBy()

The countBy method counts the occurrences of values in the collection. By default, the method counts the occurrences
of every element, allowing you to count certain "types" of elements in the collection:

Page 351 of 1307

Laravel 9.x

$collection = collect([1, 2, 2, 2, 3]);
$counted = $collection->countBy();
$counted->all();
// [1 => 1, 2 => 3, 3 => 1]

You pass a closure to the countBy method to count all items by a custom value:
$collection = collect(['alice@gmail.com', 'bob@yahoo.com', 'carlos@gmail.com']);
$counted = $collection->countBy(function ($email) {
return substr(strrchr($email, "@"), 1);
});
$counted->all();
// ['gmail.com' => 2, 'yahoo.com' => 1]

crossJoin()

The crossJoin method cross joins the collection's values among the given arrays or collections, returning a Cartesian
product with all possible permutations:

Page 352 of 1307

Laravel 9.x

$collection = collect([1, 2]);
$matrix = $collection->crossJoin(['a', 'b']);
$matrix->all();
/*
[
[1, 'a'],
[1, 'b'],
[2, 'a'],
[2, 'b'],
]
*/
$collection = collect([1, 2]);
$matrix = $collection->crossJoin(['a', 'b'], ['I', 'II']);
$matrix->all();
/*
[
[1, 'a', 'I'],
[1, 'a', 'II'],
[1, 'b', 'I'],
[1, 'b', 'II'],
[2, 'a', 'I'],
[2, 'a', 'II'],
[2, 'b', 'I'],
[2, 'b', 'II'],
]
*/

dd()

The dd method dumps the collection's items and ends execution of the script:
$collection = collect(['John Doe', 'Jane Doe']);
$collection->dd();
/*
Collection {
#items: array:2 [
0 => "John Doe"
1 => "Jane Doe"
]
}
*/

If you do not want to stop executing the script, use the dump method instead.
diff()

Page 353 of 1307

Laravel 9.x

The diff method compares the collection against another collection or a plain PHP array based on its values. This
method will return the values in the original collection that are not present in the given collection:
$collection = collect([1, 2, 3, 4, 5]);
$diff = $collection->diff([2, 4, 6, 8]);
$diff->all();
// [1, 3, 5]

This method's behavior is modified when using Eloquent Collections.
diffAssoc()

The diffAssoc method compares the collection against another collection or a plain PHP array based on its keys and
values. This method will return the key / value pairs in the original collection that are not present in the given collection:
$collection = collect([
'color' => 'orange',
'type' => 'fruit',
'remain' => 6,
]);
$diff = $collection->diffAssoc([
'color' => 'yellow',
'type' => 'fruit',
'remain' => 3,
'used' => 6,
]);
$diff->all();
// ['color' => 'orange', 'remain' => 6]

diffKeys()

The diffKeys method compares the collection against another collection or a plain PHP array based on its keys. This
method will return the key / value pairs in the original collection that are not present in the given collection:

Page 354 of 1307

Laravel 9.x

$collection = collect([
'one' => 10,
'two' => 20,
'three' => 30,
'four' => 40,
'five' => 50,
]);
$diff = $collection->diffKeys([
'two' => 2,
'four' => 4,
'six' => 6,
'eight' => 8,
]);
$diff->all();
// ['one' => 10, 'three' => 30, 'five' => 50]

doesntContain()

The doesntContain method determines whether the collection does not contain a given item. You may pass a closure to
the doesntContain method to determine if an element does not exist in the collection matching a given truth test:
$collection = collect([1, 2, 3, 4, 5]);
$collection->doesntContain(function ($value, $key) {
return $value < 5;
});
// false

Alternatively, you may pass a string to the doesntContain method to determine whether the collection does not contain
a given item value:
$collection = collect(['name' => 'Desk', 'price' => 100]);
$collection->doesntContain('Table');
// true
$collection->doesntContain('Desk');
// false

You may also pass a key / value pair to the doesntContain method, which will determine if the given pair does not exist
in the collection:

Page 355 of 1307

Laravel 9.x

$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 100],
]);
$collection->doesntContain('product', 'Bookcase');
// true

The doesntContain method uses "loose" comparisons when checking item values, meaning a string with an integer
value will be considered equal to an integer of the same value.
dump()

The dump method dumps the collection's items:
$collection = collect(['John Doe', 'Jane Doe']);
$collection->dump();
/*
Collection {
#items: array:2 [
0 => "John Doe"
1 => "Jane Doe"
]
}
*/

If you want to stop executing the script after dumping the collection, use the dd method instead.
duplicates()

The duplicates method retrieves and returns duplicate values from the collection:
$collection = collect(['a', 'b', 'a', 'c', 'b']);
$collection->duplicates();
// [2 => 'a', 4 => 'b']

If the collection contains arrays or objects, you can pass the key of the attributes that you wish to check for duplicate
values:
$employees = collect([
['email' => 'abigail@example.com', 'position' => 'Developer'],
['email' => 'james@example.com', 'position' => 'Designer'],
['email' => 'victoria@example.com', 'position' => 'Developer'],
]);
$employees->duplicates('position');
// [2 => 'Developer']

Page 356 of 1307

Laravel 9.x

duplicatesStrict()

This method has the same signature as the duplicates method; however, all values are compared using "strict"
comparisons.
each()

The each method iterates over the items in the collection and passes each item to a closure:
$collection->each(function ($item, $key) {
//
});

If you would like to stop iterating through the items, you may return false from your closure:
$collection->each(function ($item, $key) {
if (/* condition */) {
return false;
}
});

eachSpread()

The eachSpread method iterates over the collection's items, passing each nested item value into the given callback:
$collection = collect([['John Doe', 35], ['Jane Doe', 33]]);
$collection->eachSpread(function ($name, $age) {
//
});

You may stop iterating through the items by returning false from the callback:
$collection->eachSpread(function ($name, $age) {
return false;
});

every()

The every method may be used to verify that all elements of a collection pass a given truth test:
collect([1, 2, 3, 4])->every(function ($value, $key) {
return $value > 2;
});
// false

If the collection is empty, the every method will return true:

Page 357 of 1307

Laravel 9.x

$collection = collect([]);
$collection->every(function ($value, $key) {
return $value > 2;
});
// true

except()

The except method returns all items in the collection except for those with the specified keys:
$collection = collect(['product_id' => 1, 'price' => 100, 'discount' => false]);
$filtered = $collection->except(['price', 'discount']);
$filtered->all();
// ['product_id' => 1]

For the inverse of except , see the only method.
This method's behavior is modified when using Eloquent Collections.
filter()

The filter method filters the collection using the given callback, keeping only those items that pass a given truth test:
$collection = collect([1, 2, 3, 4]);
$filtered = $collection->filter(function ($value, $key) {
return $value > 2;
});
$filtered->all();
// [3, 4]

If no callback is supplied, all entries of the collection that are equivalent to false will be removed:
$collection = collect([1, 2, 3, null, false, '', 0, []]);
$collection->filter()->all();
// [1, 2, 3]

For the inverse of filter , see the reject method.
first()

The first method returns the first element in the collection that passes a given truth test:

Page 358 of 1307

Laravel 9.x

collect([1, 2, 3, 4])->first(function ($value, $key) {
return $value > 2;
});
// 3

You may also call the first method with no arguments to get the first element in the collection. If the collection is
empty, null is returned:
collect([1, 2, 3, 4])->first();
// 1

firstOrFail()

The firstOrFail method is identical to the first method; however, if no result is found, an
Illuminate\Support\ItemNotFoundException exception will be thrown:
collect([1, 2, 3, 4])->firstOrFail(function ($value, $key) {
return $value > 5;
});
// Throws ItemNotFoundException...

You may also call the firstOrFail method with no arguments to get the first element in the collection. If the collection
is empty, an Illuminate\Support\ItemNotFoundException exception will be thrown:
collect([])->firstOrFail();
// Throws ItemNotFoundException...

firstWhere()

The firstWhere method returns the first element in the collection with the given key / value pair:
$collection = collect([
['name' => 'Regena', 'age' => null],
['name' => 'Linda', 'age' => 14],
['name' => 'Diego', 'age' => 23],
['name' => 'Linda', 'age' => 84],
]);
$collection->firstWhere('name', 'Linda');
// ['name' => 'Linda', 'age' => 14]

You may also call the firstWhere method with a comparison operator:
$collection->firstWhere('age', '>=', 18);
// ['name' => 'Diego', 'age' => 23]

Page 359 of 1307

Laravel 9.x

Like the where method, you may pass one argument to the firstWhere method. In this scenario, the firstWhere
method will return the first item where the given item key's value is "truthy":
$collection->firstWhere('age');
// ['name' => 'Linda', 'age' => 14]

flatMap()

The flatMap method iterates through the collection and passes each value to the given closure. The closure is free to
modify the item and return it, thus forming a new collection of modified items. Then, the array is flattened by one level:
$collection = collect([
['name' => 'Sally'],
['school' => 'Arkansas'],
['age' => 28]
]);
$flattened = $collection->flatMap(function ($values) {
return array_map('strtoupper', $values);
});
$flattened->all();
// ['name' => 'SALLY', 'school' => 'ARKANSAS', 'age' => '28'];

flatten()

The flatten method flattens a multi-dimensional collection into a single dimension:
$collection = collect([
'name' => 'taylor',
'languages' => [
'php', 'javascript'
]
]);
$flattened = $collection->flatten();
$flattened->all();
// ['taylor', 'php', 'javascript'];

If necessary, you may pass the flatten method a "depth" argument:

Page 360 of 1307

Laravel 9.x

$collection = collect([
'Apple' => [
[
'name' => 'iPhone 6S',
'brand' => 'Apple'
],
],
'Samsung' => [
[
'name' => 'Galaxy S7',
'brand' => 'Samsung'
],
],
]);
$products = $collection->flatten(1);
$products->values()->all();
/*
[
['name' => 'iPhone 6S', 'brand' => 'Apple'],
['name' => 'Galaxy S7', 'brand' => 'Samsung'],
]
*/

In this example, calling flatten without providing the depth would have also flattened the nested arrays, resulting in
['iPhone 6S', 'Apple', 'Galaxy S7', 'Samsung'] . Providing a depth allows you to specify the number of levels
nested arrays will be flattened.
flip()

The flip method swaps the collection's keys with their corresponding values:
$collection = collect(['name' => 'taylor', 'framework' => 'laravel']);
$flipped = $collection->flip();
$flipped->all();
// ['taylor' => 'name', 'laravel' => 'framework']

forget()

The forget method removes an item from the collection by its key:
$collection = collect(['name' => 'taylor', 'framework' => 'laravel']);
$collection->forget('name');
$collection->all();
// ['framework' => 'laravel']

Page 361 of 1307

Laravel 9.x

Unlike most other collection methods, forget does not return a new modified collection; it
modifies the collection it is called on.
forPage()

The forPage method returns a new collection containing the items that would be present on a given page number. The
method accepts the page number as its first argument and the number of items to show per page as its second argument:
$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);
$chunk = $collection->forPage(2, 3);
$chunk->all();
// [4, 5, 6]

get()

The get method returns the item at a given key. If the key does not exist, null is returned:
$collection = collect(['name' => 'taylor', 'framework' => 'laravel']);
$value = $collection->get('name');
// taylor

You may optionally pass a default value as the second argument:
$collection = collect(['name' => 'taylor', 'framework' => 'laravel']);
$value = $collection->get('age', 34);
// 34

You may even pass a callback as the method's default value. The result of the callback will be returned if the specified key
does not exist:
$collection->get('email', function () {
return 'taylor@example.com';
});
// taylor@example.com

groupBy()

The groupBy method groups the collection's items by a given key:

Page 362 of 1307

Laravel 9.x

$collection = collect([
['account_id' => 'account-x10', 'product' => 'Chair'],
['account_id' => 'account-x10', 'product' => 'Bookcase'],
['account_id' => 'account-x11', 'product' => 'Desk'],
]);
$grouped = $collection->groupBy('account_id');
$grouped->all();
/*
[
'account-x10' => [
['account_id' => 'account-x10', 'product' => 'Chair'],
['account_id' => 'account-x10', 'product' => 'Bookcase'],
],
'account-x11' => [
['account_id' => 'account-x11', 'product' => 'Desk'],
],
]
*/

Instead of passing a string key , you may pass a callback. The callback should return the value you wish to key the group
by:
$grouped = $collection->groupBy(function ($item, $key) {
return substr($item['account_id'], -3);
});
$grouped->all();
/*
[
'x10' => [
['account_id' => 'account-x10', 'product' => 'Chair'],
['account_id' => 'account-x10', 'product' => 'Bookcase'],
],
'x11' => [
['account_id' => 'account-x11', 'product' => 'Desk'],
],
]
*/

Multiple grouping criteria may be passed as an array. Each array element will be applied to the corresponding level within a
multi-dimensional array:

Page 363 of 1307

Laravel 9.x

$data = new Collection([
10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],
20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],
30 => ['user' => 3, 'skill' => 2, 'roles' => ['Role_1']],
40 => ['user' => 4, 'skill' => 2, 'roles' => ['Role_2']],
]);
$result = $data->groupBy(['skill', function ($item) {
return $item['roles'];
}], preserveKeys: true);
/*
[
1 => [
'Role_1' => [
10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],
20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],
],
'Role_2' => [
20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],
],
'Role_3' => [
10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],
],
],
2 => [
'Role_1' => [
30 => ['user' => 3, 'skill' => 2, 'roles' => ['Role_1']],
],
'Role_2' => [
40 => ['user' => 4, 'skill' => 2, 'roles' => ['Role_2']],
],
],
];
*/

has()

The has method determines if a given key exists in the collection:
$collection = collect(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]);
$collection->has('product');
// true
$collection->has(['product', 'amount']);
// true
$collection->has(['amount', 'price']);
// false

hasAny()

Page 364 of 1307

Laravel 9.x

The hasAny method determines whether any of the given keys exist in the collection:
$collection = collect(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]);
$collection->hasAny(['product', 'price']);
// true
$collection->hasAny(['name', 'price']);
// false

implode()

The implode method joins items in a collection. Its arguments depend on the type of items in the collection. If the
collection contains arrays or objects, you should pass the key of the attributes you wish to join, and the "glue" string you
wish to place between the values:
$collection = collect([
['account_id' => 1, 'product' => 'Desk'],
['account_id' => 2, 'product' => 'Chair'],
]);
$collection->implode('product', ', ');
// Desk, Chair

If the collection contains simple strings or numeric values, you should pass the "glue" as the only argument to the method:
collect([1, 2, 3, 4, 5])->implode('-');
// '1-2-3-4-5'

You may pass a closure to the implode method if you would like to format the values being imploded:
$collection->implode(function ($item, $key) {
return strtoupper($item['product']);
}, ', ');
// DESK, CHAIR

intersect()

The intersect method removes any values from the original collection that are not present in the given array or
collection. The resulting collection will preserve the original collection's keys:
$collection = collect(['Desk', 'Sofa', 'Chair']);
$intersect = $collection->intersect(['Desk', 'Chair', 'Bookcase']);
$intersect->all();
// [0 => 'Desk', 2 => 'Chair']

Page 365 of 1307

Laravel 9.x

This method's behavior is modified when using Eloquent Collections.
intersectByKeys()

The intersectByKeys method removes any keys and their corresponding values from the original collection that are not
present in the given array or collection:
$collection = collect([
'serial' => 'UX301', 'type' => 'screen', 'year' => 2009,
]);
$intersect = $collection->intersectByKeys([
'reference' => 'UX404', 'type' => 'tab', 'year' => 2011,
]);
$intersect->all();
// ['type' => 'screen', 'year' => 2009]

isEmpty()

The isEmpty method returns true if the collection is empty; otherwise, false is returned:
collect([])->isEmpty();
// true

isNotEmpty()

The isNotEmpty method returns true if the collection is not empty; otherwise, false is returned:
collect([])->isNotEmpty();
// false

join()

The join method joins the collection's values with a string. Using this method's second argument, you may also specify
how the final element should be appended to the string:
collect(['a', 'b', 'c'])->join(', '); // 'a, b, c'
collect(['a', 'b', 'c'])->join(', ', ', and '); // 'a, b, and c'
collect(['a', 'b'])->join(', ', ' and '); // 'a and b'
collect(['a'])->join(', ', ' and '); // 'a'
collect([])->join(', ', ' and '); // ''

keyBy()

The keyBy method keys the collection by the given key. If multiple items have the same key, only the last one will appear
in the new collection:

Page 366 of 1307

Laravel 9.x

$collection = collect([
['product_id' => 'prod-100', 'name' => 'Desk'],
['product_id' => 'prod-200', 'name' => 'Chair'],
]);
$keyed = $collection->keyBy('product_id');
$keyed->all();
/*
[
'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],
'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],
]
*/

You may also pass a callback to the method. The callback should return the value to key the collection by:
$keyed = $collection->keyBy(function ($item, $key) {
return strtoupper($item['product_id']);
});
$keyed->all();
/*
[
'PROD-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],
'PROD-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],
]
*/

keys()

The keys method returns all of the collection's keys:
$collection = collect([
'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],
'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],
]);
$keys = $collection->keys();
$keys->all();
// ['prod-100', 'prod-200']

last()

The last method returns the last element in the collection that passes a given truth test:

Page 367 of 1307

Laravel 9.x

collect([1, 2, 3, 4])->last(function ($value, $key) {
return $value < 3;
});
// 2

You may also call the last method with no arguments to get the last element in the collection. If the collection is empty,
null is returned:
collect([1, 2, 3, 4])->last();
// 4

lazy()

The lazy method returns a new LazyCollection instance from the underlying array of items:
$lazyCollection = collect([1, 2, 3, 4])->lazy();
get_class($lazyCollection);
// Illuminate\Support\LazyCollection
$lazyCollection->all();
// [1, 2, 3, 4]

This is especially useful when you need to perform transformations on a huge Collection that contains many items:
$count = $hugeCollection
->lazy()
->where('country', 'FR')
->where('balance', '>', '100')
->count();

By converting the collection to a LazyCollection , we avoid having to allocate a ton of additional memory. Though the
original collection still keeps its values in memory, the subsequent filters will not. Therefore, virtually no additional memory
will be allocated when filtering the collection's results.
macro()

The static macro method allows you to add methods to the Collection class at run time. Refer to the documentation
on extending collections for more information.
make()

The static make method creates a new collection instance. See the Creating Collections section.
map()

The map method iterates through the collection and passes each value to the given callback. The callback is free to
modify the item and return it, thus forming a new collection of modified items:

Page 368 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4, 5]);
$multiplied = $collection->map(function ($item, $key) {
return $item * 2;
});
$multiplied->all();
// [2, 4, 6, 8, 10]

Like most other collection methods, map returns a new collection instance; it does not modify the
collection it is called on. If you want to transform the original collection, use the transform
method.
mapInto()

The mapInto() method iterates over the collection, creating a new instance of the given class by passing the value into
the constructor:
class Currency
{
/**
* Create a new currency instance.
*
* @param

string

$code

* @return void
*/
function __construct(string $code)
{
$this->code = $code;
}
}
$collection = collect(['USD', 'EUR', 'GBP']);
$currencies = $collection->mapInto(Currency::class);
$currencies->all();
// [Currency('USD'), Currency('EUR'), Currency('GBP')]

mapSpread()

The mapSpread method iterates over the collection's items, passing each nested item value into the given closure. The
closure is free to modify the item and return it, thus forming a new collection of modified items:

Page 369 of 1307

Laravel 9.x

$collection = collect([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
$chunks = $collection->chunk(2);
$sequence = $chunks->mapSpread(function ($even, $odd) {
return $even + $odd;
});
$sequence->all();
// [1, 5, 9, 13, 17]

mapToGroups()

The mapToGroups method groups the collection's items by the given closure. The closure should return an associative
array containing a single key / value pair, thus forming a new collection of grouped values:
$collection = collect([
[
'name' => 'John Doe',
'department' => 'Sales',
],
[
'name' => 'Jane Doe',
'department' => 'Sales',
],
[
'name' => 'Johnny Doe',
'department' => 'Marketing',
]
]);
$grouped = $collection->mapToGroups(function ($item, $key) {
return [$item['department'] => $item['name']];
});
$grouped->all();
/*
[
'Sales' => ['John Doe', 'Jane Doe'],
'Marketing' => ['Johnny Doe'],
]
*/
$grouped->get('Sales')->all();
// ['John Doe', 'Jane Doe']

mapWithKeys()

The mapWithKeys method iterates through the collection and passes each value to the given callback. The callback
should return an associative array containing a single key / value pair:

Page 370 of 1307

Laravel 9.x

$collection = collect([
[
'name' => 'John',
'department' => 'Sales',
'email' => 'john@example.com',
],
[
'name' => 'Jane',
'department' => 'Marketing',
'email' => 'jane@example.com',
]
]);
$keyed = $collection->mapWithKeys(function ($item, $key) {
return [$item['email'] => $item['name']];
});
$keyed->all();
/*
[
'john@example.com' => 'John',
'jane@example.com' => 'Jane',
]
*/

max()

The max method returns the maximum value of a given key:
$max = collect([
['foo' => 10],
['foo' => 20]
])->max('foo');
// 20
$max = collect([1, 2, 3, 4, 5])->max();
// 5

median()

The median method returns the median value of a given key:

Page 371 of 1307

Laravel 9.x

$median = collect([
['foo' => 10],
['foo' => 10],
['foo' => 20],
['foo' => 40]
])->median('foo');
// 15
$median = collect([1, 1, 2, 4])->median();
// 1.5

merge()

The merge method merges the given array or collection with the original collection. If a string key in the given items
matches a string key in the original collection, the given item's value will overwrite the value in the original collection:
$collection = collect(['product_id' => 1, 'price' => 100]);
$merged = $collection->merge(['price' => 200, 'discount' => false]);
$merged->all();
// ['product_id' => 1, 'price' => 200, 'discount' => false]

If the given item's keys are numeric, the values will be appended to the end of the collection:
$collection = collect(['Desk', 'Chair']);
$merged = $collection->merge(['Bookcase', 'Door']);
$merged->all();
// ['Desk', 'Chair', 'Bookcase', 'Door']

mergeRecursive()

The mergeRecursive method merges the given array or collection recursively with the original collection. If a string key
in the given items matches a string key in the original collection, then the values for these keys are merged together into an
array, and this is done recursively:
$collection = collect(['product_id' => 1, 'price' => 100]);
$merged = $collection->mergeRecursive([
'product_id' => 2,
'price' => 200,
'discount' => false
]);
$merged->all();
// ['product_id' => [1, 2], 'price' => [100, 200], 'discount' => false]

Page 372 of 1307

Laravel 9.x

min()

The min method returns the minimum value of a given key:
$min = collect([['foo' => 10], ['foo' => 20]])->min('foo');
// 10
$min = collect([1, 2, 3, 4, 5])->min();
// 1

mode()

The mode method returns the mode value of a given key:
$mode = collect([
['foo' => 10],
['foo' => 10],
['foo' => 20],
['foo' => 40]
])->mode('foo');
// [10]
$mode = collect([1, 1, 2, 4])->mode();
// [1]
$mode = collect([1, 1, 2, 2])->mode();
// [1, 2]

nth()

The nth method creates a new collection consisting of every n-th element:
$collection = collect(['a', 'b', 'c', 'd', 'e', 'f']);
$collection->nth(4);
// ['a', 'e']

You may optionally pass a starting offset as the second argument:
$collection->nth(4, 1);
// ['b', 'f']

only()

The only method returns the items in the collection with the specified keys:

Page 373 of 1307

Laravel 9.x

$collection = collect([
'product_id' => 1,
'name' => 'Desk',
'price' => 100,
'discount' => false
]);
$filtered = $collection->only(['product_id', 'name']);
$filtered->all();
// ['product_id' => 1, 'name' => 'Desk']

For the inverse of only , see the except method.
This method's behavior is modified when using Eloquent Collections.
pad()

The pad method will fill the array with the given value until the array reaches the specified size. This method behaves like
the array_pad PHP function.
To pad to the left, you should specify a negative size. No padding will take place if the absolute value of the given size is
less than or equal to the length of the array:
$collection = collect(['A', 'B', 'C']);
$filtered = $collection->pad(5, 0);
$filtered->all();
// ['A', 'B', 'C', 0, 0]
$filtered = $collection->pad(-5, 0);
$filtered->all();
// [0, 0, 'A', 'B', 'C']

partition()

The partition method may be combined with PHP array destructuring to separate elements that pass a given truth test
from those that do not:

Page 374 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4, 5, 6]);
[$underThree, $equalOrAboveThree] = $collection->partition(function ($i) {
return $i < 3;
});
$underThree->all();
// [1, 2]
$equalOrAboveThree->all();
// [3, 4, 5, 6]

pipe()

The pipe method passes the collection to the given closure and returns the result of the executed closure:
$collection = collect([1, 2, 3]);
$piped = $collection->pipe(function ($collection) {
return $collection->sum();
});
// 6

pipeInto()

The pipeInto method creates a new instance of the given class and passes the collection into the constructor:

Page 375 of 1307

Laravel 9.x

class ResourceCollection
{
/**
* The Collection instance.
*/
public $collection;
/**
* Create a new ResourceCollection instance.
*
* @param

Collection

$collection

* @return void
*/
public function __construct(Collection $collection)
{
$this->collection = $collection;
}
}
$collection = collect([1, 2, 3]);
$resource = $collection->pipeInto(ResourceCollection::class);
$resource->collection->all();
// [1, 2, 3]

pipeThrough()

The pipeThrough method passes the collection to the given array of closures and returns the result of the executed
closures:
$collection = collect([1, 2, 3]);
$result = $collection->pipeThrough([
function ($collection) {
return $collection->merge([4, 5]);
},
function ($collection) {
return $collection->sum();
},
]);
// 15

pluck()

The pluck method retrieves all of the values for a given key:

Page 376 of 1307

Laravel 9.x

$collection = collect([
['product_id' => 'prod-100', 'name' => 'Desk'],
['product_id' => 'prod-200', 'name' => 'Chair'],
]);
$plucked = $collection->pluck('name');
$plucked->all();
// ['Desk', 'Chair']

You may also specify how you wish the resulting collection to be keyed:
$plucked = $collection->pluck('name', 'product_id');
$plucked->all();
// ['prod-100' => 'Desk', 'prod-200' => 'Chair']

The pluck method also supports retrieving nested values using "dot" notation:
$collection = collect([
[
'name' => 'Laracon',
'speakers' => [
'first_day' => ['Rosa', 'Judith'],
],
],
[
'name' => 'VueConf',
'speakers' => [
'first_day' => ['Abigail', 'Joey'],
],
],
]);
$plucked = $collection->pluck('speakers.first_day');
$plucked->all();
// [['Rosa', 'Judith'], ['Abigail', 'Joey']]

If duplicate keys exist, the last matching element will be inserted into the plucked collection:

Page 377 of 1307

Laravel 9.x

$collection = collect([
['brand' => 'Tesla',

'color' => 'red'],

['brand' => 'Pagani', 'color' => 'white'],
['brand' => 'Tesla',

'color' => 'black'],

['brand' => 'Pagani', 'color' => 'orange'],
]);
$plucked = $collection->pluck('color', 'brand');
$plucked->all();
// ['Tesla' => 'black', 'Pagani' => 'orange']

pop()

The pop method removes and returns the last item from the collection:
$collection = collect([1, 2, 3, 4, 5]);
$collection->pop();
// 5
$collection->all();
// [1, 2, 3, 4]

You may pass an integer to the pop method to remove and return multiple items from the end of a collection:
$collection = collect([1, 2, 3, 4, 5]);
$collection->pop(3);
// collect([5, 4, 3])
$collection->all();
// [1, 2]

prepend()

The prepend method adds an item to the beginning of the collection:
$collection = collect([1, 2, 3, 4, 5]);
$collection->prepend(0);
$collection->all();
// [0, 1, 2, 3, 4, 5]

You may also pass a second argument to specify the key of the prepended item:

Page 378 of 1307

Laravel 9.x

$collection = collect(['one' => 1, 'two' => 2]);
$collection->prepend(0, 'zero');
$collection->all();
// ['zero' => 0, 'one' => 1, 'two' => 2]

pull()

The pull method removes and returns an item from the collection by its key:
$collection = collect(['product_id' => 'prod-100', 'name' => 'Desk']);
$collection->pull('name');
// 'Desk'
$collection->all();
// ['product_id' => 'prod-100']

push()

The push method appends an item to the end of the collection:
$collection = collect([1, 2, 3, 4]);
$collection->push(5);
$collection->all();
// [1, 2, 3, 4, 5]

put()

The put method sets the given key and value in the collection:
$collection = collect(['product_id' => 1, 'name' => 'Desk']);
$collection->put('price', 100);
$collection->all();
// ['product_id' => 1, 'name' => 'Desk', 'price' => 100]

random()

The random method returns a random item from the collection:

Page 379 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4, 5]);
$collection->random();
// 4 - (retrieved randomly)

You may pass an integer to random to specify how many items you would like to randomly retrieve. A collection of items
is always returned when explicitly passing the number of items you wish to receive:
$random = $collection->random(3);
$random->all();
// [2, 4, 5] - (retrieved randomly)

If the collection instance has fewer items than requested, the random method will throw an
InvalidArgumentException .
The random method also accepts a closure, which will receive the current collection instance:
$random = $collection->random(fn ($items) => min(10, count($items)));
$random->all();
// [1, 2, 3, 4, 5] - (retrieved randomly)

range()

The range method returns a collection containing integers between the specified range:
$collection = collect()->range(3, 6);
$collection->all();
// [3, 4, 5, 6]

reduce()

The reduce method reduces the collection to a single value, passing the result of each iteration into the subsequent
iteration:
$collection = collect([1, 2, 3]);
$total = $collection->reduce(function ($carry, $item) {
return $carry + $item;
});
// 6

The value for $carry on the first iteration is null ; however, you may specify its initial value by passing a second
argument to reduce :

Page 380 of 1307

Laravel 9.x

$collection->reduce(function ($carry, $item) {
return $carry + $item;
}, 4);
// 10

The reduce method also passes array keys in associative collections to the given callback:
$collection = collect([
'usd' => 1400,
'gbp' => 1200,
'eur' => 1000,
]);
$ratio = [
'usd' => 1,
'gbp' => 1.37,
'eur' => 1.22,
];
$collection->reduce(function ($carry, $value, $key) use ($ratio) {
return $carry + ($value * $ratio[$key]);
});
// 4264

reduceSpread()

The reduceSpread method reduces the collection to an array of values, passing the results of each iteration into the
subsequent iteration. This method is similar to the reduce method; however, it can accept multiple initial values:
[$creditsRemaining, $batch] = Image::where('status', 'unprocessed')
->get()
->reduceSpread(function ($creditsRemaining, $batch, $image) {
if ($creditsRemaining >= $image->creditsRequired()) {
$batch->push($image);
$creditsRemaining -= $image->creditsRequired();
}
return [$creditsRemaining, $batch];
}, $creditsAvailable, collect());

reject()

The reject method filters the collection using the given closure. The closure should return true if the item should be
removed from the resulting collection:

Page 381 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4]);
$filtered = $collection->reject(function ($value, $key) {
return $value > 2;
});
$filtered->all();
// [1, 2]

For the inverse of the reject method, see the filter method.
replace()

The replace method behaves similarly to merge ; however, in addition to overwriting matching items that have string
keys, the replace method will also overwrite items in the collection that have matching numeric keys:
$collection = collect(['Taylor', 'Abigail', 'James']);
$replaced = $collection->replace([1 => 'Victoria', 3 => 'Finn']);
$replaced->all();
// ['Taylor', 'Victoria', 'James', 'Finn']

replaceRecursive()

This method works like replace , but it will recur into arrays and apply the same replacement process to the inner values:
$collection = collect([
'Taylor',
'Abigail',
[
'James',
'Victoria',
'Finn'
]
]);
$replaced = $collection->replaceRecursive([
'Charlie',
2 => [1 => 'King']
]);
$replaced->all();
// ['Charlie', 'Abigail', ['James', 'King', 'Finn']]

reverse()

The reverse method reverses the order of the collection's items, preserving the original keys:

Page 382 of 1307

Laravel 9.x

$collection = collect(['a', 'b', 'c', 'd', 'e']);
$reversed = $collection->reverse();
$reversed->all();
/*
[
4 => 'e',
3 => 'd',
2 => 'c',
1 => 'b',
0 => 'a',
]
*/

search()

The search method searches the collection for the given value and returns its key if found. If the item is not found,
false is returned:
$collection = collect([2, 4, 6, 8]);
$collection->search(4);
// 1

The search is done using a "loose" comparison, meaning a string with an integer value will be considered equal to an
integer of the same value. To use "strict" comparison, pass true as the second argument to the method:
collect([2, 4, 6, 8])->search('4', $strict = true);
// false

Alternatively, you may provide your own closure to search for the first item that passes a given truth test:
collect([2, 4, 6, 8])->search(function ($item, $key) {
return $item > 5;
});
// 2

shift()

The shift method removes and returns the first item from the collection:

Page 383 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4, 5]);
$collection->shift();
// 1
$collection->all();
// [2, 3, 4, 5]

You may pass an integer to the shift method to remove and return multiple items from the beginning of a collection:
$collection = collect([1, 2, 3, 4, 5]);
$collection->shift(3);
// collect([1, 2, 3])
$collection->all();
// [4, 5]

shuffle()

The shuffle method randomly shuffles the items in the collection:
$collection = collect([1, 2, 3, 4, 5]);
$shuffled = $collection->shuffle();
$shuffled->all();
// [3, 2, 5, 1, 4] - (generated randomly)

skip()

The skip method returns a new collection, with the given number of elements removed from the beginning of the
collection:
$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
$collection = $collection->skip(4);
$collection->all();
// [5, 6, 7, 8, 9, 10]

skipUntil()

The skipUntil method skips over items from the collection until the given callback returns true and then returns the
remaining items in the collection as a new collection instance:

Page 384 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4]);
$subset = $collection->skipUntil(function ($item) {
return $item >= 3;
});
$subset->all();
// [3, 4]

You may also pass a simple value to the skipUntil method to skip all items until the given value is found:
$collection = collect([1, 2, 3, 4]);
$subset = $collection->skipUntil(3);
$subset->all();
// [3, 4]

If the given value is not found or the callback never returns true , the skipUntil method will
return an empty collection.
skipWhile()

The skipWhile method skips over items from the collection while the given callback returns true and then returns the
remaining items in the collection as a new collection:
$collection = collect([1, 2, 3, 4]);
$subset = $collection->skipWhile(function ($item) {
return $item <= 3;
});
$subset->all();
// [4]

If the callback never returns false , the skipWhile method will return an empty collection.
slice()

The slice method returns a slice of the collection starting at the given index:

Page 385 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
$slice = $collection->slice(4);
$slice->all();
// [5, 6, 7, 8, 9, 10]

If you would like to limit the size of the returned slice, pass the desired size as the second argument to the method:
$slice = $collection->slice(4, 2);
$slice->all();
// [5, 6]

The returned slice will preserve keys by default. If you do not wish to preserve the original keys, you can use the values
method to reindex them.
sliding()

The sliding method returns a new collection of chunks representing a "sliding window" view of the items in the
collection:
$collection = collect([1, 2, 3, 4, 5]);
$chunks = $collection->sliding(2);
$chunks->toArray();
// [[1, 2], [2, 3], [3, 4], [4, 5]]

This is especially useful in conjunction with the eachSpread method:
$transactions->sliding(2)->eachSpread(function ($previous, $current) {
$current->total = $previous->total + $current->amount;
});

You may optionally pass a second "step" value, which determines the distance between the first item of every chunk:
$collection = collect([1, 2, 3, 4, 5]);
$chunks = $collection->sliding(3, step: 2);
$chunks->toArray();
// [[1, 2, 3], [3, 4, 5]]

sole()

The sole method returns the first element in the collection that passes a given truth test, but only if the truth test
matches exactly one element:

Page 386 of 1307

Laravel 9.x

collect([1, 2, 3, 4])->sole(function ($value, $key) {
return $value === 2;
});
// 2

You may also pass a key / value pair to the sole method, which will return the first element in the collection that matches
the given pair, but only if it exactly one element matches:
$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 100],
]);
$collection->sole('product', 'Chair');
// ['product' => 'Chair', 'price' => 100]

Alternatively, you may also call the sole method with no argument to get the first element in the collection if there is only
one element:
$collection = collect([
['product' => 'Desk', 'price' => 200],
]);
$collection->sole();
// ['product' => 'Desk', 'price' => 200]

If there are no elements in the collection that should be returned by the sole method, an
\Illuminate\Collections\ItemNotFoundException exception will be thrown. If there is more than one element that
should be returned, an \Illuminate\Collections\MultipleItemsFoundException will be thrown.
some()

Alias for the contains method.
sort()

The sort method sorts the collection. The sorted collection keeps the original array keys, so in the following example we
will use the values method to reset the keys to consecutively numbered indexes:
$collection = collect([5, 3, 1, 2, 4]);
$sorted = $collection->sort();
$sorted->values()->all();
// [1, 2, 3, 4, 5]

If your sorting needs are more advanced, you may pass a callback to sort with your own algorithm. Refer to the PHP
documentation on uasort , which is what the collection's sort method calls utilizes internally.

Page 387 of 1307

Laravel 9.x

If you need to sort a collection of nested arrays or objects, see the sortBy and sortByDesc
methods.
sortBy()

The sortBy method sorts the collection by the given key. The sorted collection keeps the original array keys, so in the
following example we will use the values method to reset the keys to consecutively numbered indexes:
$collection = collect([
['name' => 'Desk', 'price' => 200],
['name' => 'Chair', 'price' => 100],
['name' => 'Bookcase', 'price' => 150],
]);
$sorted = $collection->sortBy('price');
$sorted->values()->all();
/*
[
['name' => 'Chair', 'price' => 100],
['name' => 'Bookcase', 'price' => 150],
['name' => 'Desk', 'price' => 200],
]
*/

The sortBy method accepts sort flags as its second argument:
$collection = collect([
['title' => 'Item 1'],
['title' => 'Item 12'],
['title' => 'Item 3'],
]);
$sorted = $collection->sortBy('title', SORT_NATURAL);
$sorted->values()->all();
/*
[
['title' => 'Item 1'],
['title' => 'Item 3'],
['title' => 'Item 12'],
]
*/

Alternatively, you may pass your own closure to determine how to sort the collection's values:

Page 388 of 1307

Laravel 9.x

$collection = collect([
['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],
['name' => 'Chair', 'colors' => ['Black']],
['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],
]);
$sorted = $collection->sortBy(function ($product, $key) {
return count($product['colors']);
});
$sorted->values()->all();
/*
[
['name' => 'Chair', 'colors' => ['Black']],
['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],
['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],
]
*/

If you would like to sort your collection by multiple attributes, you may pass an array of sort operations to the sortBy
method. Each sort operation should be an array consisting of the attribute that you wish to sort by and the direction of the
desired sort:
$collection = collect([
['name' => 'Taylor Otwell', 'age' => 34],
['name' => 'Abigail Otwell', 'age' => 30],
['name' => 'Taylor Otwell', 'age' => 36],
['name' => 'Abigail Otwell', 'age' => 32],
]);
$sorted = $collection->sortBy([
['name', 'asc'],
['age', 'desc'],
]);
$sorted->values()->all();
/*
[
['name' => 'Abigail Otwell', 'age' => 32],
['name' => 'Abigail Otwell', 'age' => 30],
['name' => 'Taylor Otwell', 'age' => 36],
['name' => 'Taylor Otwell', 'age' => 34],
]
*/

When sorting a collection by multiple attributes, you may also provide closures that define each sort operation:

Page 389 of 1307

Laravel 9.x

$collection = collect([
['name' => 'Taylor Otwell', 'age' => 34],
['name' => 'Abigail Otwell', 'age' => 30],
['name' => 'Taylor Otwell', 'age' => 36],
['name' => 'Abigail Otwell', 'age' => 32],
]);
$sorted = $collection->sortBy([
fn ($a, $b) => $a['name'] <=> $b['name'],
fn ($a, $b) => $b['age'] <=> $a['age'],
]);
$sorted->values()->all();
/*
[
['name' => 'Abigail Otwell', 'age' => 32],
['name' => 'Abigail Otwell', 'age' => 30],
['name' => 'Taylor Otwell', 'age' => 36],
['name' => 'Taylor Otwell', 'age' => 34],
]
*/

sortByDesc()

This method has the same signature as the sortBy method, but will sort the collection in the opposite order.
sortDesc()

This method will sort the collection in the opposite order as the sort method:
$collection = collect([5, 3, 1, 2, 4]);
$sorted = $collection->sortDesc();
$sorted->values()->all();
// [5, 4, 3, 2, 1]

Unlike sort , you may not pass a closure to sortDesc . Instead, you should use the sort method and invert your
comparison.
sortKeys()

The sortKeys method sorts the collection by the keys of the underlying associative array:

Page 390 of 1307

Laravel 9.x

$collection = collect([
'id' => 22345,
'first' => 'John',
'last' => 'Doe',
]);
$sorted = $collection->sortKeys();
$sorted->all();
/*
[
'first' => 'John',
'id' => 22345,
'last' => 'Doe',
]
*/

sortKeysDesc()

This method has the same signature as the sortKeys method, but will sort the collection in the opposite order.
sortKeysUsing()

The sortKeysUsing method sorts the collection by the keys of the underlying associative array using a callback:
$collection = collect([
'ID' => 22345,
'first' => 'John',
'last' => 'Doe',
]);
$sorted = $collection->sortKeysUsing('strnatcasecmp');
$sorted->all();
/*
[
'first' => 'John',
'ID' => 22345,
'last' => 'Doe',
]
*/

The callback must be a comparison function that returns an integer less than, equal to, or greater than zero. For more
information, refer to the PHP documentation on uksort , which is the PHP function that sortKeysUsing method utilizes
internally.
splice()

The splice method removes and returns a slice of items starting at the specified index:

Page 391 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4, 5]);
$chunk = $collection->splice(2);
$chunk->all();
// [3, 4, 5]
$collection->all();
// [1, 2]

You may pass a second argument to limit the size of the resulting collection:
$collection = collect([1, 2, 3, 4, 5]);
$chunk = $collection->splice(2, 1);
$chunk->all();
// [3]
$collection->all();
// [1, 2, 4, 5]

In addition, you may pass a third argument containing the new items to replace the items removed from the collection:
$collection = collect([1, 2, 3, 4, 5]);
$chunk = $collection->splice(2, 1, [10, 11]);
$chunk->all();
// [3]
$collection->all();
// [1, 2, 10, 11, 4, 5]

split()

The split method breaks a collection into the given number of groups:
$collection = collect([1, 2, 3, 4, 5]);
$groups = $collection->split(3);
$groups->all();
// [[1, 2], [3, 4], [5]]

splitIn()

Page 392 of 1307

Laravel 9.x

The splitIn method breaks a collection into the given number of groups, filling non-terminal groups completely before
allocating the remainder to the final group:
$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
$groups = $collection->splitIn(3);
$groups->all();
// [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]

sum()

The sum method returns the sum of all items in the collection:
collect([1, 2, 3, 4, 5])->sum();
// 15

If the collection contains nested arrays or objects, you should pass a key that will be used to determine which values to
sum:
$collection = collect([
['name' => 'JavaScript: The Good Parts', 'pages' => 176],
['name' => 'JavaScript: The Definitive Guide', 'pages' => 1096],
]);
$collection->sum('pages');
// 1272

In addition, you may pass your own closure to determine which values of the collection to sum:
$collection = collect([
['name' => 'Chair', 'colors' => ['Black']],
['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],
['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],
]);
$collection->sum(function ($product) {
return count($product['colors']);
});
// 6

take()

The take method returns a new collection with the specified number of items:

Page 393 of 1307

Laravel 9.x

$collection = collect([0, 1, 2, 3, 4, 5]);
$chunk = $collection->take(3);
$chunk->all();
// [0, 1, 2]

You may also pass a negative integer to take the specified number of items from the end of the collection:
$collection = collect([0, 1, 2, 3, 4, 5]);
$chunk = $collection->take(-2);
$chunk->all();
// [4, 5]

takeUntil()

The takeUntil method returns items in the collection until the given callback returns true :
$collection = collect([1, 2, 3, 4]);
$subset = $collection->takeUntil(function ($item) {
return $item >= 3;
});
$subset->all();
// [1, 2]

You may also pass a simple value to the takeUntil method to get the items until the given value is found:
$collection = collect([1, 2, 3, 4]);
$subset = $collection->takeUntil(3);
$subset->all();
// [1, 2]

If the given value is not found or the callback never returns true , the takeUntil method will
return all items in the collection.
takeWhile()

The takeWhile method returns items in the collection until the given callback returns false :

Page 394 of 1307

Laravel 9.x

$collection = collect([1, 2, 3, 4]);
$subset = $collection->takeWhile(function ($item) {
return $item < 3;
});
$subset->all();
// [1, 2]

If the callback never returns false , the takeWhile method will return all items in the collection.
tap()

The tap method passes the collection to the given callback, allowing you to "tap" into the collection at a specific point
and do something with the items while not affecting the collection itself. The collection is then returned by the tap
method:
collect([2, 4, 3, 1, 5])
->sort()
->tap(function ($collection) {
Log::debug('Values after sorting', $collection->values()->all());
})
->shift();
// 1

times()

The static times method creates a new collection by invoking the given closure a specified number of times:
$collection = Collection::times(10, function ($number) {
return $number * 9;
});
$collection->all();
// [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]

toArray()

The toArray method converts the collection into a plain PHP array . If the collection's values are Eloquent models, the
models will also be converted to arrays:

Page 395 of 1307

Laravel 9.x

$collection = collect(['name' => 'Desk', 'price' => 200]);
$collection->toArray();
/*
[
['name' => 'Desk', 'price' => 200],
]
*/

toArray also converts all of the collection's nested objects that are an instance of Arrayable
to an array. If you want to get the raw array underlying the collection, use the all method
instead.

toJson()

The toJson method converts the collection into a JSON serialized string:
$collection = collect(['name' => 'Desk', 'price' => 200]);
$collection->toJson();
// '{"name":"Desk", "price":200}'

transform()

The transform method iterates over the collection and calls the given callback with each item in the collection. The
items in the collection will be replaced by the values returned by the callback:
$collection = collect([1, 2, 3, 4, 5]);
$collection->transform(function ($item, $key) {
return $item * 2;
});
$collection->all();
// [2, 4, 6, 8, 10]

Unlike most other collection methods, transform modifies the collection itself. If you wish to
create a new collection instead, use the map method.
undot()

The undot method expands a single-dimensional collection that uses "dot" notation into a multi-dimensional collection:

Page 396 of 1307

Laravel 9.x

$person = collect([
'name.first_name' => 'Marie',
'name.last_name' => 'Valentine',
'address.line_1' => '2992 Eagle Drive',
'address.line_2' => '',
'address.suburb' => 'Detroit',
'address.state' => 'MI',
'address.postcode' => '48219'
]);
$person = $person->undot();
$person->toArray();
/*
[
"name" => [
"first_name" => "Marie",
"last_name" => "Valentine",
],
"address" => [
"line_1" => "2992 Eagle Drive",
"line_2" => "",
"suburb" => "Detroit",
"state" => "MI",
"postcode" => "48219",
],
]
*/

union()

The union method adds the given array to the collection. If the given array contains keys that are already in the original
collection, the original collection's values will be preferred:
$collection = collect([1 => ['a'], 2 => ['b']]);
$union = $collection->union([3 => ['c'], 1 => ['d']]);
$union->all();
// [1 => ['a'], 2 => ['b'], 3 => ['c']]

unique()

The unique method returns all of the unique items in the collection. The returned collection keeps the original array
keys, so in the following example we will use the values method to reset the keys to consecutively numbered indexes:

Page 397 of 1307

Laravel 9.x

$collection = collect([1, 1, 2, 2, 3, 4, 2]);
$unique = $collection->unique();
$unique->values()->all();
// [1, 2, 3, 4]

When dealing with nested arrays or objects, you may specify the key used to determine uniqueness:
$collection = collect([
['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],
['name' => 'iPhone 5', 'brand' => 'Apple', 'type' => 'phone'],
['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'],
['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],
['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'],
]);
$unique = $collection->unique('brand');
$unique->values()->all();
/*
[
['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],
['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],
]
*/

Finally, you may also pass your own closure to the unique method to specify which value should determine an item's
uniqueness:
$unique = $collection->unique(function ($item) {
return $item['brand'].$item['type'];
});
$unique->values()->all();
/*
[
['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],
['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'],
['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],
['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'],
]
*/

The unique method uses "loose" comparisons when checking item values, meaning a string with an integer value will be
considered equal to an integer of the same value. Use the uniqueStrict method to filter using "strict" comparisons.
This method's behavior is modified when using Eloquent Collections.

Page 398 of 1307

Laravel 9.x

uniqueStrict()

This method has the same signature as the unique method; however, all values are compared using "strict"
comparisons.
unless()

The unless method will execute the given callback unless the first argument given to the method evaluates to true :
$collection = collect([1, 2, 3]);
$collection->unless(true, function ($collection) {
return $collection->push(4);
});
$collection->unless(false, function ($collection) {
return $collection->push(5);
});
$collection->all();
// [1, 2, 3, 5]

A second callback may be passed to the unless method. The second callback will be executed when the first argument
given to the unless method evaluates to true :
$collection = collect([1, 2, 3]);
$collection->unless(true, function ($collection) {
return $collection->push(4);
}, function ($collection) {
return $collection->push(5);
});
$collection->all();
// [1, 2, 3, 5]

For the inverse of unless , see the when method.
unlessEmpty()

Alias for the whenNotEmpty method.
unlessNotEmpty()

Alias for the whenEmpty method.
unwrap()

The static unwrap method returns the collection's underlying items from the given value when applicable:

Page 399 of 1307

Laravel 9.x

Collection::unwrap(collect('John Doe'));
// ['John Doe']
Collection::unwrap(['John Doe']);
// ['John Doe']
Collection::unwrap('John Doe');
// 'John Doe'

value()

The value method retrieves a given value from the first element of the collection:
$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Speaker', 'price' => 400],
]);
$value = $collection->value('price');
// 200

values()

The values method returns a new collection with the keys reset to consecutive integers:
$collection = collect([
10 => ['product' => 'Desk', 'price' => 200],
11 => ['product' => 'Desk', 'price' => 200],
]);
$values = $collection->values();
$values->all();
/*
[
0 => ['product' => 'Desk', 'price' => 200],
1 => ['product' => 'Desk', 'price' => 200],
]
*/

when()

The when method will execute the given callback when the first argument given to the method evaluates to true . The
collection instance and the first argument given to the when method will be provided to the closure:

Page 400 of 1307

Laravel 9.x

$collection = collect([1, 2, 3]);
$collection->when(true, function ($collection, $value) {
return $collection->push(4);
});
$collection->when(false, function ($collection, $value) {
return $collection->push(5);
});
$collection->all();
// [1, 2, 3, 4]

A second callback may be passed to the when method. The second callback will be executed when the first argument
given to the when method evaluates to false :
$collection = collect([1, 2, 3]);
$collection->when(false, function ($collection, $value) {
return $collection->push(4);
}, function ($collection) {
return $collection->push(5);
});
$collection->all();
// [1, 2, 3, 5]

For the inverse of when , see the unless method.
whenEmpty()

The whenEmpty method will execute the given callback when the collection is empty:

Page 401 of 1307

Laravel 9.x

$collection = collect(['Michael', 'Tom']);
$collection->whenEmpty(function ($collection) {
return $collection->push('Adam');
});
$collection->all();
// ['Michael', 'Tom']

$collection = collect();
$collection->whenEmpty(function ($collection) {
return $collection->push('Adam');
});
$collection->all();
// ['Adam']

A second closure may be passed to the whenEmpty method that will be executed when the collection is not empty:
$collection = collect(['Michael', 'Tom']);
$collection->whenEmpty(function ($collection) {
return $collection->push('Adam');
}, function ($collection) {
return $collection->push('Taylor');
});
$collection->all();
// ['Michael', 'Tom', 'Taylor']

For the inverse of whenEmpty , see the whenNotEmpty method.
whenNotEmpty()

The whenNotEmpty method will execute the given callback when the collection is not empty:

Page 402 of 1307

Laravel 9.x

$collection = collect(['michael', 'tom']);
$collection->whenNotEmpty(function ($collection) {
return $collection->push('adam');
});
$collection->all();
// ['michael', 'tom', 'adam']

$collection = collect();
$collection->whenNotEmpty(function ($collection) {
return $collection->push('adam');
});
$collection->all();
// []

A second closure may be passed to the whenNotEmpty method that will be executed when the collection is empty:
$collection = collect();
$collection->whenNotEmpty(function ($collection) {
return $collection->push('adam');
}, function ($collection) {
return $collection->push('taylor');
});
$collection->all();
// ['taylor']

For the inverse of whenNotEmpty , see the whenEmpty method.
where()

The where method filters the collection by a given key / value pair:

Page 403 of 1307

Laravel 9.x

$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 100],
['product' => 'Bookcase', 'price' => 150],
['product' => 'Door', 'price' => 100],
]);
$filtered = $collection->where('price', 100);
$filtered->all();
/*
[
['product' => 'Chair', 'price' => 100],
['product' => 'Door', 'price' => 100],
]
*/

The where method uses "loose" comparisons when checking item values, meaning a string with an integer value will be
considered equal to an integer of the same value. Use the whereStrict method to filter using "strict" comparisons.
Optionally, you may pass a comparison operator as the second parameter. Supported operators are: '===', '!==', '!=', '==',
'=', '<>', '>', '<', '>=', and '<=':
$collection = collect([
['name' => 'Jim', 'deleted_at' => '2019-01-01 00:00:00'],
['name' => 'Sally', 'deleted_at' => '2019-01-02 00:00:00'],
['name' => 'Sue', 'deleted_at' => null],
]);
$filtered = $collection->where('deleted_at', '!=', null);
$filtered->all();
/*
[
['name' => 'Jim', 'deleted_at' => '2019-01-01 00:00:00'],
['name' => 'Sally', 'deleted_at' => '2019-01-02 00:00:00'],
]
*/

whereStrict()

This method has the same signature as the where method; however, all values are compared using "strict" comparisons.
whereBetween()

The whereBetween method filters the collection by determining if a specified item value is within a given range:

Page 404 of 1307

Laravel 9.x

$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 80],
['product' => 'Bookcase', 'price' => 150],
['product' => 'Pencil', 'price' => 30],
['product' => 'Door', 'price' => 100],
]);
$filtered = $collection->whereBetween('price', [100, 200]);
$filtered->all();
/*
[
['product' => 'Desk', 'price' => 200],
['product' => 'Bookcase', 'price' => 150],
['product' => 'Door', 'price' => 100],
]
*/

whereIn()

The whereIn method removes elements from the collection that do not have a specified item value that is contained
within the given array:
$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 100],
['product' => 'Bookcase', 'price' => 150],
['product' => 'Door', 'price' => 100],
]);
$filtered = $collection->whereIn('price', [150, 200]);
$filtered->all();
/*
[
['product' => 'Desk', 'price' => 200],
['product' => 'Bookcase', 'price' => 150],
]
*/

The whereIn method uses "loose" comparisons when checking item values, meaning a string with an integer value will
be considered equal to an integer of the same value. Use the whereInStrict method to filter using "strict"
comparisons.
whereInStrict()

This method has the same signature as the whereIn method; however, all values are compared using "strict"
comparisons.
whereInstanceOf()

The whereInstanceOf method filters the collection by a given class type:

Page 405 of 1307

Laravel 9.x

use App\Models\User;
use App\Models\Post;
$collection = collect([
new User,
new User,
new Post,
]);
$filtered = $collection->whereInstanceOf(User::class);
$filtered->all();
// [App\Models\User, App\Models\User]

whereNotBetween()

The whereNotBetween method filters the collection by determining if a specified item value is outside of a given range:
$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 80],
['product' => 'Bookcase', 'price' => 150],
['product' => 'Pencil', 'price' => 30],
['product' => 'Door', 'price' => 100],
]);
$filtered = $collection->whereNotBetween('price', [100, 200]);
$filtered->all();
/*
[
['product' => 'Chair', 'price' => 80],
['product' => 'Pencil', 'price' => 30],
]
*/

whereNotIn()

The whereNotIn method removes elements from the collection that have a specified item value that is contained within
the given array:

Page 406 of 1307

Laravel 9.x

$collection = collect([
['product' => 'Desk', 'price' => 200],
['product' => 'Chair', 'price' => 100],
['product' => 'Bookcase', 'price' => 150],
['product' => 'Door', 'price' => 100],
]);
$filtered = $collection->whereNotIn('price', [150, 200]);
$filtered->all();
/*
[
['product' => 'Chair', 'price' => 100],
['product' => 'Door', 'price' => 100],
]
*/

The whereNotIn method uses "loose" comparisons when checking item values, meaning a string with an integer value
will be considered equal to an integer of the same value. Use the whereNotInStrict method to filter using "strict"
comparisons.
whereNotInStrict()

This method has the same signature as the whereNotIn method; however, all values are compared using "strict"
comparisons.
whereNotNull()

The whereNotNull method returns items from the collection where the given key is not null :
$collection = collect([
['name' => 'Desk'],
['name' => null],
['name' => 'Bookcase'],
]);
$filtered = $collection->whereNotNull('name');
$filtered->all();
/*
[
['name' => 'Desk'],
['name' => 'Bookcase'],
]
*/

whereNull()

The whereNull method returns items from the collection where the given key is null :

Page 407 of 1307

Laravel 9.x

$collection = collect([
['name' => 'Desk'],
['name' => null],
['name' => 'Bookcase'],
]);
$filtered = $collection->whereNull('name');
$filtered->all();
/*
[
['name' => null],
]
*/

wrap()

The static wrap method wraps the given value in a collection when applicable:
use Illuminate\Support\Collection;
$collection = Collection::wrap('John Doe');
$collection->all();
// ['John Doe']
$collection = Collection::wrap(['John Doe']);
$collection->all();
// ['John Doe']
$collection = Collection::wrap(collect('John Doe'));
$collection->all();
// ['John Doe']

zip()

The zip method merges together the values of the given array with the values of the original collection at their
corresponding index:
$collection = collect(['Chair', 'Desk']);
$zipped = $collection->zip([100, 200]);
$zipped->all();
// [['Chair', 100], ['Desk', 200]]

Higher Order Messages
Page 408 of 1307

Laravel 9.x

Collections also provide support for "higher order messages", which are short-cuts for performing common actions on
collections. The collection methods that provide higher order messages are: average , avg , contains , each ,
every , filter , first , flatMap , groupBy , keyBy , map , max , min , partition , reject , skipUntil ,
skipWhile , some , sortBy , sortByDesc , sum , takeUntil , takeWhile , and unique .
Each higher order message can be accessed as a dynamic property on a collection instance. For instance, let's use the
each higher order message to call a method on each object within a collection:
use App\Models\User;
$users = User::where('votes', '>', 500)->get();
$users->each->markAsVip();

Likewise, we can use the sum higher order message to gather the total number of "votes" for a collection of users:
$users = User::where('group', 'Development')->get();
return $users->sum->votes;

Lazy Collections
Introduction

Before learning more about Laravel's lazy collections, take some time to familiarize yourself with
PHP generators.
To supplement the already powerful Collection class, the LazyCollection class leverages PHP's generators to allow
you to work with very large datasets while keeping memory usage low.
For example, imagine your application needs to process a multi-gigabyte log file while taking advantage of Laravel's
collection methods to parse the logs. Instead of reading the entire file into memory at once, lazy collections may be used
to keep only a small part of the file in memory at a given time:
use App\Models\LogEntry;
use Illuminate\Support\LazyCollection;
LazyCollection::make(function () {
$handle = fopen('log.txt', 'r');
while (($line = fgets($handle)) !== false) {
yield $line;
}
})->chunk(4)->map(function ($lines) {
return LogEntry::fromLines($lines);
})->each(function (LogEntry $logEntry) {
// Process the log entry...
});

Or, imagine you need to iterate through 10,000 Eloquent models. When using traditional Laravel collections, all 10,000
Eloquent models must be loaded into memory at the same time:
Page 409 of 1307

Laravel 9.x

use App\Models\User;
$users = User::all()->filter(function ($user) {
return $user->id > 500;
});

However, the query builder's cursor method returns a LazyCollection instance. This allows you to still only run a
single query against the database but also only keep one Eloquent model loaded in memory at a time. In this example, the
filter callback is not executed until we actually iterate over each user individually, allowing for a drastic reduction in
memory usage:
use App\Models\User;
$users = User::cursor()->filter(function ($user) {
return $user->id > 500;
});
foreach ($users as $user) {
echo $user->id;
}

Creating Lazy Collections

To create a lazy collection instance, you should pass a PHP generator function to the collection's make method:
use Illuminate\Support\LazyCollection;
LazyCollection::make(function () {
$handle = fopen('log.txt', 'r');
while (($line = fgets($handle)) !== false) {
yield $line;
}
});

The Enumerable Contract

Almost all methods available on the Collection class are also available on the LazyCollection class. Both of these
classes implement the Illuminate\Support\Enumerable contract, which defines the following methods:
all
dd
firstWhere
average
diff
flatMap
avg
diffAssoc
flatten
chunk
diffKeys
flip
chunkWhile
dump
forPage
collapse
duplicates
get
collect
duplicatesStrict
groupBy
combine
each
has
concat
eachSpread
implode
contains
every
intersect
containsStrict
except
intersectByKeys
count
filter
isEmpty
countBy
first
isNotEmpty
crossJoin
firstOrFail
join
Page 410 of 1307

Laravel 9.x

keyBy
keys
last
macro
make
map
mapInto
mapSpread
mapToGroups
mapWithKeys
max
median
merge
mergeRecursive
min
mode
nth
only
pad
partition
pipe
pluck
random

reduce
reject
replace
replaceRecursive
reverse
search
shuffle
skip
slice
sole
some
sort
sortBy
sortByDesc
sortKeys
sortKeysDesc
split
sum
take
tap
times
toArray
toJson

union
unique
uniqueStrict
unless
unlessEmpty
unlessNotEmpty
unwrap
values
when
whenEmpty
whenNotEmpty
where
whereStrict
whereBetween
whereIn
whereInStrict
whereInstanceOf
whereNotBetween
whereNotIn
whereNotInStrict
wrap
zip

Methods that mutate the collection (such as shift , pop , prepend etc.) are not available on
the LazyCollection class.

Lazy Collection Methods

In addition to the methods defined in the Enumerable contract, the LazyCollection class contains the following
methods:
takeUntilTimeout()

The takeUntilTimeout method returns a new lazy collection that will enumerate values until the specified time. After
that time, the collection will then stop enumerating:
$lazyCollection = LazyCollection::times(INF)
->takeUntilTimeout(now()->addMinute());
$lazyCollection->each(function ($number) {
dump($number);
sleep(1);
});
// 1
// 2
// ...
// 58
// 59

Page 411 of 1307

Laravel 9.x

To illustrate the usage of this method, imagine an application that submits invoices from the database using a cursor. You
could define a scheduled task that runs every 15 minutes and only processes invoices for a maximum of 14 minutes:
use App\Models\Invoice;
use Illuminate\Support\Carbon;
Invoice::pending()->cursor()
->takeUntilTimeout(
Carbon::createFromTimestamp(LARAVEL_START)->add(14, 'minutes')
)
->each(fn ($invoice) => $invoice->submit());

tapEach()

While the each method calls the given callback for each item in the collection right away, the tapEach method only
calls the given callback as the items are being pulled out of the list one by one:
// Nothing has been dumped so far...
$lazyCollection = LazyCollection::times(INF)->tapEach(function ($value) {
dump($value);
});
// Three items are dumped...
$array = $lazyCollection->take(3)->all();
// 1
// 2
// 3

remember()

The remember method returns a new lazy collection that will remember any values that have already been enumerated
and will not retrieve them again on subsequent collection enumerations:
// No query has been executed yet...
$users = User::cursor()->remember();
// The query is executed...
// The first 5 users are hydrated from the database...
$users->take(5)->all();
// First 5 users come from the collection's cache...
// The rest are hydrated from the database...
$users->take(20)->all();

Page 412 of 1307

Laravel 9.x

Introduction
Contracts Vs. Facades
When To Use Contracts
How To Use Contracts
Contract Reference

Contracts

Introduction

Laravel's "contracts" are a set of interfaces that define the core services provided by the framework. For example, an
Illuminate\Contracts\Queue\Queue contract defines the methods needed for queueing jobs, while the
Illuminate\Contracts\Mail\Mailer contract defines the methods needed for sending e-mail.
Each contract has a corresponding implementation provided by the framework. For example, Laravel provides a queue
implementation with a variety of drivers, and a mailer implementation that is powered by Symfony Mailer.
All of the Laravel contracts live in their own GitHub repository. This provides a quick reference point for all available
contracts, as well as a single, decoupled package that may be utilized when building packages that interact with Laravel
services.

Contracts Vs. Facades

Laravel's facades and helper functions provide a simple way of utilizing Laravel's services without needing to type-hint and
resolve contracts out of the service container. In most cases, each facade has an equivalent contract.
Unlike facades, which do not require you to require them in your class' constructor, contracts allow you to define explicit
dependencies for your classes. Some developers prefer to explicitly define their dependencies in this way and therefore
prefer to use contracts, while other developers enjoy the convenience of facades. In general, most applications can use
facades without issue during development.

When To Use Contracts

The decision to use contracts or facades will come down to personal taste and the tastes of your development team. Both
contracts and facades can be used to create robust, well-tested Laravel applications. Contracts and facades are not
mutually exclusive. Some parts of your applications may use facades while others depend on contracts. As long as you are
keeping your class' responsibilities focused, you will notice very few practical differences between using contracts and
facades.
In general, most applications can use facades without issue during development. If you are building a package that
integrates with multiple PHP frameworks you may wish to use the illuminate/contracts package to define your
integration with Laravel's services without the need to require Laravel's concrete implementations in your package's
composer.json file.

How To Use Contracts

So, how do you get an implementation of a contract? It's actually quite simple.
Many types of classes in Laravel are resolved through the service container, including controllers, event listeners,
middleware, queued jobs, and even route closures. So, to get an implementation of a contract, you can just "type-hint" the
interface in the constructor of the class being resolved.
For example, take a look at this event listener:

Page 413 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use App\Events\OrderWasPlaced;
use App\Models\User;
use Illuminate\Contracts\Redis\Factory;
class CacheOrderInformation
{
/**
* The Redis factory implementation.
*
* @var \Illuminate\Contracts\Redis\Factory
*/
protected $redis;
/**
* Create a new event handler instance.
*
* @param

\Illuminate\Contracts\Redis\Factory

$redis

* @return void
*/
public function __construct(Factory $redis)
{
$this->redis = $redis;
}
/**
* Handle the event.
*
* @param

\App\Events\OrderWasPlaced

$event

* @return void
*/
public function handle(OrderWasPlaced $event)
{
//
}
}

When the event listener is resolved, the service container will read the type-hints on the constructor of the class, and
inject the appropriate value. To learn more about registering things in the service container, check out its documentation.

Contract Reference

This table provides a quick reference to all of the Laravel contracts and their equivalent facades:

Page 414 of 1307

Laravel 9.x

Contract
Illuminate\Contracts\Auth\Access\Authorizable
Illuminate\Contracts\Auth\Access\Gate
Illuminate\Contracts\Auth\Authenticatable
Illuminate\Contracts\Auth\CanResetPassword
Illuminate\Contracts\Auth\Factory
Illuminate\Contracts\Auth\Guard
Illuminate\Contracts\Auth\PasswordBroker
Illuminate\Contracts\Auth\PasswordBrokerFactory
Illuminate\Contracts\Auth\StatefulGuard
Illuminate\Contracts\Auth\SupportsBasicAuth
Illuminate\Contracts\Auth\UserProvider
Illuminate\Contracts\Bus\Dispatcher
Illuminate\Contracts\Bus\QueueingDispatcher
Illuminate\Contracts\Broadcasting\Factory
Illuminate\Contracts\Broadcasting\Broadcaster
Illuminate\Contracts\Broadcasting\ShouldBroadcast
Illuminate\Contracts\Broadcasting\ShouldBroadcastNow
Illuminate\Contracts\Cache\Factory
Illuminate\Contracts\Cache\Lock
Illuminate\Contracts\Cache\LockProvider
Illuminate\Contracts\Cache\Repository
Illuminate\Contracts\Cache\Store
Illuminate\Contracts\Config\Repository
Illuminate\Contracts\Console\Application
Illuminate\Contracts\Console\Kernel
Illuminate\Contracts\Container\Container
Illuminate\Contracts\Cookie\Factory
Illuminate\Contracts\Cookie\QueueingFactory
Illuminate\Contracts\Database\ModelIdentifier
Illuminate\Contracts\Debug\ExceptionHandler
Illuminate\Contracts\Encryption\Encrypter

Page 415 of 1307

References Facade
Gate

Auth
Auth::guard()
Password::broker()
Password

Bus
Bus::dispatchToQueue()
Broadcast
Broadcast::connection()

Cache

Cache::driver()

Config

Artisan
App
Cookie
Cookie::queue()

Crypt

Laravel 9.x

Illuminate\Contracts\Events\Dispatcher
Illuminate\Contracts\Filesystem\Cloud
Illuminate\Contracts\Filesystem\Factory
Illuminate\Contracts\Filesystem\Filesystem
Illuminate\Contracts\Foundation\Application
Illuminate\Contracts\Hashing\Hasher
Illuminate\Contracts\Http\Kernel
Illuminate\Contracts\Mail\MailQueue
Illuminate\Contracts\Mail\Mailable
Illuminate\Contracts\Mail\Mailer
Illuminate\Contracts\Notifications\Dispatcher
Illuminate\Contracts\Notifications\Factory
Illuminate\Contracts\Pagination\LengthAwarePaginator
Illuminate\Contracts\Pagination\Paginator
Illuminate\Contracts\Pipeline\Hub
Illuminate\Contracts\Pipeline\Pipeline
Illuminate\Contracts\Queue\EntityResolver
Illuminate\Contracts\Queue\Factory
Illuminate\Contracts\Queue\Job
Illuminate\Contracts\Queue\Monitor
Illuminate\Contracts\Queue\Queue
Illuminate\Contracts\Queue\QueueableCollection
Illuminate\Contracts\Queue\QueueableEntity
Illuminate\Contracts\Queue\ShouldQueue
Illuminate\Contracts\Redis\Factory
Illuminate\Contracts\Routing\BindingRegistrar
Illuminate\Contracts\Routing\Registrar
Illuminate\Contracts\Routing\ResponseFactory
Illuminate\Contracts\Routing\UrlGenerator
Illuminate\Contracts\Routing\UrlRoutable
Illuminate\Contracts\Session\Session
Illuminate\Contracts\Support\Arrayable

Page 416 of 1307

Event
Storage::cloud()
Storage
Storage::disk()
App
Hash

Mail::queue()

Mail
Notification
Notification

Queue

Queue
Queue::connection()

Redis
Route
Route
Response
URL

Session::driver()

Laravel 9.x

Illuminate\Contracts\Support\Htmlable
Illuminate\Contracts\Support\Jsonable
Illuminate\Contracts\Support\MessageBag
Illuminate\Contracts\Support\MessageProvider
Illuminate\Contracts\Support\Renderable
Illuminate\Contracts\Support\Responsable
Illuminate\Contracts\Translation\Loader
Illuminate\Contracts\Translation\Translator
Illuminate\Contracts\Validation\Factory
Illuminate\Contracts\Validation\ImplicitRule
Illuminate\Contracts\Validation\Rule
Illuminate\Contracts\Validation\ValidatesWhenResolved
Illuminate\Contracts\Validation\Validator
Illuminate\Contracts\View\Engine
Illuminate\Contracts\View\Factory
Illuminate\Contracts\View\View

Page 417 of 1307

Lang
Validator

Validator::make()

View
View::make()

Laravel 9.x

Events

Introduction
Registering Events & Listeners
Generating Events & Listeners
Manually Registering Events
Event Discovery
Defining Events
Defining Listeners
Queued Event Listeners
Manually Interacting With The Queue
Queued Event Listeners & Database Transactions
Handling Failed Jobs
Dispatching Events
Event Subscribers
Writing Event Subscribers
Registering Event Subscribers

Introduction

Laravel's events provide a simple observer pattern implementation, allowing you to subscribe and listen for various events
that occur within your application. Event classes are typically stored in the app/Events directory, while their listeners are
stored in app/Listeners . Don't worry if you don't see these directories in your application as they will be created for
you as you generate events and listeners using Artisan console commands.
Events serve as a great way to decouple various aspects of your application, since a single event can have multiple
listeners that do not depend on each other. For example, you may wish to send a Slack notification to your user each time
an order has shipped. Instead of coupling your order processing code to your Slack notification code, you can raise an
App\Events\OrderShipped event which a listener can receive and use to dispatch a Slack notification.

Registering Events & Listeners

The App\Providers\EventServiceProvider included with your Laravel application provides a convenient place to
register all of your application's event listeners. The listen property contains an array of all events (keys) and their
listeners (values). You may add as many events to this array as your application requires. For example, let's add an
OrderShipped event:
use App\Events\OrderShipped;
use App\Listeners\SendShipmentNotification;
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
OrderShipped::class => [
SendShipmentNotification::class,
],
];

Page 418 of 1307

Laravel 9.x

The event:list command may be used to display a list of all events and listeners registered by
your application.

Generating Events & Listeners

Of course, manually creating the files for each event and listener is cumbersome. Instead, add listeners and events to your
EventServiceProvider and use the event:generate Artisan command. This command will generate any events or
listeners that are listed in your EventServiceProvider that do not already exist:
php artisan event:generate

Alternatively, you may use the make:event and make:listener Artisan commands to generate individual events and
listeners:
php artisan make:event PodcastProcessed
php artisan make:listener SendPodcastNotification --event=PodcastProcessed

Manually Registering Events

Typically, events should be registered via the EventServiceProvider $listen array; however, you may also register
class or closure based event listeners manually in the boot method of your EventServiceProvider :
use App\Events\PodcastProcessed;
use App\Listeners\SendPodcastNotification;
use Illuminate\Support\Facades\Event;
/**
* Register any other events for your application.
*
* @return void
*/
public function boot()
{
Event::listen(
PodcastProcessed::class,
[SendPodcastNotification::class, 'handle']
);
Event::listen(function (PodcastProcessed $event) {
//
});
}

Queueable Anonymous Event Listeners
When registering closure based event listeners manually, you may wrap the listener closure within the
Illuminate\Events\queueable function to instruct Laravel to execute the listener using the queue:

Page 419 of 1307

Laravel 9.x

use App\Events\PodcastProcessed;
use function Illuminate\Events\queueable;
use Illuminate\Support\Facades\Event;
/**
* Register any other events for your application.
*
* @return void
*/
public function boot()
{
Event::listen(queueable(function (PodcastProcessed $event) {
//
}));
}

Like queued jobs, you may use the onConnection , onQueue , and delay methods to customize the execution of the
queued listener:
Event::listen(queueable(function (PodcastProcessed $event) {
//
})->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));

If you would like to handle anonymous queued listener failures, you may provide a closure to the catch method while
defining the queueable listener. This closure will receive the event instance and the Throwable instance that caused
the listener's failure:
use App\Events\PodcastProcessed;
use function Illuminate\Events\queueable;
use Illuminate\Support\Facades\Event;
use Throwable;
Event::listen(queueable(function (PodcastProcessed $event) {
//
})->catch(function (PodcastProcessed $event, Throwable $e) {
// The queued listener failed...
}));

Wildcard Event Listeners
You may even register listeners using the * as a wildcard parameter, allowing you to catch multiple events on the same
listener. Wildcard listeners receive the event name as their first argument and the entire event data array as their second
argument:
Event::listen('event.*', function ($eventName, array $data) {
//
});

Event Discovery

Instead of registering events and listeners manually in the $listen array of the EventServiceProvider , you can
enable automatic event discovery. When event discovery is enabled, Laravel will automatically find and register your events
and listeners by scanning your application's Listeners directory. In addition, any explicitly defined events listed in the
EventServiceProvider will still be registered.
Page 420 of 1307

Laravel 9.x

Laravel finds event listeners by scanning the listener classes using PHP's reflection services. When Laravel finds any
listener class method that begins with handle or __invoke , Laravel will register those methods as event listeners for
the event that is type-hinted in the method's signature:
use App\Events\PodcastProcessed;
class SendPodcastNotification
{
/**
* Handle the given event.
*
* @param

\App\Events\PodcastProcessed

$event

* @return void
*/
public function handle(PodcastProcessed $event)
{
//
}
}

Event discovery is disabled by default, but you can enable it by overriding the shouldDiscoverEvents method of your
application's EventServiceProvider :
/**
* Determine if events and listeners should be automatically discovered.
*
* @return bool
*/
public function shouldDiscoverEvents()
{
return true;
}

By default, all listeners within your application's app/Listeners directory will be scanned. If you would like to define
additional directories to scan, you may override the discoverEventsWithin method in your EventServiceProvider :
/**
* Get the listener directories that should be used to discover events.
*
* @return array
*/
protected function discoverEventsWithin()
{
return [
$this->app->path('Listeners'),
];
}

Event Discovery In Production
In production, it is not efficient for the framework to scan all of your listeners on every request. Therefore, during your
deployment process, you should run the event:cache Artisan command to cache a manifest of all of your application's
events and listeners. This manifest will be used by the framework to speed up the event registration process. The
event:clear command may be used to destroy the cache.
Page 421 of 1307

Laravel 9.x

Defining Events

An event class is essentially a data container which holds the information related to the event. For example, let's assume
an App\Events\OrderShipped event receives an Eloquent ORM object:
<?php
namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;
class OrderShipped
{
use Dispatchable, InteractsWithSockets, SerializesModels;
/**
* The order instance.
*
* @var \App\Models\Order
*/
public $order;
/**
* Create a new event instance.
*
* @param

\App\Models\Order

$order

* @return void
*/
public function __construct(Order $order)
{
$this->order = $order;
}
}

As you can see, this event class contains no logic. It is a container for the App\Models\Order instance that was
purchased. The SerializesModels trait used by the event will gracefully serialize any Eloquent models if the event
object is serialized using PHP's serialize function, such as when utilizing queued listeners.

Defining Listeners

Next, let's take a look at the listener for our example event. Event listeners receive event instances in their handle
method. The event:generate and make:listener Artisan commands will automatically import the proper event class
and type-hint the event on the handle method. Within the handle method, you may perform any actions necessary to
respond to the event:

Page 422 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use App\Events\OrderShipped;
class SendShipmentNotification
{
/**
* Create the event listener.
*
* @return void
*/
public function __construct()
{
//
}
/**
* Handle the event.
*
* @param

\App\Events\OrderShipped

$event

* @return void
*/
public function handle(OrderShipped $event)
{
// Access the order using $event->order...
}
}

Your event listeners may also type-hint any dependencies they need on their constructors. All
event listeners are resolved via the Laravel service container, so dependencies will be injected
automatically.
Stopping The Propagation Of An Event
Sometimes, you may wish to stop the propagation of an event to other listeners. You may do so by returning false from
your listener's handle method.

Queued Event Listeners

Queueing listeners can be beneficial if your listener is going to perform a slow task such as sending an email or making an
HTTP request. Before using queued listeners, make sure to configure your queue and start a queue worker on your server
or local development environment.
To specify that a listener should be queued, add the ShouldQueue interface to the listener class. Listeners generated by
the event:generate and make:listener Artisan commands already have this interface imported into the current
namespace so you can use it immediately:

Page 423 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
class SendShipmentNotification implements ShouldQueue
{
//
}

That's it! Now, when an event handled by this listener is dispatched, the listener will automatically be queued by the event
dispatcher using Laravel's queue system. If no exceptions are thrown when the listener is executed by the queue, the
queued job will automatically be deleted after it has finished processing.
Customizing The Queue Connection & Queue Name
If you would like to customize the queue connection, queue name, or queue delay time of an event listener, you may define
the $connection , $queue , or $delay properties on your listener class:
<?php
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
class SendShipmentNotification implements ShouldQueue
{
/**
* The name of the connection the job should be sent to.
*
* @var string|null
*/
public $connection = 'sqs';
/**
* The name of the queue the job should be sent to.
*
* @var string|null
*/
public $queue = 'listeners';
/**
* The time (seconds) before the job should be processed.
*
* @var int
*/
public $delay = 60;
}

If you would like to define the listener's queue connection or queue name at runtime, you may define viaConnection or
viaQueue methods on the listener:

Page 424 of 1307

Laravel 9.x

/**
* Get the name of the listener's queue connection.
*
* @return string
*/
public function viaConnection()
{
return 'sqs';
}
/**
* Get the name of the listener's queue.
*
* @return string
*/
public function viaQueue()
{
return 'listeners';
}

Conditionally Queueing Listeners
Sometimes, you may need to determine whether a listener should be queued based on some data that are only available at
runtime. To accomplish this, a shouldQueue method may be added to a listener to determine whether the listener should
be queued. If the shouldQueue method returns false , the listener will not be executed:

Page 425 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use App\Events\OrderCreated;
use Illuminate\Contracts\Queue\ShouldQueue;
class RewardGiftCard implements ShouldQueue
{
/**
* Reward a gift card to the customer.
*
* @param

\App\Events\OrderCreated

$event

* @return void
*/
public function handle(OrderCreated $event)
{
//
}
/**
* Determine whether the listener should be queued.
*
* @param

\App\Events\OrderCreated

$event

* @return bool
*/
public function shouldQueue(OrderCreated $event)
{
return $event->order->subtotal >= 5000;
}
}

Manually Interacting With The Queue

If you need to manually access the listener's underlying queue job's delete and release methods, you may do so
using the Illuminate\Queue\InteractsWithQueue trait. This trait is imported by default on generated listeners and
provides access to these methods:

Page 426 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueue
{
use InteractsWithQueue;
/**
* Handle the event.
*
* @param

\App\Events\OrderShipped

$event

* @return void
*/
public function handle(OrderShipped $event)
{
if (true) {
$this->release(30);
}
}
}

Queued Event Listeners & Database Transactions

When queued listeners are dispatched within database transactions, they may be processed by the queue before the
database transaction has committed. When this happens, any updates you have made to models or database records
during the database transaction may not yet be reflected in the database. In addition, any models or database records
created within the transaction may not exist in the database. If your listener depends on these models, unexpected errors
can occur when the job that dispatches the queued listener is processed.
If your queue connection's after_commit configuration option is set to false , you may still indicate that a particular
queued listener should be dispatched after all open database transactions have been committed by defining an
$afterCommit property on the listener class:
<?php
namespace App\Listeners;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueue
{
use InteractsWithQueue;
public $afterCommit = true;
}

Page 427 of 1307

Laravel 9.x

To learn more about working around these issues, please review the documentation regarding
queued jobs and database transactions.

Handling Failed Jobs

Sometimes your queued event listeners may fail. If the queued listener exceeds the maximum number of attempts as
defined by your queue worker, the failed method will be called on your listener. The failed method receives the
event instance and the Throwable that caused the failure:
<?php
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueue
{
use InteractsWithQueue;
/**
* Handle the event.
*
* @param

\App\Events\OrderShipped

$event

* @return void
*/
public function handle(OrderShipped $event)
{
//
}
/**
* Handle a job failure.
*
* @param

\App\Events\OrderShipped

* @param

\Throwable

$event

$exception

* @return void
*/
public function failed(OrderShipped $event, $exception)
{
//
}
}

Specifying Queued Listener Maximum Attempts
If one of your queued listeners is encountering an error, you likely do not want it to keep retrying indefinitely. Therefore,
Laravel provides various ways to specify how many times or for how long a listener may be attempted.
You may define a $tries property on your listener class to specify how many times the listener may be attempted before
it is considered to have failed:

Page 428 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueue
{
use InteractsWithQueue;
/**
* The number of times the queued listener may be attempted.
*
* @var int
*/
public $tries = 5;
}

As an alternative to defining how many times a listener may be attempted before it fails, you may define a time at which the
listener should no longer be attempted. This allows a listener to be attempted any number of times within a given time
frame. To define the time at which a listener should no longer be attempted, add a retryUntil method to your listener
class. This method should return a DateTime instance:
/**
* Determine the time at which the listener should timeout.
*
* @return \DateTime
*/
public function retryUntil()
{
return now()->addMinutes(5);
}

Dispatching Events

To dispatch an event, you may call the static dispatch method on the event. This method is made available on the event
by the Illuminate\Foundation\Events\Dispatchable trait. Any arguments passed to the dispatch method will be
passed to the event's constructor:

Page 429 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Events\OrderShipped;
use App\Http\Controllers\Controller;
use App\Models\Order;
use Illuminate\Http\Request;
class OrderShipmentController extends Controller
{
/**
* Ship the given order.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$order = Order::findOrFail($request->order_id);
// Order shipment logic...
OrderShipped::dispatch($order);
}
}

If you would like to conditionally dispatch an event, you may use the dispatchIf and dispatchUnless methods:
OrderShipped::dispatchIf($condition, $order);
OrderShipped::dispatchUnless($condition, $order);

When testing, it can be helpful to assert that certain events were dispatched without actually
triggering their listeners. Laravel's built-in testing helpers makes it a cinch.

Event Subscribers

Writing Event Subscribers

Event subscribers are classes that may subscribe to multiple events from within the subscriber class itself, allowing you to
define several event handlers within a single class. Subscribers should define a subscribe method, which will be passed
an event dispatcher instance. You may call the listen method on the given dispatcher to register event listeners:

Page 430 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use Illuminate\Auth\Events\Login;
use Illuminate\Auth\Events\Logout;
class UserEventSubscriber
{
/**
* Handle user login events.
*/
public function handleUserLogin($event) {}
/**
* Handle user logout events.
*/
public function handleUserLogout($event) {}
/**
* Register the listeners for the subscriber.
*
* @param

\Illuminate\Events\Dispatcher

$events

* @return void
*/
public function subscribe($events)
{
$events->listen(
Login::class,
[UserEventSubscriber::class, 'handleUserLogin']
);
$events->listen(
Logout::class,
[UserEventSubscriber::class, 'handleUserLogout']
);
}
}

If your event listener methods are defined within the subscriber itself, you may find it more convenient to return an array of
events and method names from the subscriber's subscribe method. Laravel will automatically determine the
subscriber's class name when registering the event listeners:

Page 431 of 1307

Laravel 9.x

<?php
namespace App\Listeners;
use Illuminate\Auth\Events\Login;
use Illuminate\Auth\Events\Logout;
class UserEventSubscriber
{
/**
* Handle user login events.
*/
public function handleUserLogin($event) {}
/**
* Handle user logout events.
*/
public function handleUserLogout($event) {}
/**
* Register the listeners for the subscriber.
*
* @param

\Illuminate\Events\Dispatcher

$events

* @return array
*/
public function subscribe($events)
{
return [
Login::class => 'handleUserLogin',
Logout::class => 'handleUserLogout',
];
}
}

Registering Event Subscribers

After writing the subscriber, you are ready to register it with the event dispatcher. You may register subscribers using the
$subscribe property on the EventServiceProvider . For example, let's add the UserEventSubscriber to the list:

Page 432 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use App\Listeners\UserEventSubscriber;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;
class EventServiceProvider extends ServiceProvider
{
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
//
];
/**
* The subscriber classes to register.
*
* @var array
*/
protected $subscribe = [
UserEventSubscriber::class,
];
}

Page 433 of 1307

Laravel 9.x

File Storage

Introduction
Configuration
The Local Driver
The Public Disk
Driver Prerequisites
Scoped & Read-Only Filesystems
Amazon S3 Compatible Filesystems
Obtaining Disk Instances
On-Demand Disks
Retrieving Files
Downloading Files
File URLs
File Metadata
Storing Files
Prepending & Appending To Files
Copying & Moving Files
Automatic Streaming
File Uploads
File Visibility
Deleting Files
Directories
Custom Filesystems

Introduction

Laravel provides a powerful filesystem abstraction thanks to the wonderful Flysystem PHP package by Frank de Jonge. The
Laravel Flysystem integration provides simple drivers for working with local filesystems, SFTP, and Amazon S3. Even better,
it's amazingly simple to switch between these storage options between your local development machine and production
server as the API remains the same for each system.

Configuration

Laravel's filesystem configuration file is located at config/filesystems.php . Within this file, you may configure all of
your filesystem "disks". Each disk represents a particular storage driver and storage location. Example configurations for
each supported driver are included in the configuration file so you can modify the configuration to reflect your storage
preferences and credentials.
The local driver interacts with files stored locally on the server running the Laravel application while the s3 driver is
used to write to Amazon's S3 cloud storage service.
You may configure as many disks as you like and may even have multiple disks that use the same
driver.

The Local Driver

When using the local driver, all file operations are relative to the root directory defined in your filesystems
configuration file. By default, this value is set to the storage/app directory. Therefore, the following method would write
to storage/app/example.txt :
Page 434 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Storage;
Storage::disk('local')->put('example.txt', 'Contents');

The Public Disk

The public disk included in your application's filesystems configuration file is intended for files that are going to be
publicly accessible. By default, the public disk uses the local driver and stores its files in storage/app/public .
To make these files accessible from the web, you should create a symbolic link from public/storage to
storage/app/public . Utilizing this folder convention will keep your publicly accessible files in one directory that can be
easily shared across deployments when using zero down-time deployment systems like Envoyer.
To create the symbolic link, you may use the storage:link Artisan command:
php artisan storage:link

Once a file has been stored and the symbolic link has been created, you can create a URL to the files using the asset
helper:
echo asset('storage/file.txt');

You may configure additional symbolic links in your filesystems configuration file. Each of the configured links will be
created when you run the storage:link command:
'links' => [
public_path('storage') => storage_path('app/public'),
public_path('images') => storage_path('app/images'),
],

Driver Prerequisites

S3 Driver Configuration
Before using the S3 driver, you will need to install the Flysystem S3 package via the Composer package manager:
composer require league/flysystem-aws-s3-v3 "^3.0"

The S3 driver configuration information is located in your config/filesystems.php configuration file. This file contains
an example configuration array for an S3 driver. You are free to modify this array with your own S3 configuration and
credentials. For convenience, these environment variables match the naming convention used by the AWS CLI.
FTP Driver Configuration
Before using the FTP driver, you will need to install the Flysystem FTP package via the Composer package manager:
composer require league/flysystem-ftp "^3.0"

Laravel's Flysystem integrations work great with FTP; however, a sample configuration is not included with the framework's
default filesystems.php configuration file. If you need to configure an FTP filesystem, you may use the configuration
example below:

Page 435 of 1307

Laravel 9.x

'ftp' => [
'driver' => 'ftp',
'host' => env('FTP_HOST'),
'username' => env('FTP_USERNAME'),
'password' => env('FTP_PASSWORD'),
// Optional FTP Settings...
// 'port' => env('FTP_PORT', 21),
// 'root' => env('FTP_ROOT'),
// 'passive' => true,
// 'ssl' => true,
// 'timeout' => 30,
],

SFTP Driver Configuration
Before using the SFTP driver, you will need to install the Flysystem SFTP package via the Composer package manager:
composer require league/flysystem-sftp-v3 "^3.0"

Laravel's Flysystem integrations work great with SFTP; however, a sample configuration is not included with the
framework's default filesystems.php configuration file. If you need to configure an SFTP filesystem, you may use the
configuration example below:
'sftp' => [
'driver' => 'sftp',
'host' => env('SFTP_HOST'),
// Settings for basic authentication...
'username' => env('SFTP_USERNAME'),
'password' => env('SFTP_PASSWORD'),
// Settings for SSH key based authentication with encryption password...
'privateKey' => env('SFTP_PRIVATE_KEY'),
'passphrase' => env('SFTP_PASSPHRASE'),
// Optional SFTP Settings...
// 'hostFingerprint' => env('SFTP_HOST_FINGERPRINT'),
// 'maxTries' => 4,
// 'passphrase' => env('SFTP_PASSPHRASE'),
// 'port' => env('SFTP_PORT', 22),
// 'root' => env('SFTP_ROOT', ''),
// 'timeout' => 30,
// 'useAgent' => true,
],

Scoped & Read-Only Filesystems

Scoped disks allow you to define a filesystem where all paths are automatically prefixed with a given path prefix. Before
creating a scoped filesystem disk, you will need to install an additional Flysystem package via the Composer package
manager:
composer require league/flysystem-path-prefixing "^3.0"

Page 436 of 1307

Laravel 9.x

You may create a path scoped instance of any existing filesystem disk by defining a disk that utilizes the scoped driver.
For example, you may create a disk which scopes your existing s3 disk to a specific path prefix, and then every file
operation using your scoped disk will utilize the specified prefix:
's3-videos' => [
'driver' => 'scoped',
'disk' => 's3',
'prefix' => 'path/to/videos',
],

"Read-only" disks allow you to create filesystem disks that do not allow write operations. Before using the read-only
configuration option, you will need to install an additional Flysystem package via the Composer package manager:
composer require league/flysystem-read-only "^3.0"

Next, you may include the read-only configuration option in one or more of your disk's configuration arrays:
's3-videos' => [
'driver' => 's3',
// ...
'read-only' => true,
],

Amazon S3 Compatible Filesystems

By default, your application's filesystems configuration file contains a disk configuration for the s3 disk. In addition
to using this disk to interact with Amazon S3, you may use it to interact with any S3 compatible file storage service such as
MinIO or DigitalOcean Spaces.
Typically, after updating the disk's credentials to match the credentials of the service you are planning to use, you only
need to update the value of the endpoint configuration option. This option's value is typically defined via the
AWS_ENDPOINT environment variable:
'endpoint' => env('AWS_ENDPOINT', 'https://minio:9000'),

MinIO
In order for Laravel's Flysystem integration to generate proper URLs when using MinIO, you should define the AWS_URL
environment variable so that it matches your application's local URL and includes the bucket name in the URL path:
AWS_URL=http://localhost:9000/local

Generating temporary storage URLs via the temporaryUrl method is not supported when using
MinIO.

Obtaining Disk Instances

The Storage facade may be used to interact with any of your configured disks. For example, you may use the put
method on the facade to store an avatar on the default disk. If you call methods on the Storage facade without first
calling the disk method, the method will automatically be passed to the default disk:
Page 437 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Storage;
Storage::put('avatars/1', $content);

If your application interacts with multiple disks, you may use the disk method on the Storage facade to work with files
on a particular disk:
Storage::disk('s3')->put('avatars/1', $content);

On-Demand Disks

Sometimes you may wish to create a disk at runtime using a given configuration without that configuration actually being
present in your application's filesystems configuration file. To accomplish this, you may pass a configuration array to
the Storage facade's build method:
use Illuminate\Support\Facades\Storage;
$disk = Storage::build([
'driver' => 'local',
'root' => '/path/to/root',
]);
$disk->put('image.jpg', $content);

Retrieving Files

The get method may be used to retrieve the contents of a file. The raw string contents of the file will be returned by the
method. Remember, all file paths should be specified relative to the disk's "root" location:
$contents = Storage::get('file.jpg');

The exists method may be used to determine if a file exists on the disk:
if (Storage::disk('s3')->exists('file.jpg')) {
// ...
}

The missing method may be used to determine if a file is missing from the disk:
if (Storage::disk('s3')->missing('file.jpg')) {
// ...
}

Downloading Files

The download method may be used to generate a response that forces the user's browser to download the file at the
given path. The download method accepts a filename as the second argument to the method, which will determine the
filename that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third
argument to the method:

Page 438 of 1307

Laravel 9.x

return Storage::download('file.jpg');
return Storage::download('file.jpg', $name, $headers);

File URLs

You may use the url method to get the URL for a given file. If you are using the local driver, this will typically just
prepend /storage to the given path and return a relative URL to the file. If you are using the s3 driver, the fully
qualified remote URL will be returned:
use Illuminate\Support\Facades\Storage;
$url = Storage::url('file.jpg');

When using the local driver, all files that should be publicly accessible should be placed in the storage/app/public
directory. Furthermore, you should create a symbolic link at public/storage which points to the
storage/app/public directory.
When using the local driver, the return value of url is not URL encoded. For this reason, we
recommend always storing your files using names that will create valid URLs.
Temporary URLs
Using the temporaryUrl method, you may create temporary URLs to files stored using the s3 driver. This method
accepts a path and a DateTime instance specifying when the URL should expire:
use Illuminate\Support\Facades\Storage;
$url = Storage::temporaryUrl(
'file.jpg', now()->addMinutes(5)
);

If you need to specify additional S3 request parameters, you may pass the array of request parameters as the third
argument to the temporaryUrl method:
$url = Storage::temporaryUrl(
'file.jpg',
now()->addMinutes(5),
[
'ResponseContentType' => 'application/octet-stream',
'ResponseContentDisposition' => 'attachment; filename=file2.jpg',
]
);

If you need to customize how temporary URLs are created for a specific storage disk, you can use the
buildTemporaryUrlsUsing method. For example, this can be useful if you have a controller that allows you to download
files stored via a disk that doesn't typically support temporary URLs. Usually, this method should be called from the boot
method of a service provider:

Page 439 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\URL;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Storage::disk('local')->buildTemporaryUrlsUsing(function ($path, $expiration, $options)
{
return URL::temporarySignedRoute(
'files.download',
$expiration,
array_merge($options, ['path' => $path])
);
});
}
}

URL Host Customization
If you would like to pre-define the host for URLs generated using the Storage facade, you may add a url option to the
disk's configuration array:
'public' => [
'driver' => 'local',
'root' => storage_path('app/public'),
'url' => env('APP_URL').'/storage',
'visibility' => 'public',
],

File Metadata

In addition to reading and writing files, Laravel can also provide information about the files themselves. For example, the
size method may be used to get the size of a file in bytes:
use Illuminate\Support\Facades\Storage;
$size = Storage::size('file.jpg');

The lastModified method returns the UNIX timestamp of the last time the file was modified:
$time = Storage::lastModified('file.jpg');

The MIME type of a given file may be obtained via the mimeType method:
Page 440 of 1307

Laravel 9.x

$mime = Storage::mimeType('file.jpg')

File Paths
You may use the path method to get the path for a given file. If you are using the local driver, this will return the
absolute path to the file. If you are using the s3 driver, this method will return the relative path to the file in the S3
bucket:
use Illuminate\Support\Facades\Storage;
$path = Storage::path('file.jpg');

Storing Files

The put method may be used to store file contents on a disk. You may also pass a PHP resource to the put method,
which will use Flysystem's underlying stream support. Remember, all file paths should be specified relative to the "root"
location configured for the disk:
use Illuminate\Support\Facades\Storage;
Storage::put('file.jpg', $contents);
Storage::put('file.jpg', $resource);

Failed Writes
If the put method (or other "write" operations) is unable to write the file to disk, false will be returned:
if (! Storage::put('file.jpg', $contents)) {
// The file could not be written to disk...
}

If you wish, you may define the throw option within your filesystem disk's configuration array. When this option is
defined as true , "write" methods such as put will throw an instance of League\Flysystem\UnableToWriteFile
when write operations fail:
'public' => [
'driver' => 'local',
// ...
'throw' => true,
],

Prepending & Appending To Files

The prepend and append methods allow you to write to the beginning or end of a file:
Storage::prepend('file.log', 'Prepended Text');
Storage::append('file.log', 'Appended Text');

Copying & Moving Files
Page 441 of 1307

Laravel 9.x

The copy method may be used to copy an existing file to a new location on the disk, while the move method may be
used to rename or move an existing file to a new location:
Storage::copy('old/file.jpg', 'new/file.jpg');
Storage::move('old/file.jpg', 'new/file.jpg');

Automatic Streaming

Streaming files to storage offers significantly reduced memory usage. If you would like Laravel to automatically manage
streaming a given file to your storage location, you may use the putFile or putFileAs method. This method accepts
either an Illuminate\Http\File or Illuminate\Http\UploadedFile instance and will automatically stream the file
to your desired location:
use Illuminate\Http\File;
use Illuminate\Support\Facades\Storage;
// Automatically generate a unique ID for filename...
$path = Storage::putFile('photos', new File('/path/to/photo'));
// Manually specify a filename...
$path = Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg');

There are a few important things to note about the putFile method. Note that we only specified a directory name and
not a filename. By default, the putFile method will generate a unique ID to serve as the filename. The file's extension
will be determined by examining the file's MIME type. The path to the file will be returned by the putFile method so you
can store the path, including the generated filename, in your database.
The putFile and putFileAs methods also accept an argument to specify the "visibility" of the stored file. This is
particularly useful if you are storing the file on a cloud disk such as Amazon S3 and would like the file to be publicly
accessible via generated URLs:
Storage::putFile('photos', new File('/path/to/photo'), 'public');

File Uploads

In web applications, one of the most common use-cases for storing files is storing user uploaded files such as photos and
documents. Laravel makes it very easy to store uploaded files using the store method on an uploaded file instance. Call
the store method with the path at which you wish to store the uploaded file:

Page 442 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
class UserAvatarController extends Controller
{
/**
* Update the avatar for the user.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function update(Request $request)
{
$path = $request->file('avatar')->store('avatars');
return $path;
}
}

There are a few important things to note about this example. Note that we only specified a directory name, not a filename.
By default, the store method will generate a unique ID to serve as the filename. The file's extension will be determined
by examining the file's MIME type. The path to the file will be returned by the store method so you can store the path,
including the generated filename, in your database.
You may also call the putFile method on the Storage facade to perform the same file storage operation as the
example above:
$path = Storage::putFile('avatars', $request->file('avatar'));

Specifying A File Name
If you do not want a filename to be automatically assigned to your stored file, you may use the storeAs method, which
receives the path, the filename, and the (optional) disk as its arguments:
$path = $request->file('avatar')->storeAs(
'avatars', $request->user()->id
);

You may also use the putFileAs method on the Storage facade, which will perform the same file storage operation as
the example above:
$path = Storage::putFileAs(
'avatars', $request->file('avatar'), $request->user()->id
);

Page 443 of 1307

Laravel 9.x

Unprintable and invalid unicode characters will automatically be removed from file paths.
Therefore, you may wish to sanitize your file paths before passing them to Laravel's file storage
methods. File paths are normalized using the
League\Flysystem\WhitespacePathNormalizer::normalizePath method.
Specifying A Disk
By default, this uploaded file's store method will use your default disk. If you would like to specify another disk, pass the
disk name as the second argument to the store method:
$path = $request->file('avatar')->store(
'avatars/'.$request->user()->id, 's3'
);

If you are using the storeAs method, you may pass the disk name as the third argument to the method:
$path = $request->file('avatar')->storeAs(
'avatars',
$request->user()->id,
's3'
);

Other Uploaded File Information
If you would like to get the original name and extension of the uploaded file, you may do so using the
getClientOriginalName and getClientOriginalExtension methods:
$file = $request->file('avatar');
$name = $file->getClientOriginalName();
$extension = $file->getClientOriginalExtension();

However, keep in mind that the getClientOriginalName and getClientOriginalExtension methods are considered
unsafe, as the file name and extension may be tampered with by a malicious user. For this reason, you should typically
prefer the hashName and extension methods to get a name and an extension for the given file upload:
$file = $request->file('avatar');
$name = $file->hashName(); // Generate a unique, random name...
$extension = $file->extension(); // Determine the file's extension based on the file's MIME
type...

File Visibility

In Laravel's Flysystem integration, "visibility" is an abstraction of file permissions across multiple platforms. Files may
either be declared public or private . When a file is declared public , you are indicating that the file should
generally be accessible to others. For example, when using the S3 driver, you may retrieve URLs for public files.
You can set the visibility when writing the file via the put method:

Page 444 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Storage;
Storage::put('file.jpg', $contents, 'public');

If the file has already been stored, its visibility can be retrieved and set via the getVisibility and setVisibility
methods:
$visibility = Storage::getVisibility('file.jpg');
Storage::setVisibility('file.jpg', 'public');

When interacting with uploaded files, you may use the storePublicly and storePubliclyAs methods to store the
uploaded file with public visibility:
$path = $request->file('avatar')->storePublicly('avatars', 's3');
$path = $request->file('avatar')->storePubliclyAs(
'avatars',
$request->user()->id,
's3'
);

Local Files & Visibility
When using the local driver, public visibility translates to 0755 permissions for directories and 0644 permissions
for files. You can modify the permissions mappings in your application's filesystems configuration file:
'local' => [
'driver' => 'local',
'root' => storage_path('app'),
'permissions' => [
'file' => [
'public' => 0644,
'private' => 0600,
],
'dir' => [
'public' => 0755,
'private' => 0700,
],
],
],

Deleting Files

The delete method accepts a single filename or an array of files to delete:
use Illuminate\Support\Facades\Storage;
Storage::delete('file.jpg');
Storage::delete(['file.jpg', 'file2.jpg']);

If necessary, you may specify the disk that the file should be deleted from:
Page 445 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Storage;
Storage::disk('s3')->delete('path/file.jpg');

Directories

Get All Files Within A Directory
The files method returns an array of all of the files in a given directory. If you would like to retrieve a list of all files
within a given directory including all subdirectories, you may use the allFiles method:
use Illuminate\Support\Facades\Storage;
$files = Storage::files($directory);
$files = Storage::allFiles($directory);

Get All Directories Within A Directory
The directories method returns an array of all the directories within a given directory. Additionally, you may use the
allDirectories method to get a list of all directories within a given directory and all of its subdirectories:
$directories = Storage::directories($directory);
$directories = Storage::allDirectories($directory);

Create A Directory
The makeDirectory method will create the given directory, including any needed subdirectories:
Storage::makeDirectory($directory);

Delete A Directory
Finally, the deleteDirectory method may be used to remove a directory and all of its files:
Storage::deleteDirectory($directory);

Custom Filesystems

Laravel's Flysystem integration provides support for several "drivers" out of the box; however, Flysystem is not limited to
these and has adapters for many other storage systems. You can create a custom driver if you want to use one of these
additional adapters in your Laravel application.
In order to define a custom filesystem you will need a Flysystem adapter. Let's add a community maintained Dropbox
adapter to our project:
composer require spatie/flysystem-dropbox

Next, you can register the driver within the boot method of one of your application's service providers. To accomplish
this, you should use the extend method of the Storage facade:

Page 446 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Filesystem\FilesystemAdapter;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\ServiceProvider;
use League\Flysystem\Filesystem;
use Spatie\Dropbox\Client as DropboxClient;
use Spatie\FlysystemDropbox\DropboxAdapter;
class AppServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Storage::extend('dropbox', function ($app, $config) {
$adapter = new DropboxAdapter(new DropboxClient(
$config['authorization_token']
));
return new FilesystemAdapter(
new Filesystem($adapter, $config),
$adapter,
$config
);
});
}
}

The first argument of the extend method is the name of the driver and the second is a closure that receives the $app
and $config variables. The closure must return an instance of Illuminate\Filesystem\FilesystemAdapter . The
$config variable contains the values defined in config/filesystems.php for the specified disk.
Once you have created and registered the extension's service provider, you may use the dropbox driver in your
config/filesystems.php configuration file.

Page 447 of 1307

Laravel 9.x

Helpers
Introduction
Available Methods
Other Utilities
Benchmarking
Lottery

Introduction

Laravel includes a variety of global "helper" PHP functions. Many of these functions are used by the framework itself;
however, you are free to use them in your own applications if you find them convenient.

Available Methods
Arrays & Objects
Arr::accessible
Arr::add
Arr::collapse
Arr::crossJoin
Arr::divide
Arr::dot
Arr::except
Arr::exists
Arr::first
Arr::flatten
Arr::forget
Arr::get
Arr::has
Arr::hasAny

Paths

app_path
base_path
config_path

Strings

__
class_basename
e
preg_replace_array
Str::after
Str::afterLast
Str::ascii
Str::before
Str::beforeLast
Str::between
Str::betweenFirst
Str::camel
Str::contains
Str::containsAll

Arr::isAssoc
Arr::isList
Arr::join
Arr::keyBy
Arr::last
Arr::map
Arr::only
Arr::pluck
Arr::prepend
Arr::prependKeysWith
Arr::pull
Arr::query
Arr::random
Arr::set

Arr::shuffle
Arr::sort
Arr::sortDesc
Arr::sortRecursive
Arr::toCssClasses
Arr::undot
Arr::where
Arr::whereNotNull
Arr::wrap
data_fill
data_get
data_set
head
last

database_path
lang_path
mix

public_path
resource_path
storage_path

Str::endsWith
Str::excerpt
Str::finish
Str::headline
Str::inlineMarkdown
Str::is
Str::isAscii
Str::isJson
Str::isUlid
Str::isUuid
Str::kebab
Str::lcfirst
Str::length
Str::limit

Str::lower
Str::markdown
Str::mask
Str::orderedUuid
Str::padBoth
Str::padLeft
Str::padRight
Str::plural
Str::pluralStudly
Str::random
Str::remove
Str::replace
Str::replaceArray
Str::replaceFirst

Page 448 of 1307

Laravel 9.x

Str::replaceLast
Str::reverse
Str::singular
Str::slug
Str::snake
Str::squish
Str::start
Str::startsWith
Str::studly

Str::substr
Str::substrCount
Str::substrReplace
Str::swap
Str::title
Str::toHtmlString
Str::ucfirst
Str::ucsplit
Str::upper

Str::ulid
Str::uuid
Str::wordCount
Str::words
str
trans
trans_choice

after
afterLast
append
ascii
basename
before
beforeLast
between
betweenFirst
camel
classBasename
contains
containsAll
dirname
endsWith
excerpt
exactly
explode
finish
headline
inlineMarkdown
is
isAscii
isEmpty
isNotEmpty
isJson
isUlid
isUuid
kebab

lcfirst
length
limit
lower
ltrim
markdown
mask
match
matchAll
newLine
padBoth
padLeft
padRight
pipe
plural
prepend
remove
replace
replaceArray
replaceFirst
replaceLast
replaceMatches
rtrim
scan
singular
slug
snake
split
squish

start
startsWith
studly
substr
substrReplace
swap
tap
test
title
trim
ucfirst
ucsplit
upper
when
whenContains
whenContainsAll
whenEmpty
whenNotEmpty
whenStartsWith
whenEndsWith
whenExactly
whenNotExactly
whenIs
whenIsAscii
whenIsUlid
whenIsUuid
whenTest
wordCount
words

secure_asset
secure_url
to_route

url

blank
broadcast
cache
class_uses_recursive
collect
config
cookie

csrf_field
csrf_token
decrypt
dd
dispatch
dump
encrypt

Fluent Strings

URLs
action
asset
route

Miscellaneous
abort
abort_if
abort_unless
app
auth
back
bcrypt

Page 449 of 1307

Laravel 9.x

env
event
fake
filled
info
logger
method_field
now
old
optional
policy

Method Listing
Arrays & Objects

redirect
report
report_if
report_unless
request
rescue
resolve
response
retry
session
tap

throw_if
throw_unless
today
trait_uses_recursive
transform
validator
value
view
with

Arr::accessible()

The Arr::accessible method determines if the given value is array accessible:
use Illuminate\Support\Arr;
use Illuminate\Support\Collection;
$isAccessible = Arr::accessible(['a' => 1, 'b' => 2]);
// true
$isAccessible = Arr::accessible(new Collection);
// true
$isAccessible = Arr::accessible('abc');
// false
$isAccessible = Arr::accessible(new stdClass);
// false

Arr::add()

The Arr::add method adds a given key / value pair to an array if the given key doesn't already exist in the array or is set
to null :
use Illuminate\Support\Arr;
$array = Arr::add(['name' => 'Desk'], 'price', 100);
// ['name' => 'Desk', 'price' => 100]
$array = Arr::add(['name' => 'Desk', 'price' => null], 'price', 100);
// ['name' => 'Desk', 'price' => 100]

Arr::collapse()

Page 450 of 1307

Laravel 9.x

The Arr::collapse method collapses an array of arrays into a single array:
use Illuminate\Support\Arr;
$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);
// [1, 2, 3, 4, 5, 6, 7, 8, 9]

Arr::crossJoin()

The Arr::crossJoin method cross joins the given arrays, returning a Cartesian product with all possible permutations:
use Illuminate\Support\Arr;
$matrix = Arr::crossJoin([1, 2], ['a', 'b']);
/*
[
[1, 'a'],
[1, 'b'],
[2, 'a'],
[2, 'b'],
]
*/
$matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);
/*
[
[1, 'a', 'I'],
[1, 'a', 'II'],
[1, 'b', 'I'],
[1, 'b', 'II'],
[2, 'a', 'I'],
[2, 'a', 'II'],
[2, 'b', 'I'],
[2, 'b', 'II'],
]
*/

Arr::divide()

The Arr::divide method returns two arrays: one containing the keys and the other containing the values of the given
array:
use Illuminate\Support\Arr;
[$keys, $values] = Arr::divide(['name' => 'Desk']);
// $keys: ['name']
// $values: ['Desk']

Arr::dot()

Page 451 of 1307

Laravel 9.x

The Arr::dot method flattens a multi-dimensional array into a single level array that uses "dot" notation to indicate
depth:
use Illuminate\Support\Arr;
$array = ['products' => ['desk' => ['price' => 100]]];
$flattened = Arr::dot($array);
// ['products.desk.price' => 100]

Arr::except()

The Arr::except method removes the given key / value pairs from an array:
use Illuminate\Support\Arr;
$array = ['name' => 'Desk', 'price' => 100];
$filtered = Arr::except($array, ['price']);
// ['name' => 'Desk']

Arr::exists()

The Arr::exists method checks that the given key exists in the provided array:
use Illuminate\Support\Arr;
$array = ['name' => 'John Doe', 'age' => 17];
$exists = Arr::exists($array, 'name');
// true
$exists = Arr::exists($array, 'salary');
// false

Arr::first()

The Arr::first method returns the first element of an array passing a given truth test:
use Illuminate\Support\Arr;
$array = [100, 200, 300];
$first = Arr::first($array, function ($value, $key) {
return $value >= 150;
});
// 200

A default value may also be passed as the third parameter to the method. This value will be returned if no value passes the
truth test:
Page 452 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$first = Arr::first($array, $callback, $default);

Arr::flatten()

The Arr::flatten method flattens a multi-dimensional array into a single level array:
use Illuminate\Support\Arr;
$array = ['name' => 'Joe', 'languages' => ['PHP', 'Ruby']];
$flattened = Arr::flatten($array);
// ['Joe', 'PHP', 'Ruby']

Arr::forget()

The Arr::forget method removes a given key / value pair from a deeply nested array using "dot" notation:
use Illuminate\Support\Arr;
$array = ['products' => ['desk' => ['price' => 100]]];
Arr::forget($array, 'products.desk');
// ['products' => []]

Arr::get()

The Arr::get method retrieves a value from a deeply nested array using "dot" notation:
use Illuminate\Support\Arr;
$array = ['products' => ['desk' => ['price' => 100]]];
$price = Arr::get($array, 'products.desk.price');
// 100

The Arr::get method also accepts a default value, which will be returned if the specified key is not present in the array:
use Illuminate\Support\Arr;
$discount = Arr::get($array, 'products.desk.discount', 0);
// 0

Arr::has()

The Arr::has method checks whether a given item or items exists in an array using "dot" notation:

Page 453 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$array = ['product' => ['name' => 'Desk', 'price' => 100]];
$contains = Arr::has($array, 'product.name');
// true
$contains = Arr::has($array, ['product.price', 'product.discount']);
// false

Arr::hasAny()

The Arr::hasAny method checks whether any item in a given set exists in an array using "dot" notation:
use Illuminate\Support\Arr;
$array = ['product' => ['name' => 'Desk', 'price' => 100]];
$contains = Arr::hasAny($array, 'product.name');
// true
$contains = Arr::hasAny($array, ['product.name', 'product.discount']);
// true
$contains = Arr::hasAny($array, ['category', 'product.discount']);
// false

Arr::isAssoc()

The Arr::isAssoc method returns true if the given array is an associative array. An array is considered "associative"
if it doesn't have sequential numerical keys beginning with zero:
use Illuminate\Support\Arr;
$isAssoc = Arr::isAssoc(['product' => ['name' => 'Desk', 'price' => 100]]);
// true
$isAssoc = Arr::isAssoc([1, 2, 3]);
// false

Arr::isList()

The Arr::isList method returns true if the given array's keys are sequential integers beginning from zero:

Page 454 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$isList = Arr::isList(['foo', 'bar', 'baz']);
// true
$isList = Arr::isList(['product' => ['name' => 'Desk', 'price' => 100]]);
// false

Arr::join()

The Arr::join method joins array elements with a string. Using this method's second argument, you may also specify
the joining string for the final element of the array:
use Illuminate\Support\Arr;
$array = ['Tailwind', 'Alpine', 'Laravel', 'Livewire'];
$joined = Arr::join($array, ', ');
// Tailwind, Alpine, Laravel, Livewire
$joined = Arr::join($array, ', ', ' and ');
// Tailwind, Alpine, Laravel and Livewire

Arr::keyBy()

The Arr::keyBy method keys the array by the given key. If multiple items have the same key, only the last one will
appear in the new array:
use Illuminate\Support\Arr;
$array = [
['product_id' => 'prod-100', 'name' => 'Desk'],
['product_id' => 'prod-200', 'name' => 'Chair'],
];
$keyed = Arr::keyBy($array, 'product_id');
/*
[
'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],
'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],
]
*/

Arr::last()

The Arr::last method returns the last element of an array passing a given truth test:

Page 455 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$array = [100, 200, 300, 110];
$last = Arr::last($array, function ($value, $key) {
return $value >= 150;
});
// 300

A default value may be passed as the third argument to the method. This value will be returned if no value passes the truth
test:
use Illuminate\Support\Arr;
$last = Arr::last($array, $callback, $default);

Arr::map()

The Arr::map method iterates through the array and passes each value and key to the given callback. The array value is
replaced by the value returned by the callback:
use Illuminate\Support\Arr;
$array = ['first' => 'james', 'last' => 'kirk'];
$mapped = Arr::map($array, function ($value, $key) {
return ucfirst($value);
});
// ['first' => 'James', 'last' => 'Kirk']

Arr::only()

The Arr::only method returns only the specified key / value pairs from the given array:
use Illuminate\Support\Arr;
$array = ['name' => 'Desk', 'price' => 100, 'orders' => 10];
$slice = Arr::only($array, ['name', 'price']);
// ['name' => 'Desk', 'price' => 100]

Arr::pluck()

The Arr::pluck method retrieves all of the values for a given key from an array:

Page 456 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$array = [
['developer' => ['id' => 1, 'name' => 'Taylor']],
['developer' => ['id' => 2, 'name' => 'Abigail']],
];
$names = Arr::pluck($array, 'developer.name');
// ['Taylor', 'Abigail']

You may also specify how you wish the resulting list to be keyed:
use Illuminate\Support\Arr;
$names = Arr::pluck($array, 'developer.name', 'developer.id');
// [1 => 'Taylor', 2 => 'Abigail']

Arr::prepend()

The Arr::prepend method will push an item onto the beginning of an array:
use Illuminate\Support\Arr;
$array = ['one', 'two', 'three', 'four'];
$array = Arr::prepend($array, 'zero');
// ['zero', 'one', 'two', 'three', 'four']

If needed, you may specify the key that should be used for the value:
use Illuminate\Support\Arr;
$array = ['price' => 100];
$array = Arr::prepend($array, 'Desk', 'name');
// ['name' => 'Desk', 'price' => 100]

Arr::prependKeysWith()

The Arr::prependKeysWith prepends all key names of an associative array with the given prefix:

Page 457 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$array = [
'name' => 'Desk',
'price' => 100,
];
$keyed = Arr::prependKeysWith($array, 'product.');
/*
[
'product.name' => 'Desk',
'product.price' => 100,
]
*/

Arr::pull()

The Arr::pull method returns and removes a key / value pair from an array:
use Illuminate\Support\Arr;
$array = ['name' => 'Desk', 'price' => 100];
$name = Arr::pull($array, 'name');
// $name: Desk
// $array: ['price' => 100]

A default value may be passed as the third argument to the method. This value will be returned if the key doesn't exist:
use Illuminate\Support\Arr;
$value = Arr::pull($array, $key, $default);

Arr::query()

The Arr::query method converts the array into a query string:
use Illuminate\Support\Arr;
$array = [
'name' => 'Taylor',
'order' => [
'column' => 'created_at',
'direction' => 'desc'
]
];
Arr::query($array);
// name=Taylor&order[column]=created_at&order[direction]=desc

Page 458 of 1307

Laravel 9.x

Arr::random()

The Arr::random method returns a random value from an array:
use Illuminate\Support\Arr;
$array = [1, 2, 3, 4, 5];
$random = Arr::random($array);
// 4 - (retrieved randomly)

You may also specify the number of items to return as an optional second argument. Note that providing this argument will
return an array even if only one item is desired:
use Illuminate\Support\Arr;
$items = Arr::random($array, 2);
// [2, 5] - (retrieved randomly)

Arr::set()

The Arr::set method sets a value within a deeply nested array using "dot" notation:
use Illuminate\Support\Arr;
$array = ['products' => ['desk' => ['price' => 100]]];
Arr::set($array, 'products.desk.price', 200);
// ['products' => ['desk' => ['price' => 200]]]

Arr::shuffle()

The Arr::shuffle method randomly shuffles the items in the array:
use Illuminate\Support\Arr;
$array = Arr::shuffle([1, 2, 3, 4, 5]);
// [3, 2, 5, 1, 4] - (generated randomly)

Arr::sort()

The Arr::sort method sorts an array by its values:
use Illuminate\Support\Arr;
$array = ['Desk', 'Table', 'Chair'];
$sorted = Arr::sort($array);
// ['Chair', 'Desk', 'Table']

Page 459 of 1307

Laravel 9.x

You may also sort the array by the results of a given closure:
use Illuminate\Support\Arr;
$array = [
['name' => 'Desk'],
['name' => 'Table'],
['name' => 'Chair'],
];
$sorted = array_values(Arr::sort($array, function ($value) {
return $value['name'];
}));
/*
[
['name' => 'Chair'],
['name' => 'Desk'],
['name' => 'Table'],
]
*/

Arr::sortDesc()

The Arr::sortDesc method sorts an array in descending order by its values:
use Illuminate\Support\Arr;
$array = ['Desk', 'Table', 'Chair'];
$sorted = Arr::sortDesc($array);
// ['Table', 'Desk', 'Chair']

You may also sort the array by the results of a given closure:

Page 460 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$array = [
['name' => 'Desk'],
['name' => 'Table'],
['name' => 'Chair'],
];
$sorted = array_values(Arr::sortDesc($array, function ($value) {
return $value['name'];
}));
/*
[
['name' => 'Table'],
['name' => 'Desk'],
['name' => 'Chair'],
]
*/

Arr::sortRecursive()

The Arr::sortRecursive method recursively sorts an array using the sort function for numerically indexed subarrays and the ksort function for associative sub-arrays:
use Illuminate\Support\Arr;
$array = [
['Roman', 'Taylor', 'Li'],
['PHP', 'Ruby', 'JavaScript'],
['one' => 1, 'two' => 2, 'three' => 3],
];
$sorted = Arr::sortRecursive($array);
/*
[
['JavaScript', 'PHP', 'Ruby'],
['one' => 1, 'three' => 3, 'two' => 2],
['Li', 'Roman', 'Taylor'],
]
*/

Arr::toCssClasses()

The Arr::toCssClasses conditionally compiles a CSS class string. The method accepts an array of classes where the
array key contains the class or classes you wish to add, while the value is a boolean expression. If the array element has a
numeric key, it will always be included in the rendered class list:

Page 461 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$isActive = false;
$hasError = true;
$array = ['p-4', 'font-bold' => $isActive, 'bg-red' => $hasError];
$classes = Arr::toCssClasses($array);
/*
'p-4 bg-red'
*/

This method powers Laravel's functionality allowing merging classes with a Blade component's attribute bag as well as the
@class Blade directive.
Arr::undot()

The Arr::undot method expands a single-dimensional array that uses "dot" notation into a multi-dimensional array:
use Illuminate\Support\Arr;
$array = [
'user.name' => 'Kevin Malone',
'user.occupation' => 'Accountant',
];
$array = Arr::undot($array);
// ['user' => ['name' => 'Kevin Malone', 'occupation' => 'Accountant']]

Arr::where()

The Arr::where method filters an array using the given closure:
use Illuminate\Support\Arr;
$array = [100, '200', 300, '400', 500];
$filtered = Arr::where($array, function ($value, $key) {
return is_string($value);
});
// [1 => '200', 3 => '400']

Arr::whereNotNull()

The Arr::whereNotNull method removes all null values from the given array:

Page 462 of 1307

Laravel 9.x

use Illuminate\Support\Arr;
$array = [0, null];
$filtered = Arr::whereNotNull($array);
// [0 => 0]

Arr::wrap()

The Arr::wrap method wraps the given value in an array. If the given value is already an array it will be returned without
modification:
use Illuminate\Support\Arr;
$string = 'Laravel';
$array = Arr::wrap($string);
// ['Laravel']

If the given value is null , an empty array will be returned:
use Illuminate\Support\Arr;
$array = Arr::wrap(null);
// []

data_fill()

The data_fill function sets a missing value within a nested array or object using "dot" notation:
$data = ['products' => ['desk' => ['price' => 100]]];
data_fill($data, 'products.desk.price', 200);
// ['products' => ['desk' => ['price' => 100]]]
data_fill($data, 'products.desk.discount', 10);
// ['products' => ['desk' => ['price' => 100, 'discount' => 10]]]

This function also accepts asterisks as wildcards and will fill the target accordingly:

Page 463 of 1307

Laravel 9.x

$data = [
'products' => [
['name' => 'Desk 1', 'price' => 100],
['name' => 'Desk 2'],
],
];
data_fill($data, 'products.*.price', 200);
/*
[
'products' => [
['name' => 'Desk 1', 'price' => 100],
['name' => 'Desk 2', 'price' => 200],
],
]
*/

data_get()

The data_get function retrieves a value from a nested array or object using "dot" notation:
$data = ['products' => ['desk' => ['price' => 100]]];
$price = data_get($data, 'products.desk.price');
// 100

The data_get function also accepts a default value, which will be returned if the specified key is not found:
$discount = data_get($data, 'products.desk.discount', 0);
// 0

The function also accepts wildcards using asterisks, which may target any key of the array or object:
$data = [
'product-one' => ['name' => 'Desk 1', 'price' => 100],
'product-two' => ['name' => 'Desk 2', 'price' => 150],
];
data_get($data, '*.name');
// ['Desk 1', 'Desk 2'];

data_set()

The data_set function sets a value within a nested array or object using "dot" notation:

Page 464 of 1307

Laravel 9.x

$data = ['products' => ['desk' => ['price' => 100]]];
data_set($data, 'products.desk.price', 200);
// ['products' => ['desk' => ['price' => 200]]]

This function also accepts wildcards using asterisks and will set values on the target accordingly:
$data = [
'products' => [
['name' => 'Desk 1', 'price' => 100],
['name' => 'Desk 2', 'price' => 150],
],
];
data_set($data, 'products.*.price', 200);
/*
[
'products' => [
['name' => 'Desk 1', 'price' => 200],
['name' => 'Desk 2', 'price' => 200],
],
]
*/

By default, any existing values are overwritten. If you wish to only set a value if it doesn't exist, you may pass false as
the fourth argument to the function:
$data = ['products' => ['desk' => ['price' => 100]]];
data_set($data, 'products.desk.price', 200, overwrite: false);
// ['products' => ['desk' => ['price' => 100]]]

head()

The head function returns the first element in the given array:
$array = [100, 200, 300];
$first = head($array);
// 100

last()

The last function returns the last element in the given array:

Page 465 of 1307

Laravel 9.x

$array = [100, 200, 300];
$last = last($array);
// 300

Paths
app_path()

The app_path function returns the fully qualified path to your application's app directory. You may also use the
app_path function to generate a fully qualified path to a file relative to the application directory:
$path = app_path();
$path = app_path('Http/Controllers/Controller.php');

base_path()

The base_path function returns the fully qualified path to your application's root directory. You may also use the
base_path function to generate a fully qualified path to a given file relative to the project root directory:
$path = base_path();
$path = base_path('vendor/bin');

config_path()

The config_path function returns the fully qualified path to your application's config directory. You may also use the
config_path function to generate a fully qualified path to a given file within the application's configuration directory:
$path = config_path();
$path = config_path('app.php');

database_path()

The database_path function returns the fully qualified path to your application's database directory. You may also use
the database_path function to generate a fully qualified path to a given file within the database directory:
$path = database_path();
$path = database_path('factories/UserFactory.php');

lang_path()

The lang_path function returns the fully qualified path to your application's lang directory. You may also use the
lang_path function to generate a fully qualified path to a given file within the directory:
$path = lang_path();
$path = lang_path('en/messages.php');

Page 466 of 1307

Laravel 9.x

mix()

The mix function returns the path to a versioned Mix file:
$path = mix('css/app.css');

public_path()

The public_path function returns the fully qualified path to your application's public directory. You may also use the
public_path function to generate a fully qualified path to a given file within the public directory:
$path = public_path();
$path = public_path('css/app.css');

resource_path()

The resource_path function returns the fully qualified path to your application's resources directory. You may also
use the resource_path function to generate a fully qualified path to a given file within the resources directory:
$path = resource_path();
$path = resource_path('sass/app.scss');

storage_path()

The storage_path function returns the fully qualified path to your application's storage directory. You may also use
the storage_path function to generate a fully qualified path to a given file within the storage directory:
$path = storage_path();
$path = storage_path('app/file.txt');

Strings
__()

The __ function translates the given translation string or translation key using your localization files:
echo __('Welcome to our application');
echo __('messages.welcome');

If the specified translation string or key does not exist, the __ function will return the given value. So, using the example
above, the __ function would return messages.welcome if that translation key does not exist.
class_basename()

The class_basename function returns the class name of the given class with the class's namespace removed:
$class = class_basename('Foo\Bar\Baz');
// Baz

Page 467 of 1307

Laravel 9.x

e()

The e function runs PHP's htmlspecialchars function with the double_encode option set to true by default:
echo e('<html>foo</html>');
// &lt;html&gt;foo&lt;/html&gt;

preg_replace_array()

The preg_replace_array function replaces a given pattern in the string sequentially using an array:
$string = 'The event will take place between :start and :end';
$replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);
// The event will take place between 8:30 and 9:00

Str::after()

The Str::after method returns everything after the given value in a string. The entire string will be returned if the value
does not exist within the string:
use Illuminate\Support\Str;
$slice = Str::after('This is my name', 'This is');
// ' my name'

Str::afterLast()

The Str::afterLast method returns everything after the last occurrence of the given value in a string. The entire string
will be returned if the value does not exist within the string:
use Illuminate\Support\Str;
$slice = Str::afterLast('App\Http\Controllers\Controller', '\\');
// 'Controller'

Str::ascii()

The Str::ascii method will attempt to transliterate the string into an ASCII value:
use Illuminate\Support\Str;
$slice = Str::ascii('Ã»');
// 'u'

Str::before()

The Str::before method returns everything before the given value in a string:

Page 468 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$slice = Str::before('This is my name', 'my name');
// 'This is '

Str::beforeLast()

The Str::beforeLast method returns everything before the last occurrence of the given value in a string:
use Illuminate\Support\Str;
$slice = Str::beforeLast('This is my name', 'is');
// 'This '

Str::between()

The Str::between method returns the portion of a string between two values:
use Illuminate\Support\Str;
$slice = Str::between('This is my name', 'This', 'name');
// ' is my '

Str::betweenFirst()

The Str::betweenFirst method returns the smallest possible portion of a string between two values:
use Illuminate\Support\Str;
$slice = Str::betweenFirst('[a] bc [d]', '[', ']');
// 'a'

Str::camel()

The Str::camel method converts the given string to camelCase :
use Illuminate\Support\Str;
$converted = Str::camel('foo_bar');
// fooBar

Str::contains()

The Str::contains method determines if the given string contains the given value. This method is case sensitive:

Page 469 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$contains = Str::contains('This is my name', 'my');
// true

You may also pass an array of values to determine if the given string contains any of the values in the array:
use Illuminate\Support\Str;
$contains = Str::contains('This is my name', ['my', 'foo']);
// true

Str::containsAll()

The Str::containsAll method determines if the given string contains all of the values in a given array:
use Illuminate\Support\Str;
$containsAll = Str::containsAll('This is my name', ['my', 'name']);
// true

Str::endsWith()

The Str::endsWith method determines if the given string ends with the given value:
use Illuminate\Support\Str;
$result = Str::endsWith('This is my name', 'name');
// true

You may also pass an array of values to determine if the given string ends with any of the values in the array:
use Illuminate\Support\Str;
$result = Str::endsWith('This is my name', ['name', 'foo']);
// true
$result = Str::endsWith('This is my name', ['this', 'foo']);
// false

Str::excerpt()

The Str::excerpt method extracts an excerpt from a given string that matches the first instance of a phrase within that
string:

Page 470 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$excerpt = Str::excerpt('This is my name', 'my', [
'radius' => 3
]);
// '...is my na...'

The radius option, which defaults to 100 , allows you to define the number of characters that should appear on each
side of the truncated string.
In addition, you may use the omission option to define the string that will be prepended and appended to the truncated
string:
use Illuminate\Support\Str;
$excerpt = Str::excerpt('This is my name', 'name', [
'radius' => 3,
'omission' => '(...) '
]);
// '(...) my name'

Str::finish()

The Str::finish method adds a single instance of the given value to a string if it does not already end with that value:
use Illuminate\Support\Str;
$adjusted = Str::finish('this/string', '/');
// this/string/
$adjusted = Str::finish('this/string/', '/');
// this/string/

Str::headline()

The Str::headline method will convert strings delimited by casing, hyphens, or underscores into a space delimited
string with each word's first letter capitalized:
use Illuminate\Support\Str;
$headline = Str::headline('steve_jobs');
// Steve Jobs
$headline = Str::headline('EmailNotificationSent');
// Email Notification Sent

Str::inlineMarkdown()

Page 471 of 1307

Laravel 9.x

The Str::inlineMarkdown method converts GitHub flavored Markdown into inline HTML using CommonMark. However,
unlike the markdown method, it does not wrap all generated HTML in a block-level element:
use Illuminate\Support\Str;
$html = Str::inlineMarkdown('**Laravel**');
// <strong>Laravel</strong>

Str::is()

The Str::is method determines if a given string matches a given pattern. Asterisks may be used as wildcard values:
use Illuminate\Support\Str;
$matches = Str::is('foo*', 'foobar');
// true
$matches = Str::is('baz*', 'foobar');
// false

Str::isAscii()

The Str::isAscii method determines if a given string is 7 bit ASCII:
use Illuminate\Support\Str;
$isAscii = Str::isAscii('Taylor');
// true
$isAscii = Str::isAscii('Ã¼');
// false

Str::isJson()

The Str::isJson method determines if the given string is valid JSON:
use Illuminate\Support\Str;
$result = Str::isJson('[1,2,3]');
// true
$result = Str::isJson('{"first": "John", "last": "Doe"}');
// true
$result = Str::isJson('{first: "John", last: "Doe"}');
// false

Page 472 of 1307

Laravel 9.x

Str::isUlid()

The Str::isUlid method determines if the given string is a valid ULID:
use Illuminate\Support\Str;
$isUlid = Str::isUlid('01gd6r360bp37zj17nxb55yv40');
// true
$isUlid = Str::isUlid('laravel');
// false

Str::isUuid()

The Str::isUuid method determines if the given string is a valid UUID:
use Illuminate\Support\Str;
$isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');
// true
$isUuid = Str::isUuid('laravel');
// false

Str::kebab()

The Str::kebab method converts the given string to kebab-case :
use Illuminate\Support\Str;
$converted = Str::kebab('fooBar');
// foo-bar

Str::lcfirst()

The Str::lcfirst method returns the given string with the first character lowercased:
use Illuminate\Support\Str;
$string = Str::lcfirst('Foo Bar');
// foo Bar

Str::length()

The Str::length method returns the length of the given string:

Page 473 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$length = Str::length('Laravel');
// 7

Str::limit()

The Str::limit method truncates the given string to the specified length:
use Illuminate\Support\Str;
$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);
// The quick brown fox...

You may pass a third argument to the method to change the string that will be appended to the end of the truncated string:
use Illuminate\Support\Str;
$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');
// The quick brown fox (...)

Str::lower()

The Str::lower method converts the given string to lowercase:
use Illuminate\Support\Str;
$converted = Str::lower('LARAVEL');
// laravel

Str::markdown()

The Str::markdown method converts GitHub flavored Markdown into HTML using CommonMark:
use Illuminate\Support\Str;
$html = Str::markdown('# Laravel');
// <h1>Laravel</h1>
$html = Str::markdown('# Taylor <b>Otwell</b>', [
'html_input' => 'strip',
]);
// <h1>Taylor Otwell</h1>

Str::mask()

The Str::mask method masks a portion of a string with a repeated character, and may be used to obfuscate segments
of strings such as email addresses and phone numbers:
Page 474 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$string = Str::mask('taylor@example.com', '*', 3);
// tay***************

If needed, you provide a negative number as the third argument to the mask method, which will instruct the method to
begin masking at the given distance from the end of the string:
$string = Str::mask('taylor@example.com', '*', -15, 3);
// tay***@example.com

Str::orderedUuid()

The Str::orderedUuid method generates a "timestamp first" UUID that may be efficiently stored in an indexed
database column. Each UUID that is generated using this method will be sorted after UUIDs previously generated using the
method:
use Illuminate\Support\Str;
return (string) Str::orderedUuid();

Str::padBoth()

The Str::padBoth method wraps PHP's str_pad function, padding both sides of a string with another string until the
final string reaches a desired length:
use Illuminate\Support\Str;
$padded = Str::padBoth('James', 10, '_');
// '__James___'
$padded = Str::padBoth('James', 10);
// '

James

'

Str::padLeft()

The Str::padLeft method wraps PHP's str_pad function, padding the left side of a string with another string until
the final string reaches a desired length:
use Illuminate\Support\Str;
$padded = Str::padLeft('James', 10, '-=');
// '-=-=-James'
$padded = Str::padLeft('James', 10);
// '

James'

Page 475 of 1307

Laravel 9.x

Str::padRight()

The Str::padRight method wraps PHP's str_pad function, padding the right side of a string with another string until
the final string reaches a desired length:
use Illuminate\Support\Str;
$padded = Str::padRight('James', 10, '-');
// 'James-----'
$padded = Str::padRight('James', 10);
// 'James

'

Str::plural()

The Str::plural method converts a singular word string to its plural form. This function supports any of the languages
support by Laravel's pluralizer:
use Illuminate\Support\Str;
$plural = Str::plural('car');
// cars
$plural = Str::plural('child');
// children

You may provide an integer as a second argument to the function to retrieve the singular or plural form of the string:
use Illuminate\Support\Str;
$plural = Str::plural('child', 2);
// children
$singular = Str::plural('child', 1);
// child

Str::pluralStudly()

The Str::pluralStudly method converts a singular word string formatted in studly caps case to its plural form. This
function supports any of the languages support by Laravel's pluralizer:

Page 476 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$plural = Str::pluralStudly('VerifiedHuman');
// VerifiedHumans
$plural = Str::pluralStudly('UserFeedback');
// UserFeedback

You may provide an integer as a second argument to the function to retrieve the singular or plural form of the string:
use Illuminate\Support\Str;
$plural = Str::pluralStudly('VerifiedHuman', 2);
// VerifiedHumans
$singular = Str::pluralStudly('VerifiedHuman', 1);
// VerifiedHuman

Str::random()

The Str::random method generates a random string of the specified length. This function uses PHP's random_bytes
function:
use Illuminate\Support\Str;
$random = Str::random(40);

Str::remove()

The Str::remove method removes the given value or array of values from the string:
use Illuminate\Support\Str;
$string = 'Peter Piper picked a peck of pickled peppers.';
$removed = Str::remove('e', $string);
// Ptr Pipr pickd a pck of pickld ppprs.

You may also pass false as a third argument to the remove method to ignore case when removing strings.
Str::replace()

The Str::replace method replaces a given string within the string:

Page 477 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$string = 'Laravel 8.x';
$replaced = Str::replace('8.x', '9.x', $string);
// Laravel 9.x

Str::replaceArray()

The Str::replaceArray method replaces a given value in the string sequentially using an array:
use Illuminate\Support\Str;
$string = 'The event will take place between ? and ?';
$replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);
// The event will take place between 8:30 and 9:00

Str::replaceFirst()

The Str::replaceFirst method replaces the first occurrence of a given value in a string:
use Illuminate\Support\Str;
$replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');
// a quick brown fox jumps over the lazy dog

Str::replaceLast()

The Str::replaceLast method replaces the last occurrence of a given value in a string:
use Illuminate\Support\Str;
$replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');
// the quick brown fox jumps over a lazy dog

Str::reverse()

The Str::reverse method reverses the given string:
use Illuminate\Support\Str;
$reversed = Str::reverse('Hello World');
// dlroW olleH

Str::singular()

The Str::singular method converts a string to its singular form. This function supports any of the languages support
by Laravel's pluralizer:
Page 478 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$singular = Str::singular('cars');
// car
$singular = Str::singular('children');
// child

Str::slug()

The Str::slug method generates a URL friendly "slug" from the given string:
use Illuminate\Support\Str;
$slug = Str::slug('Laravel 5 Framework', '-');
// laravel-5-framework

Str::snake()

The Str::snake method converts the given string to snake_case :
use Illuminate\Support\Str;
$converted = Str::snake('fooBar');
// foo_bar
$converted = Str::snake('fooBar', '-');
// foo-bar

Str::squish()

The Str::squish method removes all extraneous white space from a string, including extraneous white space between
words:
use Illuminate\Support\Str;
$string = Str::squish('

laravel

framework

');

// laravel framework

Str::start()

The Str::start method adds a single instance of the given value to a string if it does not already start with that value:

Page 479 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$adjusted = Str::start('this/string', '/');
// /this/string
$adjusted = Str::start('/this/string', '/');
// /this/string

Str::startsWith()

The Str::startsWith method determines if the given string begins with the given value:
use Illuminate\Support\Str;
$result = Str::startsWith('This is my name', 'This');
// true

If an array of possible values is passed, the startsWith method will return true if the string begins with any of the
given values:
$result = Str::startsWith('This is my name', ['This', 'That', 'There']);
// true

Str::studly()

The Str::studly method converts the given string to StudlyCase :
use Illuminate\Support\Str;
$converted = Str::studly('foo_bar');
// FooBar

Str::substr()

The Str::substr method returns the portion of string specified by the start and length parameters:
use Illuminate\Support\Str;
$converted = Str::substr('The Laravel Framework', 4, 7);
// Laravel

Str::substrCount()

The Str::substrCount method returns the number of occurrences of a given value in the given string:

Page 480 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$count = Str::substrCount('If you like ice cream, you will like snow cones.', 'like');
// 2

Str::substrReplace()

The Str::substrReplace method replaces text within a portion of a string, starting at the position specified by the third
argument and replacing the number of characters specified by the fourth argument. Passing 0 to the method's fourth
argument will insert the string at the specified position without replacing any of the existing characters in the string:
use Illuminate\Support\Str;
$result = Str::substrReplace('1300', ':', 2);
// 13:
$result = Str::substrReplace('1300', ':', 2, 0);
// 13:00

Str::swap()

The Str::swap method replaces multiple values in the given string using PHP's strtr function:
use Illuminate\Support\Str;
$string = Str::swap([
'Tacos' => 'Burritos',
'great' => 'fantastic',
], 'Tacos are great!');
// Burritos are fantastic!

Str::title()

The Str::title method converts the given string to Title Case :
use Illuminate\Support\Str;
$converted = Str::title('a nice title uses the correct case');
// A Nice Title Uses The Correct Case

Str::toHtmlString()

The Str::toHtmlString method converts the string instance to an instance of Illuminate\Support\HtmlString ,
which may be displayed in Blade templates:
use Illuminate\Support\Str;
$htmlString = Str::of('Nuno Maduro')->toHtmlString();

Str::ucfirst()

Page 481 of 1307

Laravel 9.x

The Str::ucfirst method returns the given string with the first character capitalized:
use Illuminate\Support\Str;
$string = Str::ucfirst('foo bar');
// Foo bar

Str::ucsplit()

The Str::ucsplit method splits the given string into an array by uppercase characters:
use Illuminate\Support\Str;
$segments = Str::ucsplit('FooBar');
// [0 => 'Foo', 1 => 'Bar']

Str::upper()

The Str::upper method converts the given string to uppercase:
use Illuminate\Support\Str;
$string = Str::upper('laravel');
// LARAVEL

Str::ulid()

The Str::ulid method generates a ULID:
use Illuminate\Support\Str;
return (string) Str::ulid();
// 01gd6r360bp37zj17nxb55yv40

Str::uuid()

The Str::uuid method generates a UUID (version 4):
use Illuminate\Support\Str;
return (string) Str::uuid();

Str::wordCount()

The Str::wordCount method returns the number of words that a string contains:
use Illuminate\Support\Str;
Str::wordCount('Hello, world!'); // 2

Page 482 of 1307

Laravel 9.x

Str::words()

The Str::words method limits the number of words in a string. An additional string may be passed to this method via its
third argument to specify which string should be appended to the end of the truncated string:
use Illuminate\Support\Str;
return Str::words('Perfectly balanced, as all things should be.', 3, ' >>>');
// Perfectly balanced, as >>>

str()

The str function returns a new Illuminate\Support\Stringable instance of the given string. This function is
equivalent to the Str::of method:
$string = str('Taylor')->append(' Otwell');
// 'Taylor Otwell'

If no argument is provided to the str function, the function returns an instance of Illuminate\Support\Str :
$snake = str()->snake('FooBar');
// 'foo_bar'

trans()

The trans function translates the given translation key using your localization files:
echo trans('messages.welcome');

If the specified translation key does not exist, the trans function will return the given key. So, using the example above,
the trans function would return messages.welcome if the translation key does not exist.
trans_choice()

The trans_choice function translates the given translation key with inflection:
echo trans_choice('messages.notifications', $unreadCount);

If the specified translation key does not exist, the trans_choice function will return the given key. So, using the example
above, the trans_choice function would return messages.notifications if the translation key does not exist.

Fluent Strings

Fluent strings provide a more fluent, object-oriented interface for working with string values, allowing you to chain multiple
string operations together using a more readable syntax compared to traditional string operations.
after

The after method returns everything after the given value in a string. The entire string will be returned if the value does
not exist within the string:

Page 483 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$slice = Str::of('This is my name')->after('This is');
// ' my name'

afterLast

The afterLast method returns everything after the last occurrence of the given value in a string. The entire string will
be returned if the value does not exist within the string:
use Illuminate\Support\Str;
$slice = Str::of('App\Http\Controllers\Controller')->afterLast('\\');
// 'Controller'

append

The append method appends the given values to the string:
use Illuminate\Support\Str;
$string = Str::of('Taylor')->append(' Otwell');
// 'Taylor Otwell'

ascii

The ascii method will attempt to transliterate the string into an ASCII value:
use Illuminate\Support\Str;
$string = Str::of('Ã¼')->ascii();
// 'u'

basename

The basename method will return the trailing name component of the given string:
use Illuminate\Support\Str;
$string = Str::of('/foo/bar/baz')->basename();
// 'baz'

If needed, you may provide an "extension" that will be removed from the trailing component:

Page 484 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$string = Str::of('/foo/bar/baz.jpg')->basename('.jpg');
// 'baz'

before

The before method returns everything before the given value in a string:
use Illuminate\Support\Str;
$slice = Str::of('This is my name')->before('my name');
// 'This is '

beforeLast

The beforeLast method returns everything before the last occurrence of the given value in a string:
use Illuminate\Support\Str;
$slice = Str::of('This is my name')->beforeLast('is');
// 'This '

between

The between method returns the portion of a string between two values:
use Illuminate\Support\Str;
$converted = Str::of('This is my name')->between('This', 'name');
// ' is my '

betweenFirst

The betweenFirst method returns the smallest possible portion of a string between two values:
use Illuminate\Support\Str;
$converted = Str::of('[a] bc [d]')->betweenFirst('[', ']');
// 'a'

camel

The camel method converts the given string to camelCase :

Page 485 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$converted = Str::of('foo_bar')->camel();
// fooBar

classBasename

The classBasename method returns the class name of the given class with the class's namespace removed:
use Illuminate\Support\Str;
$class = Str::of('Foo\Bar\Baz')->classBasename();
// Baz

contains

The contains method determines if the given string contains the given value. This method is case sensitive:
use Illuminate\Support\Str;
$contains = Str::of('This is my name')->contains('my');
// true

You may also pass an array of values to determine if the given string contains any of the values in the array:
use Illuminate\Support\Str;
$contains = Str::of('This is my name')->contains(['my', 'foo']);
// true

containsAll

The containsAll method determines if the given string contains all of the values in the given array:
use Illuminate\Support\Str;
$containsAll = Str::of('This is my name')->containsAll(['my', 'name']);
// true

dirname

The dirname method returns the parent directory portion of the given string:
use Illuminate\Support\Str;
$string = Str::of('/foo/bar/baz')->dirname();
// '/foo/bar'

Page 486 of 1307

Laravel 9.x

If necessary, you may specify how many directory levels you wish to trim from the string:
use Illuminate\Support\Str;
$string = Str::of('/foo/bar/baz')->dirname(2);
// '/foo'

excerpt

The excerpt method extracts an excerpt from the string that matches the first instance of a phrase within that string:
use Illuminate\Support\Str;
$excerpt = Str::of('This is my name')->excerpt('my', [
'radius' => 3
]);
// '...is my na...'

The radius option, which defaults to 100 , allows you to define the number of characters that should appear on each
side of the truncated string.
In addition, you may use the omission option to change the string that will be prepended and appended to the truncated
string:
use Illuminate\Support\Str;
$excerpt = Str::of('This is my name')->excerpt('name', [
'radius' => 3,
'omission' => '(...) '
]);
// '(...) my name'

endsWith

The endsWith method determines if the given string ends with the given value:
use Illuminate\Support\Str;
$result = Str::of('This is my name')->endsWith('name');
// true

You may also pass an array of values to determine if the given string ends with any of the values in the array:

Page 487 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$result = Str::of('This is my name')->endsWith(['name', 'foo']);
// true
$result = Str::of('This is my name')->endsWith(['this', 'foo']);
// false

exactly

The exactly method determines if the given string is an exact match with another string:
use Illuminate\Support\Str;
$result = Str::of('Laravel')->exactly('Laravel');
// true

explode

The explode method splits the string by the given delimiter and returns a collection containing each section of the split
string:
use Illuminate\Support\Str;
$collection = Str::of('foo bar baz')->explode(' ');
// collect(['foo', 'bar', 'baz'])

finish

The finish method adds a single instance of the given value to a string if it does not already end with that value:
use Illuminate\Support\Str;
$adjusted = Str::of('this/string')->finish('/');
// this/string/
$adjusted = Str::of('this/string/')->finish('/');
// this/string/

headline

The headline method will convert strings delimited by casing, hyphens, or underscores into a space delimited string
with each word's first letter capitalized:

Page 488 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$headline = Str::of('taylor_otwell')->headline();
// Taylor Otwell
$headline = Str::of('EmailNotificationSent')->headline();
// Email Notification Sent

inlineMarkdown

The inlineMarkdown method converts GitHub flavored Markdown into inline HTML using CommonMark. However, unlike
the markdown method, it does not wrap all generated HTML in a block-level element:
use Illuminate\Support\Str;
$html = Str::of('**Laravel**')->inlineMarkdown();
// <strong>Laravel</strong>

is

The is method determines if a given string matches a given pattern. Asterisks may be used as wildcard values
use Illuminate\Support\Str;
$matches = Str::of('foobar')->is('foo*');
// true
$matches = Str::of('foobar')->is('baz*');
// false

isAscii

The isAscii method determines if a given string is an ASCII string:
use Illuminate\Support\Str;
$result = Str::of('Taylor')->isAscii();
// true
$result = Str::of('Ã¼')->isAscii();
// false

isEmpty

The isEmpty method determines if the given string is empty:

Page 489 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$result = Str::of('

')->trim()->isEmpty();

// true
$result = Str::of('Laravel')->trim()->isEmpty();
// false

isNotEmpty

The isNotEmpty method determines if the given string is not empty:
use Illuminate\Support\Str;
$result = Str::of('

')->trim()->isNotEmpty();

// false
$result = Str::of('Laravel')->trim()->isNotEmpty();
// true

isJson

The isJson method determines if a given string is valid JSON:
use Illuminate\Support\Str;
$result = Str::of('[1,2,3]')->isJson();
// true
$result = Str::of('{"first": "John", "last": "Doe"}')->isJson();
// true
$result = Str::of('{first: "John", last: "Doe"}')->isJson();
// false

isUlid

The isUlid method determines if a given string is a ULID:

Page 490 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$result = Str::of('01gd6r360bp37zj17nxb55yv40')->isUlid();
// true
$result = Str::of('Taylor')->isUlid();
// false

isUuid

The isUuid method determines if a given string is a UUID:
use Illuminate\Support\Str;
$result = Str::of('5ace9ab9-e9cf-4ec6-a19d-5881212a452c')->isUuid();
// true
$result = Str::of('Taylor')->isUuid();
// false

kebab

The kebab method converts the given string to kebab-case :
use Illuminate\Support\Str;
$converted = Str::of('fooBar')->kebab();
// foo-bar

lcfirst

The lcfirst method returns the given string with the first character lowercased:
use Illuminate\Support\Str;
$string = Str::of('Foo Bar')->lcfirst();
// foo Bar

length

The length method returns the length of the given string:
use Illuminate\Support\Str;
$length = Str::of('Laravel')->length();
// 7

Page 491 of 1307

Laravel 9.x

limit

The limit method truncates the given string to the specified length:
use Illuminate\Support\Str;
$truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20);
// The quick brown fox...

You may also pass a second argument to change the string that will be appended to the end of the truncated string:
use Illuminate\Support\Str;
$truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20, ' (...)');
// The quick brown fox (...)

lower

The lower method converts the given string to lowercase:
use Illuminate\Support\Str;
$result = Str::of('LARAVEL')->lower();
// 'laravel'

ltrim

The ltrim method trims the left side of the string:
use Illuminate\Support\Str;
$string = Str::of('
// 'Laravel

Laravel

')->ltrim();

'

$string = Str::of('/Laravel/')->ltrim('/');
// 'Laravel/'

markdown

The markdown method converts GitHub flavored Markdown into HTML:

Page 492 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$html = Str::of('# Laravel')->markdown();
// <h1>Laravel</h1>
$html = Str::of('# Taylor <b>Otwell</b>')->markdown([
'html_input' => 'strip',
]);
// <h1>Taylor Otwell</h1>

mask

The mask method masks a portion of a string with a repeated character, and may be used to obfuscate segments of
strings such as email addresses and phone numbers:
use Illuminate\Support\Str;
$string = Str::of('taylor@example.com')->mask('*', 3);
// tay***************

If needed, you may provide negative numbers as the third or fourth argument to the mask method, which will instruct the
method to begin masking at the given distance from the end of the string:
$string = Str::of('taylor@example.com')->mask('*', -15, 3);
// tay***@example.com
$string = Str::of('taylor@example.com')->mask('*', 4, -4);
// tayl**********.com

match

The match method will return the portion of a string that matches a given regular expression pattern:
use Illuminate\Support\Str;
$result = Str::of('foo bar')->match('/bar/');
// 'bar'
$result = Str::of('foo bar')->match('/foo (.*)/');
// 'bar'

matchAll

The matchAll method will return a collection containing the portions of a string that match a given regular expression
pattern:

Page 493 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$result = Str::of('bar foo bar')->matchAll('/bar/');
// collect(['bar', 'bar'])

If you specify a matching group within the expression, Laravel will return a collection of that group's matches:
use Illuminate\Support\Str;
$result = Str::of('bar fun bar fly')->matchAll('/f(\w*)/');
// collect(['un', 'ly']);

If no matches are found, an empty collection will be returned.
newLine

The newLine method appends an "end of line" character to a string:
use Illuminate\Support\Str;
$padded = Str::of('Laravel')->newLine()->append('Framework');
// 'Laravel
//

Framework'

padBoth

The padBoth method wraps PHP's str_pad function, padding both sides of a string with another string until the final
string reaches the desired length:
use Illuminate\Support\Str;
$padded = Str::of('James')->padBoth(10, '_');
// '__James___'
$padded = Str::of('James')->padBoth(10);
// '

James

'

padLeft

The padLeft method wraps PHP's str_pad function, padding the left side of a string with another string until the final
string reaches the desired length:

Page 494 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$padded = Str::of('James')->padLeft(10, '-=');
// '-=-=-James'
$padded = Str::of('James')->padLeft(10);
// '

James'

padRight

The padRight method wraps PHP's str_pad function, padding the right side of a string with another string until the
final string reaches the desired length:
use Illuminate\Support\Str;
$padded = Str::of('James')->padRight(10, '-');
// 'James-----'
$padded = Str::of('James')->padRight(10);
// 'James

'

pipe

The pipe method allows you to transform the string by passing its current value to the given callable:
use Illuminate\Support\Str;
$hash = Str::of('Laravel')->pipe('md5')->prepend('Checksum: ');
// 'Checksum: a5c95b86291ea299fcbe64458ed12702'
$closure = Str::of('foo')->pipe(function ($str) {
return 'bar';
});
// 'bar'

plural

The plural method converts a singular word string to its plural form. This function supports any of the languages
support by Laravel's pluralizer:

Page 495 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$plural = Str::of('car')->plural();
// cars
$plural = Str::of('child')->plural();
// children

You may provide an integer as a second argument to the function to retrieve the singular or plural form of the string:
use Illuminate\Support\Str;
$plural = Str::of('child')->plural(2);
// children
$plural = Str::of('child')->plural(1);
// child

prepend

The prepend method prepends the given values onto the string:
use Illuminate\Support\Str;
$string = Str::of('Framework')->prepend('Laravel ');
// Laravel Framework

remove

The remove method removes the given value or array of values from the string:
use Illuminate\Support\Str;
$string = Str::of('Arkansas is quite beautiful!')->remove('quite');
// Arkansas is beautiful!

You may also pass false as a second parameter to ignore case when removing strings.
replace

The replace method replaces a given string within the string:
use Illuminate\Support\Str;
$replaced = Str::of('Laravel 6.x')->replace('6.x', '7.x');
// Laravel 7.x

Page 496 of 1307

Laravel 9.x

replaceArray

The replaceArray method replaces a given value in the string sequentially using an array:
use Illuminate\Support\Str;
$string = 'The event will take place between ? and ?';
$replaced = Str::of($string)->replaceArray('?', ['8:30', '9:00']);
// The event will take place between 8:30 and 9:00

replaceFirst

The replaceFirst method replaces the first occurrence of a given value in a string:
use Illuminate\Support\Str;
$replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceFirst('the', 'a');
// a quick brown fox jumps over the lazy dog

replaceLast

The replaceLast method replaces the last occurrence of a given value in a string:
use Illuminate\Support\Str;
$replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceLast('the', 'a');
// the quick brown fox jumps over a lazy dog

replaceMatches

The replaceMatches method replaces all portions of a string matching a pattern with the given replacement string:
use Illuminate\Support\Str;
$replaced = Str::of('(+1) 501-555-1000')->replaceMatches('/[^A-Za-z0-9]++/', '')
// '15015551000'

The replaceMatches method also accepts a closure that will be invoked with each portion of the string matching the
given pattern, allowing you to perform the replacement logic within the closure and return the replaced value:
use Illuminate\Support\Str;
$replaced = Str::of('123')->replaceMatches('/\d/', function ($match) {
return '['.$match[0].']';
});
// '[1][2][3]'

rtrim

Page 497 of 1307

Laravel 9.x

The rtrim method trims the right side of the given string:
use Illuminate\Support\Str;
$string = Str::of('
// '

Laravel

')->rtrim();

Laravel'

$string = Str::of('/Laravel/')->rtrim('/');
// '/Laravel'

scan

The scan method parses input from a string into a collection according to a format supported by the sscanf PHP
function:
use Illuminate\Support\Str;
$collection = Str::of('filename.jpg')->scan('%[^.].%s');
// collect(['filename', 'jpg'])

singular

The singular method converts a string to its singular form. This function supports any of the languages support by
Laravel's pluralizer:
use Illuminate\Support\Str;
$singular = Str::of('cars')->singular();
// car
$singular = Str::of('children')->singular();
// child

slug

The slug method generates a URL friendly "slug" from the given string:
use Illuminate\Support\Str;
$slug = Str::of('Laravel Framework')->slug('-');
// laravel-framework

snake

The snake method converts the given string to snake_case :

Page 498 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$converted = Str::of('fooBar')->snake();
// foo_bar

split

The split method splits a string into a collection using a regular expression:
use Illuminate\Support\Str;
$segments = Str::of('one, two, three')->split('/[\s,]+/');
// collect(["one", "two", "three"])

squish

The squish method removes all extraneous white space from a string, including extraneous white space between words:
use Illuminate\Support\Str;
$string = Str::of('

laravel

framework

')->squish();

// laravel framework

start

The start method adds a single instance of the given value to a string if it does not already start with that value:
use Illuminate\Support\Str;
$adjusted = Str::of('this/string')->start('/');
// /this/string
$adjusted = Str::of('/this/string')->start('/');
// /this/string

startsWith

The startsWith method determines if the given string begins with the given value:
use Illuminate\Support\Str;
$result = Str::of('This is my name')->startsWith('This');
// true

studly

The studly method converts the given string to StudlyCase :

Page 499 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$converted = Str::of('foo_bar')->studly();
// FooBar

substr

The substr method returns the portion of the string specified by the given start and length parameters:
use Illuminate\Support\Str;
$string = Str::of('Laravel Framework')->substr(8);
// Framework
$string = Str::of('Laravel Framework')->substr(8, 5);
// Frame

substrReplace

The substrReplace method replaces text within a portion of a string, starting at the position specified by the second
argument and replacing the number of characters specified by the third argument. Passing 0 to the method's third
argument will insert the string at the specified position without replacing any of the existing characters in the string:
use Illuminate\Support\Str;
$string = Str::of('1300')->substrReplace(':', 2);
// 13:
$string = Str::of('The Framework')->substrReplace(' Laravel', 3, 0);
// The Laravel Framework

swap

The swap method replaces multiple values in the string using PHP's strtr function:
use Illuminate\Support\Str;
$string = Str::of('Tacos are great!')
->swap([
'Tacos' => 'Burritos',
'great' => 'fantastic',
]);
// Burritos are fantastic!

tap

The tap method passes the string to the given closure, allowing you to examine and interact with the string while not
affecting the string itself. The original string is returned by the tap method regardless of what is returned by the closure:
Page 500 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$string = Str::of('Laravel')
->append(' Framework')
->tap(function ($string) {
dump('String after append: '.$string);
})
->upper();
// LARAVEL FRAMEWORK

test

The test method determines if a string matches the given regular expression pattern:
use Illuminate\Support\Str;
$result = Str::of('Laravel Framework')->test('/Laravel/');
// true

title

The title method converts the given string to Title Case :
use Illuminate\Support\Str;
$converted = Str::of('a nice title uses the correct case')->title();
// A Nice Title Uses The Correct Case

trim

The trim method trims the given string:
use Illuminate\Support\Str;
$string = Str::of('

Laravel

')->trim();

// 'Laravel'
$string = Str::of('/Laravel/')->trim('/');
// 'Laravel'

ucfirst

The ucfirst method returns the given string with the first character capitalized:
use Illuminate\Support\Str;
$string = Str::of('foo bar')->ucfirst();
// Foo bar

Page 501 of 1307

Laravel 9.x

ucsplit

The ucsplit method splits the given string into a collection by uppercase characters:
use Illuminate\Support\Str;
$string = Str::of('Foo Bar')->ucsplit();
// collect(['Foo', 'Bar'])

upper

The upper method converts the given string to uppercase:
use Illuminate\Support\Str;
$adjusted = Str::of('laravel')->upper();
// LARAVEL

when

The when method invokes the given closure if a given condition is true . The closure will receive the fluent string
instance:
use Illuminate\Support\Str;
$string = Str::of('Taylor')
->when(true, function ($string) {
return $string->append(' Otwell');
});
// 'Taylor Otwell'

If necessary, you may pass another closure as the third parameter to the when method. This closure will execute if the
condition parameter evaluates to false .
whenContains

The whenContains method invokes the given closure if the string contains the given value. The closure will receive the
fluent string instance:
use Illuminate\Support\Str;
$string = Str::of('tony stark')
->whenContains('tony', function ($string) {
return $string->title();
});
// 'Tony Stark'

If necessary, you may pass another closure as the third parameter to the when method. This closure will execute if the
string does not contain the given value.
You may also pass an array of values to determine if the given string contains any of the values in the array:
Page 502 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$string = Str::of('tony stark')
->whenContains(['tony', 'hulk'], function ($string) {
return $string->title();
});
// Tony Stark

whenContainsAll

The whenContainsAll method invokes the given closure if the string contains all of the given sub-strings. The closure
will receive the fluent string instance:
use Illuminate\Support\Str;
$string = Str::of('tony stark')
->whenContainsAll(['tony', 'stark'], function ($string) {
return $string->title();
});
// 'Tony Stark'

If necessary, you may pass another closure as the third parameter to the when method. This closure will execute if the
condition parameter evaluates to false .
whenEmpty

The whenEmpty method invokes the given closure if the string is empty. If the closure returns a value, that value will also
be returned by the whenEmpty method. If the closure does not return a value, the fluent string instance will be returned:
use Illuminate\Support\Str;
$string = Str::of('

')->whenEmpty(function ($string) {

return $string->trim()->prepend('Laravel');
});
// 'Laravel'

whenNotEmpty

The whenNotEmpty method invokes the given closure if the string is not empty. If the closure returns a value, that value
will also be returned by the whenNotEmpty method. If the closure does not return a value, the fluent string instance will
be returned:
use Illuminate\Support\Str;
$string = Str::of('Framework')->whenNotEmpty(function ($string) {
return $string->prepend('Laravel ');
});
// 'Laravel Framework'

whenStartsWith

Page 503 of 1307

Laravel 9.x

The whenStartsWith method invokes the given closure if the string starts with the given sub-string. The closure will
receive the fluent string instance:
use Illuminate\Support\Str;
$string = Str::of('disney world')->whenStartsWith('disney', function ($string) {
return $string->title();
});
// 'Disney World'

whenEndsWith

The whenEndsWith method invokes the given closure if the string ends with the given sub-string. The closure will receive
the fluent string instance:
use Illuminate\Support\Str;
$string = Str::of('disney world')->whenEndsWith('world', function ($string) {
return $string->title();
});
// 'Disney World'

whenExactly

The whenExactly method invokes the given closure if the string exactly matches the given string. The closure will
receive the fluent string instance:
use Illuminate\Support\Str;
$string = Str::of('laravel')->whenExactly('laravel', function ($string) {
return $string->title();
});
// 'Laravel'

whenNotExactly

The whenNotExactly method invokes the given closure if the string does not exactly match the given string. The closure
will receive the fluent string instance:
use Illuminate\Support\Str;
$string = Str::of('framework')->whenNotExactly('laravel', function ($string) {
return $string->title();
});
// 'Framework'

whenIs

The whenIs method invokes the given closure if the string matches a given pattern. Asterisks may be used as wildcard
values. The closure will receive the fluent string instance:

Page 504 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$string = Str::of('foo/bar')->whenIs('foo/*', function ($string) {
return $string->append('/baz');
});
// 'foo/bar/baz'

whenIsAscii

The whenIsAscii method invokes the given closure if the string is 7 bit ASCII. The closure will receive the fluent string
instance:
use Illuminate\Support\Str;
$string = Str::of('laravel')->whenIsAscii(function ($string) {
return $string->title();
});
// 'Laravel'

whenIsUlid

The whenIsUlid method invokes the given closure if the string is a valid ULID. The closure will receive the fluent string
instance:
use Illuminate\Support\Str;
$string = Str::of('01gd6r360bp37zj17nxb55yv40')->whenIsUlid(function ($string) {
return $string->substr(0, 8);
});
// '01gd6r36'

whenIsUuid

The whenIsUuid method invokes the given closure if the string is a valid UUID. The closure will receive the fluent string
instance:
use Illuminate\Support\Str;
$string = Str::of('a0a2a2d2-0b87-4a18-83f2-2529882be2de')->whenIsUuid(function ($string) {
return $string->substr(0, 8);
});
// 'a0a2a2d2'

whenTest

The whenTest method invokes the given closure if the string matches the given regular expression. The closure will
receive the fluent string instance:

Page 505 of 1307

Laravel 9.x

use Illuminate\Support\Str;
$string = Str::of('laravel framework')->whenTest('/laravel/', function ($string) {
return $string->title();
});
// 'Laravel Framework'

wordCount

The wordCount method returns the number of words that a string contains:
use Illuminate\Support\Str;
Str::of('Hello, world!')->wordCount(); // 2

words

The words method limits the number of words in a string. If necessary, you may specify an additional string that will be
appended to the truncated string:
use Illuminate\Support\Str;
$string = Str::of('Perfectly balanced, as all things should be.')->words(3, ' >>>');
// Perfectly balanced, as >>>

URLs
action()

The action function generates a URL for the given controller action:
use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);

If the method accepts route parameters, you may pass them as the second argument to the method:
$url = action([UserController::class, 'profile'], ['id' => 1]);

asset()

The asset function generates a URL for an asset using the current scheme of the request (HTTP or HTTPS):
$url = asset('img/photo.jpg');

You can configure the asset URL host by setting the ASSET_URL variable in your .env file. This can be useful if you host
your assets on an external service like Amazon S3 or another CDN:

Page 506 of 1307

Laravel 9.x

// ASSET_URL=http://example.com/assets
$url = asset('img/photo.jpg'); // http://example.com/assets/img/photo.jpg

route()

The route function generates a URL for a given named route:
$url = route('route.name');

If the route accepts parameters, you may pass them as the second argument to the function:
$url = route('route.name', ['id' => 1]);

By default, the route function generates an absolute URL. If you wish to generate a relative URL, you may pass false
as the third argument to the function:
$url = route('route.name', ['id' => 1], false);

secure_asset()

The secure_asset function generates a URL for an asset using HTTPS:
$url = secure_asset('img/photo.jpg');

secure_url()

The secure_url function generates a fully qualified HTTPS URL to the given path. Additional URL segments may be
passed in the function's second argument:
$url = secure_url('user/profile');
$url = secure_url('user/profile', [1]);

to_route()

The to_route function generates a redirect HTTP response for a given named route:
return to_route('users.show', ['user' => 1]);

If necessary, you may pass the HTTP status code that should be assigned to the redirect and any additional response
headers as the third and fourth arguments to the to_route method:
return to_route('users.show', ['user' => 1], 302, ['X-Framework' => 'Laravel']);

url()

The url function generates a fully qualified URL to the given path:
$url = url('user/profile');
$url = url('user/profile', [1]);

Page 507 of 1307

Laravel 9.x

If no path is provided, an Illuminate\Routing\UrlGenerator instance is returned:
$current = url()->current();
$full = url()->full();
$previous = url()->previous();

Miscellaneous
abort()

The abort function throws an HTTP exception which will be rendered by the exception handler:
abort(403);

You may also provide the exception's message and custom HTTP response headers that should be sent to the browser:
abort(403, 'Unauthorized.', $headers);

abort_if()

The abort_if function throws an HTTP exception if a given boolean expression evaluates to true :
abort_if(! Auth::user()->isAdmin(), 403);

Like the abort method, you may also provide the exception's response text as the third argument and an array of custom
response headers as the fourth argument to the function.
abort_unless()

The abort_unless function throws an HTTP exception if a given boolean expression evaluates to false :
abort_unless(Auth::user()->isAdmin(), 403);

Like the abort method, you may also provide the exception's response text as the third argument and an array of custom
response headers as the fourth argument to the function.
app()

The app function returns the service container instance:
$container = app();

You may pass a class or interface name to resolve it from the container:
$api = app('HelpSpot\API');

auth()

The auth function returns an authenticator instance. You may use it as an alternative to the Auth facade:
$user = auth()->user();

Page 508 of 1307

Laravel 9.x

If needed, you may specify which guard instance you would like to access:
$user = auth('admin')->user();

back()

The back function generates a redirect HTTP response to the user's previous location:
return back($status = 302, $headers = [], $fallback = '/');
return back();

bcrypt()

The bcrypt function hashes the given value using Bcrypt. You may use this function as an alternative to the Hash
facade:
$password = bcrypt('my-secret-password');

blank()

The blank function determines whether the given value is "blank":
blank('');
blank('

');

blank(null);
blank(collect());
// true
blank(0);
blank(true);
blank(false);
// false

For the inverse of blank , see the filled method.
broadcast()

The broadcast function broadcasts the given event to its listeners:
broadcast(new UserRegistered($user));
broadcast(new UserRegistered($user))->toOthers();

cache()

The cache function may be used to get values from the cache. If the given key does not exist in the cache, an optional
default value will be returned:
$value = cache('key');
$value = cache('key', 'default');

Page 509 of 1307

Laravel 9.x

You may add items to the cache by passing an array of key / value pairs to the function. You should also pass the number
of seconds or duration the cached value should be considered valid:
cache(['key' => 'value'], 300);
cache(['key' => 'value'], now()->addSeconds(10));

class_uses_recursive()

The class_uses_recursive function returns all traits used by a class, including traits used by all of its parent classes:
$traits = class_uses_recursive(App\Models\User::class);

collect()

The collect function creates a collection instance from the given value:
$collection = collect(['taylor', 'abigail']);

config()

The config function gets the value of a configuration variable. The configuration values may be accessed using "dot"
syntax, which includes the name of the file and the option you wish to access. A default value may be specified and is
returned if the configuration option does not exist:
$value = config('app.timezone');
$value = config('app.timezone', $default);

You may set configuration variables at runtime by passing an array of key / value pairs. However, note that this function
only affects the configuration value for the current request and does not update your actual configuration values:
config(['app.debug' => true]);

cookie()

The cookie function creates a new cookie instance:
$cookie = cookie('name', 'value', $minutes);

csrf_field()

The csrf_field function generates an HTML hidden input field containing the value of the CSRF token. For example,
using Blade syntax:
{{ csrf_field() }}

csrf_token()

The csrf_token function retrieves the value of the current CSRF token:
$token = csrf_token();

Page 510 of 1307

Laravel 9.x

decrypt()

The decrypt function decrypts the given value. You may use this function as an alternative to the Crypt facade:
$password = decrypt($value);

dd()

The dd function dumps the given variables and ends execution of the script:
dd($value);
dd($value1, $value2, $value3, ...);

If you do not want to halt the execution of your script, use the dump function instead.
dispatch()

The dispatch function pushes the given job onto the Laravel job queue:
dispatch(new App\Jobs\SendEmails);

dump()

The dump function dumps the given variables:
dump($value);
dump($value1, $value2, $value3, ...);

If you want to stop executing the script after dumping the variables, use the dd function instead.
encrypt()

The encrypt function encrypts the given value. You may use this function as an alternative to the Crypt facade:
$secret = encrypt('my-secret-value');

env()

The env function retrieves the value of an environment variable or returns a default value:
$env = env('APP_ENV');
$env = env('APP_ENV', 'production');

If you execute the config:cache command during your deployment process, you should be sure
that you are only calling the env function from within your configuration files. Once the
configuration has been cached, the .env file will not be loaded and all calls to the env function
will return null .

Page 511 of 1307

Laravel 9.x

event()

The event function dispatches the given event to its listeners:
event(new UserRegistered($user));

fake()

The fake function resolves a Faker singleton from the container, which can be useful when creating fake data in model
factories, database seeding, tests, and prototyping views:
@for($i = 0; $i < 10; $i++)
<dl>
<dt>Name</dt>
<dd>{{ fake()->name() }}</dd>
<dt>Email</dt>
<dd>{{ fake()->unique()->safeEmail() }}</dd>
</dl>
@endfor

By default, the fake function will utilize the app.faker_locale configuration option in your config/app.php
configuration file; however, you may also specify the locale by passing it to the fake function. Each locale will resolve an
individual singleton:
fake('nl_NL')->name()

filled()

The filled function determines whether the given value is not "blank":
filled(0);
filled(true);
filled(false);
// true
filled('');
filled('

');

filled(null);
filled(collect());
// false

For the inverse of filled , see the blank method.
info()

The info function will write information to your application's log:
info('Some helpful information!');

An array of contextual data may also be passed to the function:

Page 512 of 1307

Laravel 9.x

info('User login attempt failed.', ['id' => $user->id]);

logger()

The logger function can be used to write a debug level message to the log:
logger('Debug message');

An array of contextual data may also be passed to the function:
logger('User has logged in.', ['id' => $user->id]);

A logger instance will be returned if no value is passed to the function:
logger()->error('You are not allowed here.');

method_field()

The method_field function generates an HTML hidden input field containing the spoofed value of the form's HTTP
verb. For example, using Blade syntax:
<form method="POST">
{{ method_field('DELETE') }}
</form>

now()

The now function creates a new Illuminate\Support\Carbon instance for the current time:
$now = now();

old()

The old function retrieves an old input value flashed into the session:
$value = old('value');
$value = old('value', 'default');

Since the "default value" provided as the second argument to the old function is often an attribute of an Eloquent model,
Laravel allows you to simply pass the entire Eloquent model as the second argument to the old function. When doing so,
Laravel will assume the first argument provided to the old function is the name of the Eloquent attribute that should be
considered the "default value":
{{ old('name', $user->name) }}
// Is equivalent to...
{{ old('name', $user) }}

optional()

Page 513 of 1307

Laravel 9.x

The optional function accepts any argument and allows you to access properties or call methods on that object. If the
given object is null , properties and methods will return null instead of causing an error:
return optional($user->address)->street;
{!! old('name', optional($user)->name) !!}

The optional function also accepts a closure as its second argument. The closure will be invoked if the value provided
as the first argument is not null:
return optional(User::find($id), function ($user) {
return $user->name;
});

policy()

The policy method retrieves a policy instance for a given class:
$policy = policy(App\Models\User::class);

redirect()

The redirect function returns a redirect HTTP response, or returns the redirector instance if called with no arguments:
return redirect($to = null, $status = 302, $headers = [], $https = null);
return redirect('/home');
return redirect()->route('route.name');

report()

The report function will report an exception using your exception handler:
report($e);

The report function also accepts a string as an argument. When a string is given to the function, the function will create
an exception with the given string as its message:
report('Something went wrong.');

report_if()

The report_if function will report an exception using your exception handler if the given condition is true :
report_if($shouldReport, $e);
report_if($shouldReport, 'Something went wrong.');

report_unless()

The report_unless function will report an exception using your exception handler if the given condition is false :

Page 514 of 1307

Laravel 9.x

report_unless($reportingDisabled, $e);
report_unless($reportingDisabled, 'Something went wrong.');

request()

The request function returns the current request instance or obtains an input field's value from the current request:
$request = request();
$value = request('key', $default);

rescue()

The rescue function executes the given closure and catches any exceptions that occur during its execution. All
exceptions that are caught will be sent to your exception handler; however, the request will continue processing:
return rescue(function () {
return $this->method();
});

You may also pass a second argument to the rescue function. This argument will be the "default" value that should be
returned if an exception occurs while executing the closure:
return rescue(function () {
return $this->method();
}, false);
return rescue(function () {
return $this->method();
}, function () {
return $this->failure();
});

resolve()

The resolve function resolves a given class or interface name to an instance using the service container:
$api = resolve('HelpSpot\API');

response()

The response function creates a response instance or obtains an instance of the response factory:
return response('Hello World', 200, $headers);
return response()->json(['foo' => 'bar'], 200, $headers);

retry()

The retry function attempts to execute the given callback until the given maximum attempt threshold is met. If the
callback does not throw an exception, its return value will be returned. If the callback throws an exception, it will
automatically be retried. If the maximum attempt count is exceeded, the exception will be thrown:

Page 515 of 1307

Laravel 9.x

return retry(5, function () {
// Attempt 5 times while resting 100ms between attempts...
}, 100);

If you would like to manually calculate the number of milliseconds to sleep between attempts, you may pass a closure as
the third argument to the retry function:
return retry(5, function () {
// ...
}, function ($attempt, $exception) {
return $attempt * 100;
});

For convenience, you may provide an array as the first argument to the retry function. This array will be used to
determine how many milliseconds to sleep between subsequent attempts:
return retry([100, 200], function () {
// Sleep for 100ms on first retry, 200ms on second retry...
});

To only retry under specific conditions, you may pass a closure as the fourth argument to the retry function:
return retry(5, function () {
// ...
}, 100, function ($exception) {
return $exception instanceof RetryException;
});

session()

The session function may be used to get or set session values:
$value = session('key');

You may set values by passing an array of key / value pairs to the function:
session(['chairs' => 7, 'instruments' => 3]);

The session store will be returned if no value is passed to the function:
$value = session()->get('key');
session()->put('key', $value);

tap()

The tap function accepts two arguments: an arbitrary $value and a closure. The $value will be passed to the
closure and then be returned by the tap function. The return value of the closure is irrelevant:

Page 516 of 1307

Laravel 9.x

$user = tap(User::first(), function ($user) {
$user->name = 'taylor';
$user->save();
});

If no closure is passed to the tap function, you may call any method on the given $value . The return value of the
method you call will always be $value , regardless of what the method actually returns in its definition. For example, the
Eloquent update method typically returns an integer. However, we can force the method to return the model itself by
chaining the update method call through the tap function:
$user = tap($user)->update([
'name' => $name,
'email' => $email,
]);

To add a tap method to a class, you may add the Illuminate\Support\Traits\Tappable trait to the class. The
tap method of this trait accepts a Closure as its only argument. The object instance itself will be passed to the Closure
and then be returned by the tap method:
return $user->tap(function ($user) {
//
});

throw_if()

The throw_if function throws the given exception if a given boolean expression evaluates to true :
throw_if(! Auth::user()->isAdmin(), AuthorizationException::class);
throw_if(
! Auth::user()->isAdmin(),
AuthorizationException::class,
'You are not allowed to access this page.'
);

throw_unless()

The throw_unless function throws the given exception if a given boolean expression evaluates to false :
throw_unless(Auth::user()->isAdmin(), AuthorizationException::class);
throw_unless(
Auth::user()->isAdmin(),
AuthorizationException::class,
'You are not allowed to access this page.'
);

today()

The today function creates a new Illuminate\Support\Carbon instance for the current date:
$today = today();

Page 517 of 1307

Laravel 9.x

trait_uses_recursive()

The trait_uses_recursive function returns all traits used by a trait:
$traits = trait_uses_recursive(\Illuminate\Notifications\Notifiable::class);

transform()

The transform function executes a closure on a given value if the value is not blank and then returns the return value of
the closure:
$callback = function ($value) {
return $value * 2;
};
$result = transform(5, $callback);
// 10

A default value or closure may be passed as the third argument to the function. This value will be returned if the given
value is blank:
$result = transform(null, $callback, 'The value is blank');
// The value is blank

validator()

The validator function creates a new validator instance with the given arguments. You may use it as an alternative to
the Validator facade:
$validator = validator($data, $rules, $messages);

value()

The value function returns the value it is given. However, if you pass a closure to the function, the closure will be
executed and its returned value will be returned:
$result = value(true);
// true
$result = value(function () {
return false;
});
// false

Additional arguments may be passed to the value function. If the first argument is a closure then the additional
parameters will be passed to the closure as arguments, otherwise they will be ignored:

Page 518 of 1307

Laravel 9.x

$result = value(function ($name) {
return $parameter;
}, 'Taylor');
// 'Taylor'

view()

The view function retrieves a view instance:
return view('auth.login');

with()

The with function returns the value it is given. If a closure is passed as the second argument to the function, the closure
will be executed and its returned value will be returned:
$callback = function ($value) {
return is_numeric($value) ? $value * 2 : 0;
};
$result = with(5, $callback);
// 10
$result = with(null, $callback);
// 0
$result = with(5, null);
// 5

Other Utilities
Benchmarking

Sometimes you may wish to quickly test the performance of certain parts of your application. On those occasions, you may
utilize the Benchmark support class to measure the number of milliseconds it takes for the given callbacks to complete:
<?php
use App\Models\User;
use Illuminate\Support\Benchmark;
Benchmark::dd(fn () => User::find(1)); // 0.1 ms
Benchmark::dd([
'Scenario 1' => fn () => User::count(), // 0.5 ms
'Scenario 2' => fn () => User::all()->count(), // 20.0 ms
]);

By default, the given callbacks will be executed once (one iteration), and their duration will be displayed in the browser /
console.
Page 519 of 1307

Laravel 9.x

To invoke a callback more than once, you may specify the number of iterations that the callback should be invoked as the
second argument to the method. When executing a callback more than once, the Benchmark class will return the average
amount of milliseconds it took to execute the callback across all iterations:
Benchmark::dd(fn () => User::count(), iterations: 10); // 0.5 ms

Lottery

Laravel's lottery class may be used to execute callbacks based on a set of given odds. This can be particularly useful when
you only want to execute code for a percentage of your incoming requests:
use Illuminate\Support\Lottery;
Lottery::odds(1, 20)
->winner(fn () => $user->won())
->loser(fn () => $user->lost())
->choose();

You may combine Laravel's lottery class with other Laravel features. For example, you may wish to only report a small
percentage of slow queries to your exception handler. And, since the lottery class is callable, we may pass an instance of
the class into any method that accepts callables:
use Carbon\CarbonInterval;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Lottery;
DB::whenQueryingForLongerThan(
CarbonInterval::seconds(2),
Lottery::odds(1, 100)->winner(fn () => report('Querying > 2 seconds.')),
);

Testing Lotteries
Laravel provides some simple methods to allow you to easily test your application's lottery invocations:
// Lottery will always win...
Lottery::alwaysWin();
// Lottery will always lose...
Lottery::alwaysLose();
// Lottery will win then lose, and finally return to normal behavior...
Lottery::fix([true, false]);
// Lottery will return to normal behavior...
Lottery::determineResultsNormally();

Page 520 of 1307

Laravel 9.x

Introduction
Making Requests
Request Data
Headers
Authentication
Timeout
Retries
Error Handling
Guzzle Middleware
Guzzle Options
Concurrent Requests
Macros
Testing
Faking Responses
Inspecting Requests
Preventing Stray Requests
Events

HTTP Client

Introduction

Laravel provides an expressive, minimal API around the Guzzle HTTP client, allowing you to quickly make outgoing HTTP
requests to communicate with other web applications. Laravel's wrapper around Guzzle is focused on its most common
use cases and a wonderful developer experience.
Before getting started, you should ensure that you have installed the Guzzle package as a dependency of your application.
By default, Laravel automatically includes this dependency. However, if you have previously removed the package, you may
install it again via Composer:
composer require guzzlehttp/guzzle

Making Requests

To make requests, you may use the head , get , post , put , patch , and delete methods provided by the Http
facade. First, let's examine how to make a basic GET request to another URL:
use Illuminate\Support\Facades\Http;
$response = Http::get('http://example.com');

The get method returns an instance of Illuminate\Http\Client\Response , which provides a variety of methods
that may be used to inspect the response:

Page 521 of 1307

Laravel 9.x

$response->body() : string;
$response->json($key = null, $default = null) : array|mixed;
$response->object() : object;
$response->collect($key = null) : Illuminate\Support\Collection;
$response->status() : int;
$response->successful() : bool;
$response->redirect(): bool;
$response->failed() : bool;
$response->clientError() : bool;
$response->header($header) : string;
$response->headers() : array;

The Illuminate\Http\Client\Response object also implements the PHP ArrayAccess interface, allowing you to
access JSON response data directly on the response:
return Http::get('http://example.com/users/1')['name'];

In addition to the response methods listed above, the following methods may be used to determine if the response has a
given status code:
$response->ok() : bool;

// 200 OK

$response->created() : bool;

// 201 Created

$response->accepted() : bool;

// 202 Accepted

$response->noContent() : bool;

// 204 No Content

$response->movedPermanently() : bool;

// 301 Moved Permanently

$response->found() : bool;

// 302 Found

$response->badRequest() : bool;

// 400 Bad Request

$response->unauthorized() : bool;

// 401 Unauthorized

$response->paymentRequired() : bool;

// 402 Payment Required

$response->forbidden() : bool;

// 403 Forbidden

$response->notFound() : bool;

// 404 Not Found

$response->requestTimeout() : bool;

// 408 Request Timeout

$response->conflict() : bool;

// 409 Conflict

$response->unprocessableEntity() : bool; // 422 Unprocessable Entity
$response->tooManyRequests() : bool;

// 429 Too Many Requests

$response->serverError() : bool;

// 500 Internal Server Error

URI Templates
The HTTP client also allows you to construct request URLs using the URI template specification. To define the URL
parameters that can be expanded by your URI template, you may use the withUrlParameters method:
Http::withUrlParameters([
'endpoint' => 'https://laravel.com',
'page' => 'docs',
'version' => '9.x',
'topic' => 'validation',
])->get('{+endpoint}/{page}/{version}/{topic}');

Dumping Requests
If you would like to dump the outgoing request instance before it is sent and terminate the script's execution, you may add
the dd method to the beginning of your request definition:

Page 522 of 1307

Laravel 9.x

return Http::dd()->get('http://example.com');

Request Data

Of course, it is common when making POST , PUT , and PATCH requests to send additional data with your request, so
these methods accept an array of data as their second argument. By default, data will be sent using the
application/json content type:
use Illuminate\Support\Facades\Http;
$response = Http::post('http://example.com/users', [
'name' => 'Steve',
'role' => 'Network Administrator',
]);

GET Request Query Parameters
When making GET requests, you may either append a query string to the URL directly or pass an array of key / value pairs
as the second argument to the get method:
$response = Http::get('http://example.com/users', [
'name' => 'Taylor',
'page' => 1,
]);

Sending Form URL Encoded Requests
If you would like to send data using the application/x-www-form-urlencoded content type, you should call the
asForm method before making your request:
$response = Http::asForm()->post('http://example.com/users', [
'name' => 'Sara',
'role' => 'Privacy Consultant',
]);

Sending A Raw Request Body
You may use the withBody method if you would like to provide a raw request body when making a request. The content
type may be provided via the method's second argument:
$response = Http::withBody(
base64_encode($photo), 'image/jpeg'
)->post('http://example.com/photo');

Multi-Part Requests
If you would like to send files as multi-part requests, you should call the attach method before making your request.
This method accepts the name of the file and its contents. If needed, you may provide a third argument which will be
considered the file's filename:
$response = Http::attach(
'attachment', file_get_contents('photo.jpg'), 'photo.jpg'
)->post('http://example.com/attachments');

Page 523 of 1307

Laravel 9.x

Instead of passing the raw contents of a file, you may pass a stream resource:
$photo = fopen('photo.jpg', 'r');
$response = Http::attach(
'attachment', $photo, 'photo.jpg'
)->post('http://example.com/attachments');

Headers

Headers may be added to requests using the withHeaders method. This withHeaders method accepts an array of key
/ value pairs:
$response = Http::withHeaders([
'X-First' => 'foo',
'X-Second' => 'bar'
])->post('http://example.com/users', [
'name' => 'Taylor',
]);

You may use the accept method to specify the content type that your application is expecting in response to your
request:
$response = Http::accept('application/json')->get('http://example.com/users');

For convenience, you may use the acceptJson method to quickly specify that your application expects the
application/json content type in response to your request:
$response = Http::acceptJson()->get('http://example.com/users');

Authentication

You may specify basic and digest authentication credentials using the withBasicAuth and withDigestAuth methods,
respectively:
// Basic authentication...
$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);
// Digest authentication...
$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);

Bearer Tokens
If you would like to quickly add a bearer token to the request's Authorization header, you may use the withToken
method:
$response = Http::withToken('token')->post(/* ... */);

Timeout

The timeout method may be used to specify the maximum number of seconds to wait for a response:

Page 524 of 1307

Laravel 9.x

$response = Http::timeout(3)->get(/* ... */);

If the given timeout is exceeded, an instance of Illuminate\Http\Client\ConnectionException will be thrown.
You may specify the maximum number of seconds to wait while trying to connect to a server using the connectTimeout
method:
$response = Http::connectTimeout(3)->get(/* ... */);

Retries

If you would like the HTTP client to automatically retry the request if a client or server error occurs, you may use the
retry method. The retry method accepts the maximum number of times the request should be attempted and the
number of milliseconds that Laravel should wait in between attempts:
$response = Http::retry(3, 100)->post(/* ... */);

If needed, you may pass a third argument to the retry method. The third argument should be a callable that determines
if the retries should actually be attempted. For example, you may wish to only retry the request if the initial request
encounters an ConnectionException :
$response = Http::retry(3, 100, function ($exception, $request) {
return $exception instanceof ConnectionException;
})->post(/* ... */);

If a request attempt fails, you may wish to make a change to the request before a new attempt is made. You can achieve
this by modifying the request argument provided to the callable you provided to the retry method. For example, you
might want to retry the request with a new authorization token if the first attempt returned an authentication error:
$response = Http::withToken($this->getToken())->retry(2, 0, function ($exception, $request) {
if (! $exception instanceof RequestException || $exception->response->status() !== 401) {
return false;
}
$request->withToken($this->getNewToken());
return true;
})->post(/* ... */);

If all of the requests fail, an instance of Illuminate\Http\Client\RequestException will be thrown. If you would like
to disable this behavior, you may provide a throw argument with a value of false . When disabled, the last response
received by the client will be returned after all retries have been attempted:
$response = Http::retry(3, 100, throw: false)->post(/* ... */);

If all of the requests fail because of a connection issue, a
Illuminate\Http\Client\ConnectionException will still be thrown even when the throw
argument is set to false .

Page 525 of 1307

Laravel 9.x

Error Handling

Unlike Guzzle's default behavior, Laravel's HTTP client wrapper does not throw exceptions on client or server errors ( 400
and 500 level responses from servers). You may determine if one of these errors was returned using the successful ,
clientError , or serverError methods:
// Determine if the status code is >= 200 and < 300...
$response->successful();
// Determine if the status code is >= 400...
$response->failed();
// Determine if the response has a 400 level status code...
$response->clientError();
// Determine if the response has a 500 level status code...
$response->serverError();
// Immediately execute the given callback if there was a client or server error...
$response->onError(callable $callback);

Throwing Exceptions
If you have a response instance and would like to throw an instance of Illuminate\Http\Client\RequestException if
the response status code indicates a client or server error, you may use the throw or throwIf methods:
$response = Http::post(/* ... */);
// Throw an exception if a client or server error occurred...
$response->throw();
// Throw an exception if an error occurred and the given condition is true...
$response->throwIf($condition);
// Throw an exception if an error occurred and the given closure resolves to true...
$response->throwIf(fn ($response) => true);
// Throw an exception if an error occurred and the given condition is false...
$response->throwUnless($condition);
// Throw an exception if an error occurred and the given closure resolves to false...
$response->throwUnless(fn ($response) => false);
// Throw an exception if the response has a specific status code...
$response->throwIfStatus(403);
// Throw an exception unless the response has a specific status code...
$response->throwUnlessStatus(200);
return $response['user']['id'];

The Illuminate\Http\Client\RequestException instance has a public $response property which will allow you to
inspect the returned response.
The throw method returns the response instance if no error occurred, allowing you to chain other operations onto the
throw method:
Page 526 of 1307

Laravel 9.x

return Http::post(/* ... */)->throw()->json();

If you would like to perform some additional logic before the exception is thrown, you may pass a closure to the throw
method. The exception will be thrown automatically after the closure is invoked, so you do not need to re-throw the
exception from within the closure:
return Http::post(/* ... */)->throw(function ($response, $e) {
//
})->json();

Guzzle Middleware

Since Laravel's HTTP client is powered by Guzzle, you may take advantage of Guzzle Middleware to manipulate the
outgoing request or inspect the incoming response. To manipulate the outgoing request, register a Guzzle middleware via
the withMiddleware method in combination with Guzzle's mapRequest middleware factory:
use GuzzleHttp\Middleware;
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\RequestInterface;
$response = Http::withMiddleware(
Middleware::mapRequest(function (RequestInterface $request) {
$request = $request->withHeader('X-Example', 'Value');
return $request;
})
)->get('http://example.com');

Likewise, you can inspect the incoming HTTP response by registering a middleware via the withMiddleware method in
combination with Guzzle's mapResponse middleware factory:
use GuzzleHttp\Middleware;
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\ResponseInterface;
$response = Http::withMiddleware(
Middleware::mapResponse(function (ResponseInterface $response) {
$header = $response->getHeader('X-Example');
// ...
return $response;
})
)->get('http://example.com');

Guzzle Options

You may specify additional Guzzle request options using the withOptions method. The withOptions method accepts
an array of key / value pairs:
$response = Http::withOptions([
'debug' => true,
])->get('http://example.com/users');

Page 527 of 1307

Laravel 9.x

Concurrent Requests

Sometimes, you may wish to make multiple HTTP requests concurrently. In other words, you want several requests to be
dispatched at the same time instead of issuing the requests sequentially. This can lead to substantial performance
improvements when interacting with slow HTTP APIs.
Thankfully, you may accomplish this using the pool method. The pool method accepts a closure which receives an
Illuminate\Http\Client\Pool instance, allowing you to easily add requests to the request pool for dispatching:
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$responses = Http::pool(fn (Pool $pool) => [
$pool->get('http://localhost/first'),
$pool->get('http://localhost/second'),
$pool->get('http://localhost/third'),
]);
return $responses[0]->ok() &&
$responses[1]->ok() &&
$responses[2]->ok();

As you can see, each response instance can be accessed based on the order it was added to the pool. If you wish, you can
name the requests using the as method, which allows you to access the corresponding responses by name:
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$responses = Http::pool(fn (Pool $pool) => [
$pool->as('first')->get('http://localhost/first'),
$pool->as('second')->get('http://localhost/second'),
$pool->as('third')->get('http://localhost/third'),
]);
return $responses['first']->ok();

Macros

The Laravel HTTP client allows you to define "macros", which can serve as a fluent, expressive mechanism to configure
common request paths and headers when interacting with services throughout your application. To get started, you may
define the macro within the boot method of your application's App\Providers\AppServiceProvider class:

Page 528 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Http;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Http::macro('github', function () {
return Http::withHeaders([
'X-Example' => 'example',
])->baseUrl('https://github.com');
});
}

Once your macro has been configured, you may invoke it from anywhere in your application to create a pending request
with the specified configuration:
$response = Http::github()->get('/');

Testing

Many Laravel services provide functionality to help you easily and expressively write tests, and Laravel's HTTP client is no
exception. The Http facade's fake method allows you to instruct the HTTP client to return stubbed / dummy responses
when requests are made.

Faking Responses

For example, to instruct the HTTP client to return empty, 200 status code responses for every request, you may call the
fake method with no arguments:
use Illuminate\Support\Facades\Http;
Http::fake();
$response = Http::post(/* ... */);

Faking Specific URLs
Alternatively, you may pass an array to the fake method. The array's keys should represent URL patterns that you wish
to fake and their associated responses. The * character may be used as a wildcard character. Any requests made to
URLs that have not been faked will actually be executed. You may use the Http facade's response method to
construct stub / fake responses for these endpoints:
Http::fake([
// Stub a JSON response for GitHub endpoints...
'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),
// Stub a string response for Google endpoints...
'google.com/*' => Http::response('Hello World', 200, $headers),
]);

If you would like to specify a fallback URL pattern that will stub all unmatched URLs, you may use a single * character:
Page 529 of 1307

Laravel 9.x

Http::fake([
// Stub a JSON response for GitHub endpoints...
'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),
// Stub a string response for all other endpoints...
'*' => Http::response('Hello World', 200, ['Headers']),
]);

Faking Response Sequences
Sometimes you may need to specify that a single URL should return a series of fake responses in a specific order. You may
accomplish this using the Http::sequence method to build the responses:
Http::fake([
// Stub a series of responses for GitHub endpoints...
'github.com/*' => Http::sequence()
->push('Hello World', 200)
->push(['foo' => 'bar'], 200)
->pushStatus(404),
]);

When all the responses in a response sequence have been consumed, any further requests will cause the response
sequence to throw an exception. If you would like to specify a default response that should be returned when a sequence
is empty, you may use the whenEmpty method:
Http::fake([
// Stub a series of responses for GitHub endpoints...
'github.com/*' => Http::sequence()
->push('Hello World', 200)
->push(['foo' => 'bar'], 200)
->whenEmpty(Http::response()),
]);

If you would like to fake a sequence of responses but do not need to specify a specific URL pattern that should be faked,
you may use the Http::fakeSequence method:
Http::fakeSequence()
->push('Hello World', 200)
->whenEmpty(Http::response());

Fake Callback
If you require more complicated logic to determine what responses to return for certain endpoints, you may pass a closure
to the fake method. This closure will receive an instance of Illuminate\Http\Client\Request and should return a
response instance. Within your closure, you may perform whatever logic is necessary to determine what type of response
to return:
use Illuminate\Http\Client\Request;
Http::fake(function (Request $request) {
return Http::response('Hello World', 200);
});

Page 530 of 1307

Laravel 9.x

Preventing Stray Requests

If you would like to ensure that all requests sent via the HTTP client have been faked throughout your individual test or
complete test suite, you can call the preventStrayRequests method. After calling this method, any requests that do not
have a corresponding fake response will throw an exception rather than making the actual HTTP request:
use Illuminate\Support\Facades\Http;
Http::preventStrayRequests();
Http::fake([
'github.com/*' => Http::response('ok'),
]);
// An "ok" response is returned...
Http::get('https://github.com/laravel/framework');
// An exception is thrown...
Http::get('https://laravel.com');

Inspecting Requests

When faking responses, you may occasionally wish to inspect the requests the client receives in order to make sure your
application is sending the correct data or headers. You may accomplish this by calling the Http::assertSent method
after calling Http::fake .
The assertSent method accepts a closure which will receive an Illuminate\Http\Client\Request instance and
should return a boolean value indicating if the request matches your expectations. In order for the test to pass, at least one
request must have been issued matching the given expectations:
use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;
Http::fake();
Http::withHeaders([
'X-First' => 'foo',
])->post('http://example.com/users', [
'name' => 'Taylor',
'role' => 'Developer',
]);
Http::assertSent(function (Request $request) {
return $request->hasHeader('X-First', 'foo') &&
$request->url() == 'http://example.com/users' &&
$request['name'] == 'Taylor' &&
$request['role'] == 'Developer';
});

If needed, you may assert that a specific request was not sent using the assertNotSent method:

Page 531 of 1307

Laravel 9.x

use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;
Http::fake();
Http::post('http://example.com/users', [
'name' => 'Taylor',
'role' => 'Developer',
]);
Http::assertNotSent(function (Request $request) {
return $request->url() === 'http://example.com/posts';
});

You may use the assertSentCount method to assert how many requests were "sent" during the test:
Http::fake();
Http::assertSentCount(5);

Or, you may use the assertNothingSent method to assert that no requests were sent during the test:
Http::fake();
Http::assertNothingSent();

Recording Requests / Responses
You may use the recorded method to gather all requests and their corresponding responses. The recorded method
returns a collection of arrays that contains instances of Illuminate\Http\Client\Request and
Illuminate\Http\Client\Response :
Http::fake([
'https://laravel.com' => Http::response(status: 500),
'https://nova.laravel.com/' => Http::response(),
]);
Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');
$recorded = Http::recorded();
[$request, $response] = $recorded[0];

Additionally, the recorded method accepts a closure which will receive an instance of
Illuminate\Http\Client\Request and Illuminate\Http\Client\Response and may be used to filter request /
response pairs based on your expectations:

Page 532 of 1307

Laravel 9.x

use Illuminate\Http\Client\Request;
use Illuminate\Http\Client\Response;
Http::fake([
'https://laravel.com' => Http::response(status: 500),
'https://nova.laravel.com/' => Http::response(),
]);
Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');
$recorded = Http::recorded(function (Request $request, Response $response) {
return $request->url() !== 'https://laravel.com' &&
$response->successful();
});

Events

Laravel fires three events during the process of sending HTTP requests. The RequestSending event is fired prior to a
request being sent, while the ResponseReceived event is fired after a response is received for a given request. The
ConnectionFailed event is fired if no response is received for a given request.
The RequestSending and ConnectionFailed events both contain a public $request property that you may use to
inspect the Illuminate\Http\Client\Request instance. Likewise, the ResponseReceived event contains a
$request property as well as a $response property which may be used to inspect the
Illuminate\Http\Client\Response instance. You may register event listeners for this event in your
App\Providers\EventServiceProvider service provider:
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
'Illuminate\Http\Client\Events\RequestSending' => [
'App\Listeners\LogRequestSending',
],
'Illuminate\Http\Client\Events\ResponseReceived' => [
'App\Listeners\LogResponseReceived',
],
'Illuminate\Http\Client\Events\ConnectionFailed' => [
'App\Listeners\LogConnectionFailed',
],
];

Page 533 of 1307

Laravel 9.x

Localization

Introduction
Configuring The Locale
Pluralization Language
Defining Translation Strings
Using Short Keys
Using Translation Strings As Keys
Retrieving Translation Strings
Replacing Parameters In Translation Strings
Pluralization
Overriding Package Language Files

Introduction

Laravel's localization features provide a convenient way to retrieve strings in various languages, allowing you to easily
support multiple languages within your application.
Laravel provides two ways to manage translation strings. First, language strings may be stored in files within the lang
directory. Within this directory, there may be subdirectories for each language supported by the application. This is the
approach Laravel uses to manage translation strings for built-in Laravel features such as validation error messages:
/lang
/en
messages.php
/es
messages.php

Or, translation strings may be defined within JSON files that are placed within the lang directory. When taking this
approach, each language supported by your application would have a corresponding JSON file within this directory. This
approach is recommended for applications that have a large number of translatable strings:
/lang
en.json
es.json

We'll discuss each approach to managing translation strings within this documentation.

Configuring The Locale

The default language for your application is stored in the config/app.php configuration file's locale configuration
option. You are free to modify this value to suit the needs of your application.
You may modify the default language for a single HTTP request at runtime using the setLocale method provided by the
App facade:

Page 534 of 1307

Laravel 9.x

use Illuminate\Support\Facades\App;
Route::get('/greeting/{locale}', function ($locale) {
if (! in_array($locale, ['en', 'es', 'fr'])) {
abort(400);
}
App::setLocale($locale);
//
});

You may configure a "fallback language", which will be used when the active language does not contain a given translation
string. Like the default language, the fallback language is also configured in the config/app.php configuration file:
'fallback_locale' => 'en',

Determining The Current Locale
You may use the currentLocale and isLocale methods on the App facade to determine the current locale or check
if the locale is a given value:
use Illuminate\Support\Facades\App;
$locale = App::currentLocale();
if (App::isLocale('en')) {
//
}

Pluralization Language

You may instruct Laravel's "pluralizer", which is used by Eloquent and other portions of the framework to convert singular
strings to plural strings, to use a language other than English. This may be accomplished by invoking the useLanguage
method within the boot method of one of your application's service providers. The pluralizer's currently supported
languages are: french , norwegian-bokmal , portuguese , spanish , and turkish :
use Illuminate\Support\Pluralizer;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Pluralizer::useLanguage('spanish');
// ...
}

Page 535 of 1307

Laravel 9.x

If you customize the pluralizer's language, you should explicitly define your Eloquent model's table
names.

Defining Translation Strings
Using Short Keys

Typically, translation strings are stored in files within the lang directory. Within this directory, there should be a
subdirectory for each language supported by your application. This is the approach Laravel uses to manage translation
strings for built-in Laravel features such as validation error messages:
/lang
/en
messages.php
/es
messages.php

All language files return an array of keyed strings. For example:
<?php
// lang/en/messages.php
return [
'welcome' => 'Welcome to our application!',
];

For languages that differ by territory, you should name the language directories according to the
ISO 15897. For example, "en_GB" should be used for British English rather than "en-gb".

Using Translation Strings As Keys

For applications with a large number of translatable strings, defining every string with a "short key" can become confusing
when referencing the keys in your views and it is cumbersome to continually invent keys for every translation string
supported by your application.
For this reason, Laravel also provides support for defining translation strings using the "default" translation of the string as
the key. Translation files that use translation strings as keys are stored as JSON files in the lang directory. For example,
if your application has a Spanish translation, you should create a lang/es.json file:
{
"I love programming.": "Me encanta programar."
}

Key / File Conflicts
You should not define translation string keys that conflict with other translation filenames. For example, translating
__('Action') for the "NL" locale while a nl/action.php file exists but a nl.json file does not exist will result in the
Page 536 of 1307

Laravel 9.x

translator returning the contents of nl/action.php .

Retrieving Translation Strings

You may retrieve translation strings from your language files using the __ helper function. If you are using "short keys" to
define your translation strings, you should pass the file that contains the key and the key itself to the __ function using
"dot" syntax. For example, let's retrieve the welcome translation string from the lang/en/messages.php language file:
echo __('messages.welcome');

If the specified translation string does not exist, the __ function will return the translation string key. So, using the
example above, the __ function would return messages.welcome if the translation string does not exist.
If you are using your default translation strings as your translation keys, you should pass the default translation of your
string to the __ function;
echo __('I love programming.');

Again, if the translation string does not exist, the __ function will return the translation string key that it was given.
If you are using the Blade templating engine, you may use the {{ }} echo syntax to display the translation string:
{{ __('messages.welcome') }}

Replacing Parameters In Translation Strings

If you wish, you may define placeholders in your translation strings. All placeholders are prefixed with a : . For example,
you may define a welcome message with a placeholder name:
'welcome' => 'Welcome, :name',

To replace the placeholders when retrieving a translation string, you may pass an array of replacements as the second
argument to the __ function:
echo __('messages.welcome', ['name' => 'dayle']);

If your placeholder contains all capital letters, or only has its first letter capitalized, the translated value will be capitalized
accordingly:
'welcome' => 'Welcome, :NAME', // Welcome, DAYLE
'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle

Object Replacement Formatting
If you attempt to provide an object as a translation placeholder, the object's __toString method will be invoked. The
__toString method is one of PHP's built-in "magic methods". However, sometimes you may not have control over the
__toString method of a given class, such as when the class that you are interacting with belongs to a third-party
library.
In these cases, Laravel allows you to register a custom formatting handler for that particular type of object. To accomplish
this, you should invoke the translator's stringable method. The stringable method accepts a closure, which should
type-hint the type of object that it is responsible for formatting. Typically, the stringable method should be invoked
within the boot method of your application's AppServiceProvider class:
Page 537 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Lang;
use Money\Money;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Lang::stringable(function (Money $money) {
return $money->formatTo('en_GB');
});
}

Pluralization

Pluralization is a complex problem, as different languages have a variety of complex rules for pluralization; however,
Laravel can help you translate strings differently based on pluralization rules that you define. Using a | character, you
may distinguish singular and plural forms of a string:
'apples' => 'There is one apple|There are many apples',

Of course, pluralization is also supported when using translation strings as keys:
{
"There is one apple|There are many apples": "Hay una manzana|Hay muchas manzanas"
}

You may even create more complex pluralization rules which specify translation strings for multiple ranges of values:
'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',

After defining a translation string that has pluralization options, you may use the trans_choice function to retrieve the
line for a given "count". In this example, since the count is greater than one, the plural form of the translation string is
returned:
echo trans_choice('messages.apples', 10);

You may also define placeholder attributes in pluralization strings. These placeholders may be replaced by passing an
array as the third argument to the trans_choice function:
'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',
echo trans_choice('time.minutes_ago', 5, ['value' => 5]);

If you would like to display the integer value that was passed to the trans_choice function, you may use the built-in
:count placeholder:
'apples' => '{0} There are none|{1} There is one|[2,*] There are :count',

Page 538 of 1307

Laravel 9.x

Overriding Package Language Files

Some packages may ship with their own language files. Instead of changing the package's core files to tweak these lines,
you may override them by placing files in the lang/vendor/{package}/{locale} directory.
So, for example, if you need to override the English translation strings in messages.php for a package named
skyrim/hearthfire , you should place a language file at: lang/vendor/hearthfire/en/messages.php . Within this
file, you should only define the translation strings you wish to override. Any translation strings you don't override will still
be loaded from the package's original language files.

Page 539 of 1307

Laravel 9.x

Mail
Introduction
Configuration
Driver Prerequisites
Failover Configuration
Generating Mailables
Writing Mailables
Configuring The Sender
Configuring The View
View Data
Attachments
Inline Attachments
Attachable Objects
Headers
Tags & Metadata
Customizing The Symfony Message
Markdown Mailables
Generating Markdown Mailables
Writing Markdown Messages
Customizing The Components
Sending Mail
Queueing Mail
Rendering Mailables
Previewing Mailables In The Browser
Localizing Mailables
Testing Mailables
Mail & Local Development
Events
Custom Transports
Additional Symfony Transports

Introduction

Sending email doesn't have to be complicated. Laravel provides a clean, simple email API powered by the popular Symfony
Mailer component. Laravel and Symfony Mailer provide drivers for sending email via SMTP, Mailgun, Postmark, Amazon
SES, and sendmail , allowing you to quickly get started sending mail through a local or cloud based service of your
choice.

Configuration

Laravel's email services may be configured via your application's config/mail.php configuration file. Each mailer
configured within this file may have its own unique configuration and even its own unique "transport", allowing your
application to use different email services to send certain email messages. For example, your application might use
Postmark to send transactional emails while using Amazon SES to send bulk emails.
Within your mail configuration file, you will find a mailers configuration array. This array contains a sample
configuration entry for each of the major mail drivers / transports supported by Laravel, while the default configuration
value determines which mailer will be used by default when your application needs to send an email message.

Driver / Transport Prerequisites
Page 540 of 1307

Laravel 9.x

The API based drivers such as Mailgun and Postmark are often simpler and faster than sending mail via SMTP servers.
Whenever possible, we recommend that you use one of these drivers.
Mailgun Driver
To use the Mailgun driver, install Symfony's Mailgun Mailer transport via Composer:
composer require symfony/mailgun-mailer symfony/http-client

Next, set the default option in your application's config/mail.php configuration file to mailgun . After configuring
your application's default mailer, verify that your config/services.php configuration file contains the following options:
'mailgun' => [
'domain' => env('MAILGUN_DOMAIN'),
'secret' => env('MAILGUN_SECRET'),
],

If you are not using the United States Mailgun region, you may define your region's endpoint in the services
configuration file:
'mailgun' => [
'domain' => env('MAILGUN_DOMAIN'),
'secret' => env('MAILGUN_SECRET'),
'endpoint' => env('MAILGUN_ENDPOINT', 'api.eu.mailgun.net'),
],

Postmark Driver
To use the Postmark driver, install Symfony's Postmark Mailer transport via Composer:
composer require symfony/postmark-mailer symfony/http-client

Next, set the default option in your application's config/mail.php configuration file to postmark . After
configuring your application's default mailer, verify that your config/services.php configuration file contains the
following options:
'postmark' => [
'token' => env('POSTMARK_TOKEN'),
],

If you would like to specify the Postmark message stream that should be used by a given mailer, you may add the
message_stream_id configuration option to the mailer's configuration array. This configuration array can be found in
your application's config/mail.php configuration file:
'postmark' => [
'transport' => 'postmark',
'message_stream_id' => env('POSTMARK_MESSAGE_STREAM_ID'),
],

This way you are also able to set up multiple Postmark mailers with different message streams.
SES Driver

Page 541 of 1307

Laravel 9.x

To use the Amazon SES driver you must first install the Amazon AWS SDK for PHP. You may install this library via the
Composer package manager:
composer require aws/aws-sdk-php

Next, set the default option in your config/mail.php configuration file to ses and verify that your
config/services.php configuration file contains the following options:
'ses' => [
'key' => env('AWS_ACCESS_KEY_ID'),
'secret' => env('AWS_SECRET_ACCESS_KEY'),
'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
],

To utilize AWS temporary credentials via a session token, you may add a token key to your application's SES
configuration:
'ses' => [
'key' => env('AWS_ACCESS_KEY_ID'),
'secret' => env('AWS_SECRET_ACCESS_KEY'),
'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
'token' => env('AWS_SESSION_TOKEN'),
],

If you would like to define additional options that Laravel should pass to the AWS SDK's SendEmail method when
sending an email, you may define an options array within your ses configuration:
'ses' => [
'key' => env('AWS_ACCESS_KEY_ID'),
'secret' => env('AWS_SECRET_ACCESS_KEY'),
'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
'options' => [
'ConfigurationSetName' => 'MyConfigurationSet',
'EmailTags' => [
['Name' => 'foo', 'Value' => 'bar'],
],
],
],

Failover Configuration

Sometimes, an external service you have configured to send your application's mail may be down. In these cases, it can be
useful to define one or more backup mail delivery configurations that will be used in case your primary delivery driver is
down.
To accomplish this, you should define a mailer within your application's mail configuration file that uses the failover
transport. The configuration array for your application's failover mailer should contain an array of mailers that
reference the order in which mail drivers should be chosen for delivery:

Page 542 of 1307

Laravel 9.x

'mailers' => [
'failover' => [
'transport' => 'failover',
'mailers' => [
'postmark',
'mailgun',
'sendmail',
],
],
// ...
],

Once your failover mailer has been defined, you should set this mailer as the default mailer used by your application by
specifying its name as the value of the default configuration key within your application's mail configuration file:
'default' => env('MAIL_MAILER', 'failover'),

Generating Mailables

When building Laravel applications, each type of email sent by your application is represented as a "mailable" class. These
classes are stored in the app/Mail directory. Don't worry if you don't see this directory in your application, since it will
be generated for you when you create your first mailable class using the make:mail Artisan command:
php artisan make:mail OrderShipped

Writing Mailables

Once you have generated a mailable class, open it up so we can explore its contents. Mailable class configuration is done
in several methods, including the envelope , content , and attachments methods.
The envelope method returns an Illuminate\Mail\Mailables\Envelope object that defines the subject and,
sometimes, the recipients of the message. The content method returns an Illuminate\Mail\Mailables\Content
object that defines the Blade template that will be used to generate the message content.

Configuring The Sender

Using The Envelope
First, let's explore configuring the sender of the email. Or, in other words, who the email is going to be "from". There are
two ways to configure the sender. First, you may specify the "from" address on your message's envelope:

Page 543 of 1307

Laravel 9.x

use Illuminate\Mail\Mailables\Address;
use Illuminate\Mail\Mailables\Envelope;
/**
* Get the message envelope.
*
* @return \Illuminate\Mail\Mailables\Envelope
*/
public function envelope()
{
return new Envelope(
from: new Address('jeffrey@example.com', 'Jeffrey Way'),
subject: 'Order Shipped',
);
}

If you would like, you may also specify a replyTo address:
return new Envelope(
from: new Address('jeffrey@example.com', 'Jeffrey Way'),
replyTo: [
new Address('taylor@example.com', 'Taylor Otwell'),
],
subject: 'Order Shipped',
);

Using A Global from Address
However, if your application uses the same "from" address for all of its emails, it can become cumbersome to call the
from method in each mailable class you generate. Instead, you may specify a global "from" address in your
config/mail.php configuration file. This address will be used if no other "from" address is specified within the mailable
class:
'from' => ['address' => 'example@example.com', 'name' => 'App Name'],

In addition, you may define a global "reply_to" address within your config/mail.php configuration file:
'reply_to' => ['address' => 'example@example.com', 'name' => 'App Name'],

Configuring The View

Within a mailable class' content method, you may define the view , or which template should be used when rendering
the email's contents. Since each email typically uses a Blade template to render its contents, you have the full power and
convenience of the Blade templating engine when building your email's HTML:

Page 544 of 1307

Laravel 9.x

/**
* Get the message content definition.
*
* @return \Illuminate\Mail\Mailables\Content
*/
public function content()
{
return new Content(
view: 'emails.orders.shipped',
);
}

You may wish to create a resources/views/emails directory to house all of your email
templates; however, you are free to place them wherever you wish within your resources/views
directory.
Plain Text Emails
If you would like to define a plain-text version of your email, you may specify the plain-text template when creating the
message's Content definition. Like the view parameter, the text parameter should be a template name which will be
used to render the contents of the email. You are free to define both an HTML and plain-text version of your message:
/**
* Get the message content definition.
*
* @return \Illuminate\Mail\Mailables\Content
*/
public function content()
{
return new Content(
view: 'emails.orders.shipped',
text: 'emails.orders.shipped-text'
);
}

For clarity, the html parameter may be used as an alias of the view parameter:
return new Content(
html: 'emails.orders.shipped',
text: 'emails.orders.shipped-text'
);

View Data

Via Public Properties
Typically, you will want to pass some data to your view that you can utilize when rendering the email's HTML. There are two
ways you may make data available to your view. First, any public property defined on your mailable class will automatically
be made available to the view. So, for example, you may pass data into your mailable class' constructor and set that data to
public properties defined on the class:

Page 545 of 1307

Laravel 9.x

<?php
namespace App\Mail;
use App\Models\Order;
use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Mail\Mailables\Content;
use Illuminate\Queue\SerializesModels;
class OrderShipped extends Mailable
{
use Queueable, SerializesModels;
/**
* The order instance.
*
* @var \App\Models\Order
*/
public $order;
/**
* Create a new message instance.
*
* @param

\App\Models\Order

$order

* @return void
*/
public function __construct(Order $order)
{
$this->order = $order;
}
/**
* Get the message content definition.
*
* @return \Illuminate\Mail\Mailables\Content
*/
public function content()
{
return new Content(
view: 'emails.orders.shipped',
);
}
}

Once the data has been set to a public property, it will automatically be available in your view, so you may access it like you
would access any other data in your Blade templates:
<div>
Price: {{ $order->price }}
</div>

Via The with Parameter:

Page 546 of 1307

Laravel 9.x

If you would like to customize the format of your email's data before it is sent to the template, you may manually pass your
data to the view via the Content definition's with parameter. Typically, you will still pass data via the mailable class'
constructor; however, you should set this data to protected or private properties so the data is not automatically
made available to the template:
<?php
namespace App\Mail;
use App\Models\Order;
use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Mail\Mailables\Content;
use Illuminate\Queue\SerializesModels;
class OrderShipped extends Mailable
{
use Queueable, SerializesModels;
/**
* The order instance.
*
* @var \App\Models\Order
*/
protected $order;
/**
* Create a new message instance.
*
* @param

\App\Models\Order

$order

* @return void
*/
public function __construct(Order $order)
{
$this->order = $order;
}
/**
* Get the message content definition.
*
* @return \Illuminate\Mail\Mailables\Content
*/
public function content()
{
return new Content(
view: 'emails.orders.shipped',
with: [
'orderName' => $this->order->name,
'orderPrice' => $this->order->price,
],
);
}
}

Once the data has been passed to the with method, it will automatically be available in your view, so you may access it
like you would access any other data in your Blade templates:
Page 547 of 1307

Laravel 9.x

<div>
Price: {{ $orderPrice }}
</div>

Attachments

To add attachments to an email, you will add attachments to the array returned by the message's attachments method.
First, you may add an attachment by providing a file path to the fromPath method provided by the Attachment class:
use Illuminate\Mail\Mailables\Attachment;
/**
* Get the attachments for the message.
*
* @return \Illuminate\Mail\Mailables\Attachment[]
*/
public function attachments()
{
return [
Attachment::fromPath('/path/to/file'),
];
}

When attaching files to a message, you may also specify the display name and / or MIME type for the attachment using the
as and withMime methods:
/**
* Get the attachments for the message.
*
* @return \Illuminate\Mail\Mailables\Attachment[]
*/
public function attachments()
{
return [
Attachment::fromPath('/path/to/file')
->as('name.pdf')
->withMime('application/pdf'),
];
}

Attaching Files From Disk
If you have stored a file on one of your filesystem disks, you may attach it to the email using the fromStorage
attachment method:

Page 548 of 1307

Laravel 9.x

/**
* Get the attachments for the message.
*
* @return \Illuminate\Mail\Mailables\Attachment[]
*/
public function attachments()
{
return [
Attachment::fromStorage('/path/to/file'),
];
}

Of course, you may also specify the attachment's name and MIME type:
/**
* Get the attachments for the message.
*
* @return \Illuminate\Mail\Mailables\Attachment[]
*/
public function attachments()
{
return [
Attachment::fromStorage('/path/to/file')
->as('name.pdf')
->withMime('application/pdf'),
];
}

The fromStorageDisk method may be used if you need to specify a storage disk other than your default disk:
/**
* Get the attachments for the message.
*
* @return \Illuminate\Mail\Mailables\Attachment[]
*/
public function attachments()
{
return [
Attachment::fromStorageDisk('s3', '/path/to/file')
->as('name.pdf')
->withMime('application/pdf'),
];
}

Raw Data Attachments
The fromData attachment method may be used to attach a raw string of bytes as an attachment. For example, you might
use this method if you have generated a PDF in memory and want to attach it to the email without writing it to disk. The
fromData method accepts a closure which resolves the raw data bytes as well as the name that the attachment should
be assigned:

Page 549 of 1307

Laravel 9.x

/**
* Get the attachments for the message.
*
* @return \Illuminate\Mail\Mailables\Attachment[]
*/
public function attachments()
{
return [
Attachment::fromData(fn () => $this->pdf, 'Report.pdf')
->withMime('application/pdf'),
];
}

Inline Attachments

Embedding inline images into your emails is typically cumbersome; however, Laravel provides a convenient way to attach
images to your emails. To embed an inline image, use the embed method on the $message variable within your email
template. Laravel automatically makes the $message variable available to all of your email templates, so you don't need
to worry about passing it in manually:
<body>
Here is an image:
<img src="{{ $message->embed($pathToImage) }}">
</body>

The $message variable is not available in plain-text message templates since plain-text messages
do not utilize inline attachments.
Embedding Raw Data Attachments
If you already have a raw image data string you wish to embed into an email template, you may call the embedData
method on the $message variable. When calling the embedData method, you will need to provide a filename that should
be assigned to the embedded image:
<body>
Here is an image from raw data:
<img src="{{ $message->embedData($data, 'example-image.jpg') }}">
</body>

Attachable Objects

While attaching files to messages via simple string paths is often sufficient, in many cases the attachable entities within
your application are represented by classes. For example, if your application is attaching a photo to a message, your
application may also have a Photo model that represents that photo. When that is the case, wouldn't it be convenient to
simply pass the Photo model to the attach method? Attachable objects allow you to do just that.
To get started, implement the Illuminate\Contracts\Mail\Attachable interface on the object that will be attachable
to messages. This interface dictates that your class defines a toMailAttachment method that returns an
Illuminate\Mail\Attachment instance:
Page 550 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Contracts\Mail\Attachable;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Mail\Attachment;
class Photo extends Model implements Attachable
{
/**
* Get the attachable representation of the model.
*
* @return \Illuminate\Mail\Attachment
*/
public function toMailAttachment()
{
return Attachment::fromPath('/path/to/file');
}
}

Once you have defined your attachable object, you may return an instance of that object from the attachments method
when building an email message:
/**
* Get the attachments for the message.
*
* @return array
*/
public function attachments()
{
return [$this->photo];
}

Of course, attachment data may be stored on a remote file storage service such as Amazon S3. So, Laravel also allows you
to generate attachment instances from data that is stored on one of your application's filesystem disks:
// Create an attachment from a file on your default disk...
return Attachment::fromStorage($this->path);
// Create an attachment from a file on a specific disk...
return Attachment::fromStorageDisk('backblaze', $this->path);

In addition, you may create attachment instances via data that you have in memory. To accomplish this, provide a closure
to the fromData method. The closure should return the raw data that represents the attachment:
return Attachment::fromData(fn () => $this->content, 'Photo Name');

Laravel also provides additional methods that you may use to customize your attachments. For example, you may use the
as and withMime methods to customize the file's name and MIME type:

Page 551 of 1307

Laravel 9.x

return Attachment::fromPath('/path/to/file')
->as('Photo Name')
->withMime('image/jpeg');

Headers

Sometimes you may need to attach additional headers to the outgoing message. For instance, you may need to set a
custom Message-Id or other arbitrary text headers.
To accomplish this, define a headers method on your mailable. The headers method should return an
Illuminate\Mail\Mailables\Headers instance. This class accepts messageId , references , and text
parameters. Of course, you may provide only the parameters you need for your particular message:
use Illuminate\Mail\Mailables\Headers;
/**
* Get the message headers.
*
* @return \Illuminate\Mail\Mailables\Headers
*/
public function headers()
{
return new Headers(
messageId: 'custom-message-id@example.com',
references: ['previous-message@example.com'],
text: [
'X-Custom-Header' => 'Custom Value',
],
);
}

Tags & Metadata

Some third-party email providers such as Mailgun and Postmark support message "tags" and "metadata", which may be
used to group and track emails sent by your application. You may add tags and metadata to an email message via your
Envelope definition:
use Illuminate\Mail\Mailables\Envelope;
/**
* Get the message envelope.
*
* @return \Illuminate\Mail\Mailables\Envelope
*/
public function envelope()
{
return new Envelope(
subject: 'Order Shipped',
tags: ['shipment'],
metadata: [
'order_id' => $this->order->id,
],
);
}

Page 552 of 1307

Laravel 9.x

If your application is using the Mailgun driver, you may consult Mailgun's documentation for more information on tags and
metadata. Likewise, the Postmark documentation may also be consulted for more information on their support for tags and
metadata.
If your application is using Amazon SES to send emails, you should use the metadata method to attach SES "tags" to the
message.

Customizing The Symfony Message

Laravel's mail capabilities are powered by Symfony Mailer. Laravel allows you to register custom callbacks that will be
invoked with the Symfony Message instance before sending the message. This gives you an opportunity to deeply
customize the message before it is sent. To accomplish this, define a using parameter on your Envelope definition:
use Illuminate\Mail\Mailables\Envelope;
use Symfony\Component\Mime\Email;
/**
* Get the message envelope.
*
* @return \Illuminate\Mail\Mailables\Envelope
*/
public function envelope()
{
return new Envelope(
subject: 'Order Shipped',
using: [
function (Email $message) {
// ...
},
]
);
}

Markdown Mailables

Markdown mailable messages allow you to take advantage of the pre-built templates and components of mail notifications
in your mailables. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML
templates for the messages while also automatically generating a plain-text counterpart.

Generating Markdown Mailables

To generate a mailable with a corresponding Markdown template, you may use the --markdown option of the
make:mail Artisan command:
php artisan make:mail OrderShipped --markdown=emails.orders.shipped

Then, when configuring the mailable Content definition within its content method, use the markdown parameter
instead of the view parameter:

Page 553 of 1307

Laravel 9.x

use Illuminate\Mail\Mailables\Content;
/**
* Get the message content definition.
*
* @return \Illuminate\Mail\Mailables\Content
*/
public function content()
{
return new Content(
markdown: 'emails.orders.shipped',
with: [
'url' => $this->orderUrl,
],
);
}

Writing Markdown Messages

Markdown mailables use a combination of Blade components and Markdown syntax which allow you to easily construct
mail messages while leveraging Laravel's pre-built email UI components:
<x-mail::message>
# Order Shipped
Your order has been shipped!
<x-mail::button :url="$url">
View Order
</x-mail::button>
Thanks,<br>
{{ config('app.name') }}
</x-mail::message>

Do not use excess indentation when writing Markdown emails. Per Markdown standards, Markdown
parsers will render indented content as code blocks.
Button Component
The button component renders a centered button link. The component accepts two arguments, a url and an optional
color . Supported colors are primary , success , and error . You may add as many button components to a
message as you wish:
<x-mail::button :url="$url" color="success">
View Order
</x-mail::button>

Panel Component

Page 554 of 1307

Laravel 9.x

The panel component renders the given block of text in a panel that has a slightly different background color than the rest
of the message. This allows you to draw attention to a given block of text:
<x-mail::panel>
This is the panel content.
</x-mail::panel>

Table Component
The table component allows you to transform a Markdown table into an HTML table. The component accepts the
Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax:
<x-mail::table>
| Laravel

| Table

| Example

|

| ------------- |:-------------:| --------:|
| Col 2 is

| Centered

| $10

|

| Col 3 is

| Right-Aligned | $20

|

</x-mail::table>

Customizing The Components

You may export all of the Markdown mail components to your own application for customization. To export the
components, use the vendor:publish Artisan command to publish the laravel-mail asset tag:
php artisan vendor:publish --tag=laravel-mail

This command will publish the Markdown mail components to the resources/views/vendor/mail directory. The mail
directory will contain an html and a text directory, each containing their respective representations of every available
component. You are free to customize these components however you like.
Customizing The CSS
After exporting the components, the resources/views/vendor/mail/html/themes directory will contain a
default.css file. You may customize the CSS in this file and your styles will automatically be converted to inline CSS
styles within the HTML representations of your Markdown mail messages.
If you would like to build an entirely new theme for Laravel's Markdown components, you may place a CSS file within the
html/themes directory. After naming and saving your CSS file, update the theme option of your application's
config/mail.php configuration file to match the name of your new theme.
To customize the theme for an individual mailable, you may set the $theme property of the mailable class to the name of
the theme that should be used when sending that mailable.

Sending Mail

To send a message, use the to method on the Mail facade. The to method accepts an email address, a user
instance, or a collection of users. If you pass an object or collection of objects, the mailer will automatically use their
email and name properties when determining the email's recipients, so make sure these attributes are available on
your objects. Once you have specified your recipients, you may pass an instance of your mailable class to the send
method:

Page 555 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Mail\OrderShipped;
use App\Models\Order;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Mail;
class OrderShipmentController extends Controller
{
/**
* Ship the given order.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$order = Order::findOrFail($request->order_id);
// Ship the order...
Mail::to($request->user())->send(new OrderShipped($order));
}
}

You are not limited to just specifying the "to" recipients when sending a message. You are free to set "to", "cc", and "bcc"
recipients by chaining their respective methods together:
Mail::to($request->user())
->cc($moreUsers)
->bcc($evenMoreUsers)
->send(new OrderShipped($order));

Looping Over Recipients
Occasionally, you may need to send a mailable to a list of recipients by iterating over an array of recipients / email
addresses. However, since the to method appends email addresses to the mailable's list of recipients, each iteration
through the loop will send another email to every previous recipient. Therefore, you should always re-create the mailable
instance for each recipient:
foreach (['taylor@example.com', 'dries@example.com'] as $recipient) {
Mail::to($recipient)->send(new OrderShipped($order));
}

Sending Mail Via A Specific Mailer
By default, Laravel will send email using the mailer configured as the default mailer in your application's mail
configuration file. However, you may use the mailer method to send a message using a specific mailer configuration:

Page 556 of 1307

Laravel 9.x

Mail::mailer('postmark')
->to($request->user())
->send(new OrderShipped($order));

Queueing Mail

Queueing A Mail Message
Since sending email messages can negatively impact the response time of your application, many developers choose to
queue email messages for background sending. Laravel makes this easy using its built-in unified queue API. To queue a
mail message, use the queue method on the Mail facade after specifying the message's recipients:
Mail::to($request->user())
->cc($moreUsers)
->bcc($evenMoreUsers)
->queue(new OrderShipped($order));

This method will automatically take care of pushing a job onto the queue so the message is sent in the background. You
will need to configure your queues before using this feature.
Delayed Message Queueing
If you wish to delay the delivery of a queued email message, you may use the later method. As its first argument, the
later method accepts a DateTime instance indicating when the message should be sent:
Mail::to($request->user())
->cc($moreUsers)
->bcc($evenMoreUsers)
->later(now()->addMinutes(10), new OrderShipped($order));

Pushing To Specific Queues
Since all mailable classes generated using the make:mail command make use of the Illuminate\Bus\Queueable
trait, you may call the onQueue and onConnection methods on any mailable class instance, allowing you to specify the
connection and queue name for the message:
$message = (new OrderShipped($order))
->onConnection('sqs')
->onQueue('emails');
Mail::to($request->user())
->cc($moreUsers)
->bcc($evenMoreUsers)
->queue($message);

Queueing By Default
If you have mailable classes that you want to always be queued, you may implement the ShouldQueue contract on the
class. Now, even if you call the send method when mailing, the mailable will still be queued since it implements the
contract:

Page 557 of 1307

Laravel 9.x

use Illuminate\Contracts\Queue\ShouldQueue;
class OrderShipped extends Mailable implements ShouldQueue
{
//
}

Queued Mailables & Database Transactions
When queued mailables are dispatched within database transactions, they may be processed by the queue before the
database transaction has committed. When this happens, any updates you have made to models or database records
during the database transaction may not yet be reflected in the database. In addition, any models or database records
created within the transaction may not exist in the database. If your mailable depends on these models, unexpected errors
can occur when the job that sends the queued mailable is processed.
If your queue connection's after_commit configuration option is set to false , you may still indicate that a particular
queued mailable should be dispatched after all open database transactions have been committed by calling the
afterCommit method when sending the mail message:
Mail::to($request->user())->send(
(new OrderShipped($order))->afterCommit()
);

Alternatively, you may call the afterCommit method from your mailable's constructor:
<?php
namespace App\Mail;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;
class OrderShipped extends Mailable implements ShouldQueue
{
use Queueable, SerializesModels;
/**
* Create a new message instance.
*
* @return void
*/
public function __construct()
{
$this->afterCommit();
}
}

To learn more about working around these issues, please review the documentation regarding
queued jobs and database transactions.

Page 558 of 1307

Laravel 9.x

Rendering Mailables

Sometimes you may wish to capture the HTML content of a mailable without sending it. To accomplish this, you may call
the render method of the mailable. This method will return the evaluated HTML content of the mailable as a string:
use App\Mail\InvoicePaid;
use App\Models\Invoice;
$invoice = Invoice::find(1);
return (new InvoicePaid($invoice))->render();

Previewing Mailables In The Browser

When designing a mailable's template, it is convenient to quickly preview the rendered mailable in your browser like a
typical Blade template. For this reason, Laravel allows you to return any mailable directly from a route closure or controller.
When a mailable is returned, it will be rendered and displayed in the browser, allowing you to quickly preview its design
without needing to send it to an actual email address:
Route::get('/mailable', function () {
$invoice = App\Models\Invoice::find(1);
return new App\Mail\InvoicePaid($invoice);
});

Inline attachments will not be rendered when a mailable is previewed in your browser. To preview
these mailables, you should send them to an email testing application such as Mailpit or HELO.

Localizing Mailables

Laravel allows you to send mailables in a locale other than the request's current locale, and will even remember this locale
if the mail is queued.
To accomplish this, the Mail facade offers a locale method to set the desired language. The application will change
into this locale when the mailable's template is being evaluated and then revert back to the previous locale when evaluation
is complete:
Mail::to($request->user())->locale('es')->send(
new OrderShipped($order)
);

User Preferred Locales

Sometimes, applications store each user's preferred locale. By implementing the HasLocalePreference contract on one
or more of your models, you may instruct Laravel to use this stored locale when sending mail:

Page 559 of 1307

Laravel 9.x

use Illuminate\Contracts\Translation\HasLocalePreference;
class User extends Model implements HasLocalePreference
{
/**
* Get the user's preferred locale.
*
* @return string
*/
public function preferredLocale()
{
return $this->locale;
}
}

Once you have implemented the interface, Laravel will automatically use the preferred locale when sending mailables and
notifications to the model. Therefore, there is no need to call the locale method when using this interface:
Mail::to($request->user())->send(new OrderShipped($order));

Testing Mailables

Laravel provides a variety of methods for inspecting your mailable's structure. In addition, Laravel provides several
convenient methods for testing that your mailable contains the content that you expect. These methods are:
assertSeeInHtml , assertDontSeeInHtml , assertSeeInOrderInHtml , assertSeeInText ,
assertDontSeeInText , assertSeeInOrderInText , assertHasAttachment , assertHasAttachedData ,
assertHasAttachmentFromStorage , and assertHasAttachmentFromStorageDisk .
As you might expect, the "HTML" assertions assert that the HTML version of your mailable contains a given string, while
the "text" assertions assert that the plain-text version of your mailable contains a given string:

Page 560 of 1307

Laravel 9.x

use App\Mail\InvoicePaid;
use App\Models\User;
public function test_mailable_content()
{
$user = User::factory()->create();
$mailable = new InvoicePaid($user);
$mailable->assertFrom('jeffrey@example.com');
$mailable->assertTo('taylor@example.com');
$mailable->assertHasCc('abigail@example.com');
$mailable->assertHasBcc('victoria@example.com');
$mailable->assertHasReplyTo('tyler@example.com');
$mailable->assertHasSubject('Invoice Paid');
$mailable->assertHasTag('example-tag');
$mailable->assertHasMetadata('key', 'value');
$mailable->assertSeeInHtml($user->email);
$mailable->assertSeeInHtml('Invoice Paid');
$mailable->assertSeeInOrderInHtml(['Invoice Paid', 'Thanks']);
$mailable->assertSeeInText($user->email);
$mailable->assertSeeInOrderInText(['Invoice Paid', 'Thanks']);
$mailable->assertHasAttachment('/path/to/file');
$mailable->assertHasAttachment(Attachment::fromPath('/path/to/file'));
$mailable->assertHasAttachedData($pdfData, 'name.pdf', ['mime' => 'application/pdf']);
$mailable->assertHasAttachmentFromStorage('/path/to/file', 'name.pdf', ['mime' =>
'application/pdf']);
$mailable->assertHasAttachmentFromStorageDisk('s3', '/path/to/file', 'name.pdf', ['mime' =>
'application/pdf']);
}

Testing Mailable Sending
We suggest testing the content of your mailables separately from your tests that assert that a given mailable was "sent" to
a specific user. To learn how to test that mailables were sent, check out our documentation on the Mail fake.

Mail & Local Development

When developing an application that sends email, you probably don't want to actually send emails to live email addresses.
Laravel provides several ways to "disable" the actual sending of emails during local development.
Log Driver
Instead of sending your emails, the log mail driver will write all email messages to your log files for inspection. Typically,
this driver would only be used during local development. For more information on configuring your application per
environment, check out the configuration documentation.
HELO / Mailtrap / Mailpit
Alternatively, you may use a service like HELO or Mailtrap and the smtp driver to send your email messages to a "dummy"
mailbox where you may view them in a true email client. This approach has the benefit of allowing you to actually inspect
the final emails in Mailtrap's message viewer.

Page 561 of 1307

Laravel 9.x

If you are using Laravel Sail, you may preview your messages using Mailpit. When Sail is running, you may access the
Mailpit interface at: http://localhost:8025 .
Using A Global to Address
Finally, you may specify a global "to" address by invoking the alwaysTo method offered by the Mail facade. Typically,
this method should be called from the boot method of one of your application's service providers:
use Illuminate\Support\Facades\Mail;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
if ($this->app->environment('local')) {
Mail::alwaysTo('taylor@example.com');
}
}

Events

Laravel fires two events during the process of sending mail messages. The MessageSending event is fired prior to a
message being sent, while the MessageSent event is fired after a message has been sent. Remember, these events are
fired when the mail is being sent, not when it is queued. You may register event listeners for this event in your
App\Providers\EventServiceProvider service provider:
use App\Listeners\LogSendingMessage;
use App\Listeners\LogSentMessage;
use Illuminate\Mail\Events\MessageSending;
use Illuminate\Mail\Events\MessageSent;
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
MessageSending::class => [
LogSendingMessage::class,
],
MessageSent::class => [
LogSentMessage::class,
],
];

Custom Transports

Laravel includes a variety of mail transports; however, you may wish to write your own transports to deliver email via other
services that Laravel does not support out of the box. To get started, define a class that extends the
Symfony\Component\Mailer\Transport\AbstractTransport class. Then, implement the doSend and
__toString() methods on your transport:
Page 562 of 1307

Laravel 9.x

use MailchimpTransactional\ApiClient;
use Symfony\Component\Mailer\SentMessage;
use Symfony\Component\Mailer\Transport\AbstractTransport;
use Symfony\Component\Mime\MessageConverter;
class MailchimpTransport extends AbstractTransport
{
/**
* The Mailchimp API client.
*
* @var \MailchimpTransactional\ApiClient
*/
protected $client;
/**
* Create a new Mailchimp transport instance.
*
* @param

\MailchimpTransactional\ApiClient

$client

* @return void
*/
public function __construct(ApiClient $client)
{
parent::__construct();
$this->client = $client;
}
/**
* {@inheritDoc}
*/
protected function doSend(SentMessage $message): void
{
$email = MessageConverter::toEmail($message->getOriginalMessage());
$this->client->messages->send(['message' => [
'from_email' => $email->getFrom(),
'to' => collect($email->getTo())->map(function ($email) {
return ['email' => $email->getAddress(), 'type' => 'to'];
})->all(),
'subject' => $email->getSubject(),
'text' => $email->getTextBody(),
]]);
}
/**
* Get the string representation of the transport.
*
* @return string
*/
public function __toString(): string
{
return 'mailchimp';
}
}

Page 563 of 1307

Laravel 9.x

Once you've defined your custom transport, you may register it via the extend method provided by the Mail facade.
Typically, this should be done within the boot method of your application's AppServiceProvider service provider. A
$config argument will be passed to the closure provided to the extend method. This argument will contain the
configuration array defined for the mailer in the application's config/mail.php configuration file:
use App\Mail\MailchimpTransport;
use Illuminate\Support\Facades\Mail;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Mail::extend('mailchimp', function (array $config = []) {
return new MailchimpTransport(/* ... */);
});
}

Once your custom transport has been defined and registered, you may create a mailer definition within your application's
config/mail.php configuration file that utilizes the new transport:
'mailchimp' => [
'transport' => 'mailchimp',
// ...
],

Additional Symfony Transports

Laravel includes support for some existing Symfony maintained mail transports like Mailgun and Postmark. However, you
may wish to extend Laravel with support for additional Symfony maintained transports. You can do so by requiring the
necessary Symfony mailer via Composer and registering the transport with Laravel. For example, you may install and
register the "Sendinblue" Symfony mailer:
composer require symfony/sendinblue-mailer symfony/http-client

Once the Sendinblue mailer package has been installed, you may add an entry for your Sendinblue API credentials to your
application's services configuration file:
'sendinblue' => [
'key' => 'your-api-key',
],

Next, you may use the Mail facade's extend method to register the transport with Laravel. Typically, this should be
done within the boot method of a service provider:

Page 564 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Mail;
use Symfony\Component\Mailer\Bridge\Sendinblue\Transport\SendinblueTransportFactory;
use Symfony\Component\Mailer\Transport\Dsn;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Mail::extend('sendinblue', function () {
return (new SendinblueTransportFactory)->create(
new Dsn(
'sendinblue+api',
'default',
config('services.sendinblue.key')
)
);
});
}

Once your transport has been registered, you may create a mailer definition within your application's config/mail.php
configuration file that utilizes the new transport:
'sendinblue' => [
'transport' => 'sendinblue',
// ...
],

Page 565 of 1307

Laravel 9.x

Notifications
Introduction
Generating Notifications
Sending Notifications
Using The Notifiable Trait
Using The Notification Facade
Specifying Delivery Channels
Queueing Notifications
On-Demand Notifications
Mail Notifications
Formatting Mail Messages
Customizing The Sender
Customizing The Recipient
Customizing The Subject
Customizing The Mailer
Customizing The Templates
Attachments
Adding Tags & Metadata
Customizing The Symfony Message
Using Mailables
Previewing Mail Notifications
Markdown Mail Notifications
Generating The Message
Writing The Message
Customizing The Components
Database Notifications
Prerequisites
Formatting Database Notifications
Accessing The Notifications
Marking Notifications As Read
Broadcast Notifications
Prerequisites
Formatting Broadcast Notifications
Listening For Notifications
SMS Notifications
Prerequisites
Formatting SMS Notifications
Formatting Shortcode Notifications
Customizing The "From" Number
Adding A Client Reference
Routing SMS Notifications
Slack Notifications
Prerequisites
Formatting Slack Notifications
Slack Attachments
Routing Slack Notifications
Localizing Notifications
Notification Events
Custom Channels

Page 566 of 1307

Laravel 9.x

Introduction

In addition to support for sending email, Laravel provides support for sending notifications across a variety of delivery
channels, including email, SMS (via Vonage, formerly known as Nexmo), and Slack. In addition, a variety of community built
notification channels have been created to send notifications over dozens of different channels! Notifications may also be
stored in a database so they may be displayed in your web interface.
Typically, notifications should be short, informational messages that notify users of something that occurred in your
application. For example, if you are writing a billing application, you might send an "Invoice Paid" notification to your users
via the email and SMS channels.

Generating Notifications

In Laravel, each notification is represented by a single class that is typically stored in the app/Notifications directory.
Don't worry if you don't see this directory in your application - it will be created for you when you run the
make:notification Artisan command:
php artisan make:notification InvoicePaid

This command will place a fresh notification class in your app/Notifications directory. Each notification class contains
a via method and a variable number of message building methods, such as toMail or toDatabase , that convert the
notification to a message tailored for that particular channel.

Sending Notifications
Using The Notifiable Trait

Notifications may be sent in two ways: using the notify method of the Notifiable trait or using the Notification
facade. The Notifiable trait is included on your application's App\Models\User model by default:
<?php
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable
{
use Notifiable;
}

The notify method that is provided by this trait expects to receive a notification instance:
use App\Notifications\InvoicePaid;
$user->notify(new InvoicePaid($invoice));

Remember, you may use the Notifiable trait on any of your models. You are not limited to only
including it on your User model.

Page 567 of 1307

Laravel 9.x

Using The Notification Facade

Alternatively, you may send notifications via the Notification facade. This approach is useful when you need to send a
notification to multiple notifiable entities such as a collection of users. To send notifications using the facade, pass all of
the notifiable entities and the notification instance to the send method:
use Illuminate\Support\Facades\Notification;
Notification::send($users, new InvoicePaid($invoice));

You can also send notifications immediately using the sendNow method. This method will send the notification
immediately even if the notification implements the ShouldQueue interface:
Notification::sendNow($developers, new DeploymentCompleted($deployment));

Specifying Delivery Channels

Every notification class has a via method that determines on which channels the notification will be delivered.
Notifications may be sent on the mail , database , broadcast , vonage , and slack channels.
If you would like to use other delivery channels such as Telegram or Pusher, check out the
community driven Laravel Notification Channels website.
The via method receives a $notifiable instance, which will be an instance of the class to which the notification is
being sent. You may use $notifiable to determine which channels the notification should be delivered on:
/**
* Get the notification's delivery channels.
*
* @param

mixed

$notifiable

* @return array
*/
public function via($notifiable)
{
return $notifiable->prefers_sms ? ['vonage'] : ['mail', 'database'];
}

Queueing Notifications
Before queueing notifications you should configure your queue and start a worker.
Sending notifications can take time, especially if the channel needs to make an external API call to deliver the notification.
To speed up your application's response time, let your notification be queued by adding the ShouldQueue interface and
Queueable trait to your class. The interface and trait are already imported for all notifications generated using the
make:notification command, so you may immediately add them to your notification class:

Page 568 of 1307

Laravel 9.x

<?php
namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue
{
use Queueable;
// ...
}

Once the ShouldQueue interface has been added to your notification, you may send the notification like normal. Laravel
will detect the ShouldQueue interface on the class and automatically queue the delivery of the notification:
$user->notify(new InvoicePaid($invoice));

When queueing notifications, a queued job will be created for each recipient and channel combination. For example, six
jobs will be dispatched to the queue if your notification has three recipients and two channels.
Delaying Notifications
If you would like to delay the delivery of the notification, you may chain the delay method onto your notification
instantiation:
$delay = now()->addMinutes(10);
$user->notify((new InvoicePaid($invoice))->delay($delay));

Delaying Notifications Per Channel
You may pass an array to the delay method to specify the delay amount for specific channels:
$user->notify((new InvoicePaid($invoice))->delay([
'mail' => now()->addMinutes(5),
'sms' => now()->addMinutes(10),
]));

Alternatively, you may define a withDelay method on the notification class itself. The withDelay method should return
an array of channel names and delay values:

Page 569 of 1307

Laravel 9.x

/**
* Determine the notification's delivery delay.
*
* @param

mixed

$notifiable

* @return array
*/
public function withDelay($notifiable)
{
return [
'mail' => now()->addMinutes(5),
'sms' => now()->addMinutes(10),
];
}

Customizing The Notification Queue Connection
By default, queued notifications will be queued using your application's default queue connection. If you would like to
specify a different connection that should be used for a particular notification, you may define a $connection property
on the notification class:
/**
* The name of the queue connection to use when queueing the notification.
*
* @var string
*/
public $connection = 'redis';

Or, if you would like to specify a specific queue connection that should be used for each notification channel supported by
the notification, you may define a viaConnections method on your notification. This method should return an array of
channel name / queue connection name pairs:
/**
* Determine which connections should be used for each notification channel.
*
* @return array
*/
public function viaConnections()
{
return [
'mail' => 'redis',
'database' => 'sync',
];
}

Customizing Notification Channel Queues
If you would like to specify a specific queue that should be used for each notification channel supported by the
notification, you may define a viaQueues method on your notification. This method should return an array of channel
name / queue name pairs:

Page 570 of 1307

Laravel 9.x

/**
* Determine which queues should be used for each notification channel.
*
* @return array
*/
public function viaQueues()
{
return [
'mail' => 'mail-queue',
'slack' => 'slack-queue',
];
}

Queued Notifications & Database Transactions
When queued notifications are dispatched within database transactions, they may be processed by the queue before the
database transaction has committed. When this happens, any updates you have made to models or database records
during the database transaction may not yet be reflected in the database. In addition, any models or database records
created within the transaction may not exist in the database. If your notification depends on these models, unexpected
errors can occur when the job that sends the queued notification is processed.
If your queue connection's after_commit configuration option is set to false , you may still indicate that a particular
queued notification should be dispatched after all open database transactions have been committed by calling the
afterCommit method when sending the notification:
use App\Notifications\InvoicePaid;
$user->notify((new InvoicePaid($invoice))->afterCommit());

Alternatively, you may call the afterCommit method from your notification's constructor:
<?php
namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue
{
use Queueable;
/**
* Create a new notification instance.
*
* @return void
*/
public function __construct()
{
$this->afterCommit();
}
}

Page 571 of 1307

Laravel 9.x

To learn more about working around these issues, please review the documentation regarding
queued jobs and database transactions.
Determining If A Queued Notification Should Be Sent
After a queued notification has been dispatched for the queue for background processing, it will typically be accepted by a
queue worker and sent to its intended recipient.
However, if you would like to make the final determination on whether the queued notification should be sent after it is
being processed by a queue worker, you may define a shouldSend method on the notification class. If this method
returns false , the notification will not be sent:
/**
* Determine if the notification should be sent.
*
* @param

mixed

$notifiable

* @param

string

$channel

* @return bool
*/
public function shouldSend($notifiable, $channel)
{
return $this->invoice->isPaid();
}

On-Demand Notifications

Sometimes you may need to send a notification to someone who is not stored as a "user" of your application. Using the
Notification facade's route method, you may specify ad-hoc notification routing information before sending the
notification:
use Illuminate\Broadcasting\Channel;
use Illuminate\Support\Facades\Notification;
Notification::route('mail', 'taylor@example.com')
->route('vonage', '5555555555')
->route('slack', 'https://hooks.slack.com/services/...')
->route('broadcast', [new Channel('channel-name')])
->notify(new InvoicePaid($invoice));

If you would like to provide the recipient's name when sending an on-demand notification to the mail route, you may
provide an array that contains the email address as the key and the name as the value of the first element in the array:
Notification::route('mail', [
'barrett@example.com' => 'Barrett Blair',
])->notify(new InvoicePaid($invoice));

Mail Notifications

Formatting Mail Messages

Page 572 of 1307

Laravel 9.x

If a notification supports being sent as an email, you should define a toMail method on the notification class. This
method will receive a $notifiable entity and should return an Illuminate\Notifications\Messages\MailMessage
instance.
The MailMessage class contains a few simple methods to help you build transactional email messages. Mail messages
may contain lines of text as well as a "call to action". Let's take a look at an example toMail method:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
$url = url('/invoice/'.$this->invoice->id);
return (new MailMessage)
->greeting('Hello!')
->line('One of your invoices has been paid!')
->lineIf($this->amount > 0, "Amount paid: {$this->amount}")
->action('View Invoice', $url)
->line('Thank you for using our application!');
}

Note we are using $this->invoice->id in our toMail method. You may pass any data your
notification needs to generate its message into the notification's constructor.
In this example, we register a greeting, a line of text, a call to action, and then another line of text. These methods provided
by the MailMessage object make it simple and fast to format small transactional emails. The mail channel will then
translate the message components into a beautiful, responsive HTML email template with a plain-text counterpart. Here is
an example of an email generated by the mail channel:

Page 573 of 1307

Laravel 9.x

When sending mail notifications, be sure to set the name configuration option in your
config/app.php configuration file. This value will be used in the header and footer of your mail
notification messages.

Page 574 of 1307

Laravel 9.x

Error Messages
Some notifications inform users of errors, such as a failed invoice payment. You may indicate that a mail message is
regarding an error by calling the error method when building your message. When using the error method on a mail
message, the call to action button will be red instead of black:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->error()
->subject('Invoice Payment Failed')
->line('...');
}

Other Mail Notification Formatting Options
Instead of defining the "lines" of text in the notification class, you may use the view method to specify a custom
template that should be used to render the notification email:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)->view(
'emails.name', ['invoice' => $this->invoice]
);
}

You may specify a plain-text view for the mail message by passing the view name as the second element of an array that is
given to the view method:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)->view(
['emails.name.html', 'emails.name.plain'],
['invoice' => $this->invoice]
);
}

Page 575 of 1307

Laravel 9.x

Customizing The Sender

By default, the email's sender / from address is defined in the config/mail.php configuration file. However, you may
specify the from address for a specific notification using the from method:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->from('barrett@example.com', 'Barrett Blair')
->line('...');
}

Customizing The Recipient

When sending notifications via the mail channel, the notification system will automatically look for an email property
on your notifiable entity. You may customize which email address is used to deliver the notification by defining a
routeNotificationForMail method on the notifiable entity:
<?php
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable
{
use Notifiable;
/**
* Route notifications for the mail channel.
*
* @param

\Illuminate\Notifications\Notification

$notification

* @return array|string
*/
public function routeNotificationForMail($notification)
{
// Return email address only...
return $this->email_address;
// Return email address and name...
return [$this->email_address => $this->name];
}
}

Customizing The Subject

By default, the email's subject is the class name of the notification formatted to "Title Case". So, if your notification class is
named InvoicePaid , the email's subject will be Invoice Paid . If you would like to specify a different subject for the
Page 576 of 1307

Laravel 9.x

message, you may call the subject method when building your message:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->subject('Notification Subject')
->line('...');
}

Customizing The Mailer

By default, the email notification will be sent using the default mailer defined in the config/mail.php configuration file.
However, you may specify a different mailer at runtime by calling the mailer method when building your message:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->mailer('postmark')
->line('...');
}

Customizing The Templates

You can modify the HTML and plain-text template used by mail notifications by publishing the notification package's
resources. After running this command, the mail notification templates will be located in the
resources/views/vendor/notifications directory:
php artisan vendor:publish --tag=laravel-notifications

Attachments

To add attachments to an email notification, use the attach method while building your message. The attach method
accepts the absolute path to the file as its first argument:

Page 577 of 1307

Laravel 9.x

/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->greeting('Hello!')
->attach('/path/to/file');
}

The attach method offered by notification mail messages also accepts attachable objects.
Please consult the comprehensive attachable object documentation to learn more.
When attaching files to a message, you may also specify the display name and / or MIME type by passing an array as the
second argument to the attach method:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->greeting('Hello!')
->attach('/path/to/file', [
'as' => 'name.pdf',
'mime' => 'application/pdf',
]);
}

Unlike attaching files in mailable objects, you may not attach a file directly from a storage disk using
attachFromStorage . You should rather use the attach method with an absolute path to the file on the storage disk.
Alternatively, you could return a mailable from the toMail method:

Page 578 of 1307

Laravel 9.x

use App\Mail\InvoicePaid as InvoicePaidMailable;
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return Mailable
*/
public function toMail($notifiable)
{
return (new InvoicePaidMailable($this->invoice))
->to($notifiable->email)
->attachFromStorage('/path/to/file');
}

When necessary, multiple files may be attached to a message using the attachMany method:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->greeting('Hello!')
->attachMany([
'/path/to/forge.svg',
'/path/to/vapor.svg' => [
'as' => 'Logo.svg',
'mime' => 'image/svg+xml',
],
]);
}

Raw Data Attachments
The attachData method may be used to attach a raw string of bytes as an attachment. When calling the attachData
method, you should provide the filename that should be assigned to the attachment:

Page 579 of 1307

Laravel 9.x

/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->greeting('Hello!')
->attachData($this->pdf, 'name.pdf', [
'mime' => 'application/pdf',
]);
}

Adding Tags & Metadata

Some third-party email providers such as Mailgun and Postmark support message "tags" and "metadata", which may be
used to group and track emails sent by your application. You may add tags and metadata to an email message via the
tag and metadata methods:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->greeting('Comment Upvoted!')
->tag('upvote')
->metadata('comment_id', $this->comment->id);
}

If your application is using the Mailgun driver, you may consult Mailgun's documentation for more information on tags and
metadata. Likewise, the Postmark documentation may also be consulted for more information on their support for tags and
metadata.
If your application is using Amazon SES to send emails, you should use the metadata method to attach SES "tags" to the
message.

Customizing The Symfony Message

The withSymfonyMessage method of the MailMessage class allows you to register a closure which will be invoked with
the Symfony Message instance before sending the message. This gives you an opportunity to deeply customize the
message before it is delivered:

Page 580 of 1307

Laravel 9.x

use Symfony\Component\Mime\Email;
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->withSymfonyMessage(function (Email $message) {
$message->getHeaders()->addTextHeader(
'Custom-Header', 'Header Value'
);
});
}

Using Mailables

If needed, you may return a full mailable object from your notification's toMail method. When returning a Mailable
instead of a MailMessage , you will need to specify the message recipient using the mailable object's to method:
use App\Mail\InvoicePaid as InvoicePaidMailable;
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return Mailable
*/
public function toMail($notifiable)
{
return (new InvoicePaidMailable($this->invoice))
->to($notifiable->email);
}

Mailables & On-Demand Notifications
If you are sending an on-demand notification, the $notifiable instance given to the toMail method will be an
instance of Illuminate\Notifications\AnonymousNotifiable , which offers a routeNotificationFor method that
may be used to retrieve the email address the on-demand notification should be sent to:

Page 581 of 1307

Laravel 9.x

use App\Mail\InvoicePaid as InvoicePaidMailable;
use Illuminate\Notifications\AnonymousNotifiable;
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return Mailable
*/
public function toMail($notifiable)
{
$address = $notifiable instanceof AnonymousNotifiable
? $notifiable->routeNotificationFor('mail')
: $notifiable->email;
return (new InvoicePaidMailable($this->invoice))
->to($address);
}

Previewing Mail Notifications

When designing a mail notification template, it is convenient to quickly preview the rendered mail message in your browser
like a typical Blade template. For this reason, Laravel allows you to return any mail message generated by a mail
notification directly from a route closure or controller. When a MailMessage is returned, it will be rendered and displayed
in the browser, allowing you to quickly preview its design without needing to send it to an actual email address:
use App\Models\Invoice;
use App\Notifications\InvoicePaid;
Route::get('/notification', function () {
$invoice = Invoice::find(1);
return (new InvoicePaid($invoice))
->toMail($invoice->user);
});

Markdown Mail Notifications

Markdown mail notifications allow you to take advantage of the pre-built templates of mail notifications, while giving you
more freedom to write longer, customized messages. Since the messages are written in Markdown, Laravel is able to
render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text
counterpart.

Generating The Message

To generate a notification with a corresponding Markdown template, you may use the --markdown option of the
make:notification Artisan command:
php artisan make:notification InvoicePaid --markdown=mail.invoice.paid

Like all other mail notifications, notifications that use Markdown templates should define a toMail method on their
notification class. However, instead of using the line and action methods to construct the notification, use the
markdown method to specify the name of the Markdown template that should be used. An array of data you wish to make
available to the template may be passed as the method's second argument:
Page 582 of 1307

Laravel 9.x

/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
$url = url('/invoice/'.$this->invoice->id);
return (new MailMessage)
->subject('Invoice Paid')
->markdown('mail.invoice.paid', ['url' => $url]);
}

Writing The Message

Markdown mail notifications use a combination of Blade components and Markdown syntax which allow you to easily
construct notifications while leveraging Laravel's pre-crafted notification components:
<x-mail::message>
# Invoice Paid
Your invoice has been paid!
<x-mail::button :url="$url">
View Invoice
</x-mail::button>
Thanks,<br>
{{ config('app.name') }}
</x-mail::message>

Button Component
The button component renders a centered button link. The component accepts two arguments, a url and an optional
color . Supported colors are primary , green , and red . You may add as many button components to a notification
as you wish:
<x-mail::button :url="$url" color="green">
View Invoice
</x-mail::button>

Panel Component
The panel component renders the given block of text in a panel that has a slightly different background color than the rest
of the notification. This allows you to draw attention to a given block of text:
<x-mail::panel>
This is the panel content.
</x-mail::panel>

Table Component

Page 583 of 1307

Laravel 9.x

The table component allows you to transform a Markdown table into an HTML table. The component accepts the
Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax:
<x-mail::table>
| Laravel

| Table

| Example

|

| ------------- |:-------------:| --------:|
| Col 2 is

| Centered

| $10

|

| Col 3 is

| Right-Aligned | $20

|

</x-mail::table>

Customizing The Components

You may export all of the Markdown notification components to your own application for customization. To export the
components, use the vendor:publish Artisan command to publish the laravel-mail asset tag:
php artisan vendor:publish --tag=laravel-mail

This command will publish the Markdown mail components to the resources/views/vendor/mail directory. The mail
directory will contain an html and a text directory, each containing their respective representations of every available
component. You are free to customize these components however you like.
Customizing The CSS
After exporting the components, the resources/views/vendor/mail/html/themes directory will contain a
default.css file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML
representations of your Markdown notifications.
If you would like to build an entirely new theme for Laravel's Markdown components, you may place a CSS file within the
html/themes directory. After naming and saving your CSS file, update the theme option of the mail configuration file
to match the name of your new theme.
To customize the theme for an individual notification, you may call the theme method while building the notification's mail
message. The theme method accepts the name of the theme that should be used when sending the notification:
/**
* Get the mail representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\MailMessage
*/
public function toMail($notifiable)
{
return (new MailMessage)
->theme('invoice')
->subject('Invoice Paid')
->markdown('mail.invoice.paid', ['url' => $url]);
}

Database Notifications
Prerequisites

The database notification channel stores the notification information in a database table. This table will contain
information such as the notification type as well as a JSON data structure that describes the notification.

Page 584 of 1307

Laravel 9.x

You can query the table to display the notifications in your application's user interface. But, before you can do that, you will
need to create a database table to hold your notifications. You may use the notifications:table command to
generate a migration with the proper table schema:
php artisan notifications:table
php artisan migrate

Formatting Database Notifications

If a notification supports being stored in a database table, you should define a toDatabase or toArray method on the
notification class. This method will receive a $notifiable entity and should return a plain PHP array. The returned array
will be encoded as JSON and stored in the data column of your notifications table. Let's take a look at an example
toArray method:
/**
* Get the array representation of the notification.
*
* @param

mixed

$notifiable

* @return array
*/
public function toArray($notifiable)
{
return [
'invoice_id' => $this->invoice->id,
'amount' => $this->invoice->amount,
];
}

Vs. toArray
The toArray method is also used by the broadcast channel to determine which data to broadcast to your JavaScript
powered frontend. If you would like to have two different array representations for the database and broadcast
channels, you should define a toDatabase method instead of a toArray method.
toDatabase

Accessing The Notifications

Once notifications are stored in the database, you need a convenient way to access them from your notifiable entities. The
Illuminate\Notifications\Notifiable trait, which is included on Laravel's default App\Models\User model,
includes a notifications Eloquent relationship that returns the notifications for the entity. To fetch notifications, you
may access this method like any other Eloquent relationship. By default, notifications will be sorted by the created_at
timestamp with the most recent notifications at the beginning of the collection:
$user = App\Models\User::find(1);
foreach ($user->notifications as $notification) {
echo $notification->type;
}

If you want to retrieve only the "unread" notifications, you may use the unreadNotifications relationship. Again, these
notifications will be sorted by the created_at timestamp with the most recent notifications at the beginning of the
collection:

Page 585 of 1307

Laravel 9.x

$user = App\Models\User::find(1);
foreach ($user->unreadNotifications as $notification) {
echo $notification->type;
}

To access your notifications from your JavaScript client, you should define a notification controller
for your application which returns the notifications for a notifiable entity, such as the current user.
You may then make an HTTP request to that controller's URL from your JavaScript client.

Marking Notifications As Read

Typically, you will want to mark a notification as "read" when a user views it. The
Illuminate\Notifications\Notifiable trait provides a markAsRead method, which updates the read_at column
on the notification's database record:
$user = App\Models\User::find(1);
foreach ($user->unreadNotifications as $notification) {
$notification->markAsRead();
}

However, instead of looping through each notification, you may use the markAsRead method directly on a collection of
notifications:
$user->unreadNotifications->markAsRead();

You may also use a mass-update query to mark all of the notifications as read without retrieving them from the database:
$user = App\Models\User::find(1);
$user->unreadNotifications()->update(['read_at' => now()]);

You may delete the notifications to remove them from the table entirely:
$user->notifications()->delete();

Broadcast Notifications
Prerequisites

Before broadcasting notifications, you should configure and be familiar with Laravel's event broadcasting services. Event
broadcasting provides a way to react to server-side Laravel events from your JavaScript powered frontend.

Formatting Broadcast Notifications

The broadcast channel broadcasts notifications using Laravel's event broadcasting services, allowing your JavaScript
powered frontend to catch notifications in realtime. If a notification supports broadcasting, you can define a
toBroadcast method on the notification class. This method will receive a $notifiable entity and should return a
BroadcastMessage instance. If the toBroadcast method does not exist, the toArray method will be used to gather
Page 586 of 1307

Laravel 9.x

the data that should be broadcast. The returned data will be encoded as JSON and broadcast to your JavaScript powered
frontend. Let's take a look at an example toBroadcast method:
use Illuminate\Notifications\Messages\BroadcastMessage;
/**
* Get the broadcastable representation of the notification.
*
* @param

mixed

$notifiable

* @return BroadcastMessage
*/
public function toBroadcast($notifiable)
{
return new BroadcastMessage([
'invoice_id' => $this->invoice->id,
'amount' => $this->invoice->amount,
]);
}

Broadcast Queue Configuration
All broadcast notifications are queued for broadcasting. If you would like to configure the queue connection or queue name
that is used to queue the broadcast operation, you may use the onConnection and onQueue methods of the
BroadcastMessage :
return (new BroadcastMessage($data))
->onConnection('sqs')
->onQueue('broadcasts');

Customizing The Notification Type
In addition to the data you specify, all broadcast notifications also have a type field containing the full class name of the
notification. If you would like to customize the notification type , you may define a broadcastType method on the
notification class:
use Illuminate\Notifications\Messages\BroadcastMessage;
/**
* Get the type of the notification being broadcast.
*
* @return string
*/
public function broadcastType()
{
return 'broadcast.message';
}

Listening For Notifications

Notifications will broadcast on a private channel formatted using a {notifiable}.{id} convention. So, if you are
sending a notification to an App\Models\User instance with an ID of 1 , the notification will be broadcast on the
App.Models.User.1 private channel. When using Laravel Echo, you may easily listen for notifications on a channel using
the notification method:

Page 587 of 1307

Laravel 9.x

Echo.private('App.Models.User.' + userId)
.notification((notification) => {
console.log(notification.type);
});

Customizing The Notification Channel
If you would like to customize which channel that an entity's broadcast notifications are broadcast on, you may define a
receivesBroadcastNotificationsOn method on the notifiable entity:
<?php
namespace App\Models;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable
{
use Notifiable;
/**
* The channels the user receives notification broadcasts on.
*
* @return string
*/
public function receivesBroadcastNotificationsOn()
{
return 'users.'.$this->id;
}
}

SMS Notifications
Prerequisites

Sending SMS notifications in Laravel is powered by Vonage (formerly known as Nexmo). Before you can send notifications
via Vonage, you need to install the laravel/vonage-notification-channel and guzzlehttp/guzzle packages:
composer require laravel/vonage-notification-channel guzzlehttp/guzzle

The package includes a configuration file. However, you are not required to export this configuration file to your own
application. You can simply use the VONAGE_KEY and VONAGE_SECRET environment variables to define your Vonage
public and secret keys.
After defining your keys, you should set a VONAGE_SMS_FROM environment variable that defines the phone number that
your SMS messages should be sent from by default. You may generate this phone number within the Vonage control panel:
VONAGE_SMS_FROM=15556666666

Formatting SMS Notifications

Page 588 of 1307

Laravel 9.x

If a notification supports being sent as an SMS, you should define a toVonage method on the notification class. This
method will receive a $notifiable entity and should return an
Illuminate\Notifications\Messages\VonageMessage instance:
/**
* Get the Vonage / SMS representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\VonageMessage
*/
public function toVonage($notifiable)
{
return (new VonageMessage)
->content('Your SMS message content');
}

Unicode Content
If your SMS message will contain unicode characters, you should call the unicode method when constructing the
VonageMessage instance:
/**
* Get the Vonage / SMS representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\VonageMessage
*/
public function toVonage($notifiable)
{
return (new VonageMessage)
->content('Your unicode message')
->unicode();
}

Customizing The "From" Number

If you would like to send some notifications from a phone number that is different from the phone number specified by your
VONAGE_SMS_FROM environment variable, you may call the from method on a VonageMessage instance:
/**
* Get the Vonage / SMS representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\VonageMessage
*/
public function toVonage($notifiable)
{
return (new VonageMessage)
->content('Your SMS message content')
->from('15554443333');
}

Adding a Client Reference
Page 589 of 1307

Laravel 9.x

If you would like to keep track of costs per user, team, or client, you may add a "client reference" to the notification.
Vonage will allow you to generate reports using this client reference so that you can better understand a particular
customer's SMS usage. The client reference can be any string up to 40 characters:
/**
* Get the Vonage / SMS representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\VonageMessage
*/
public function toVonage($notifiable)
{
return (new VonageMessage)
->clientReference((string) $notifiable->id)
->content('Your SMS message content');
}

Routing SMS Notifications

To route Vonage notifications to the proper phone number, define a routeNotificationForVonage method on your
notifiable entity:
<?php
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable
{
use Notifiable;
/**
* Route notifications for the Vonage channel.
*
* @param

\Illuminate\Notifications\Notification

$notification

* @return string
*/
public function routeNotificationForVonage($notification)
{
return $this->phone_number;
}
}

Slack Notifications
Prerequisites

Before you can send notifications via Slack, you must install the Slack notification channel via Composer:
composer require laravel/slack-notification-channel

Page 590 of 1307

Laravel 9.x

You will also need to create a Slack App for your team. After creating the App, you should configure an "Incoming
Webhook" for the workspace. Slack will then provide you with a webhook URL that you may use when routing Slack
notifications.

Formatting Slack Notifications

If a notification supports being sent as a Slack message, you should define a toSlack method on the notification class.
This method will receive a $notifiable entity and should return an
Illuminate\Notifications\Messages\SlackMessage instance. Slack messages may contain text content as well as
an "attachment" that formats additional text or an array of fields. Let's take a look at a basic toSlack example:
/**
* Get the Slack representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\SlackMessage
*/
public function toSlack($notifiable)
{
return (new SlackMessage)
->content('One of your invoices has been paid!');
}

Slack Attachments

You may also add "attachments" to Slack messages. Attachments provide richer formatting options than simple text
messages. In this example, we will send an error notification about an exception that occurred in an application, including a
link to view more details about the exception:
/**
* Get the Slack representation of the notification.
*
* @param

mixed

$notifiable

* @return \Illuminate\Notifications\Messages\SlackMessage
*/
public function toSlack($notifiable)
{
$url = url('/exceptions/'.$this->exception->id);
return (new SlackMessage)
->error()
->content('Whoops! Something went wrong.')
->attachment(function ($attachment) use ($url) {
$attachment->title('Exception: File Not Found', $url)
->content('File [background.jpg] was not found.');
});
}

Attachments also allow you to specify an array of data that should be presented to the user. The given data will be
presented in a table-style format for easy reading:

Page 591 of 1307

Laravel 9.x

/**
* Get the Slack representation of the notification.
*
* @param

mixed

$notifiable

* @return SlackMessage
*/
public function toSlack($notifiable)
{
$url = url('/invoices/'.$this->invoice->id);
return (new SlackMessage)
->success()
->content('One of your invoices has been paid!')
->attachment(function ($attachment) use ($url) {
$attachment->title('Invoice 1322', $url)
->fields([
'Title' => 'Server Expenses',
'Amount' => '$1,234',
'Via' => 'American Express',
'Was Overdue' => ':-1:',
]);
});
}

Markdown Attachment Content
If some of your attachment fields contain Markdown, you may use the markdown method to instruct Slack to parse and
display the given attachment fields as Markdown formatted text. The values accepted by this method are: pretext ,
text , and / or fields . For more information about Slack attachment formatting, check out the Slack API
documentation:
/**
* Get the Slack representation of the notification.
*
* @param

mixed

$notifiable

* @return SlackMessage
*/
public function toSlack($notifiable)
{
$url = url('/exceptions/'.$this->exception->id);
return (new SlackMessage)
->error()
->content('Whoops! Something went wrong.')
->attachment(function ($attachment) use ($url) {
$attachment->title('Exception: File Not Found', $url)
->content('File [background.jpg] was *not found*.')
->markdown(['text']);
});
}

Routing Slack Notifications

To route Slack notifications to the proper Slack team and channel, define a routeNotificationForSlack method on
your notifiable entity. This should return the webhook URL to which the notification should be delivered. Webhook URLs
Page 592 of 1307

Laravel 9.x

may be generated by adding an "Incoming Webhook" service to your Slack team:
<?php
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable
{
use Notifiable;
/**
* Route notifications for the Slack channel.
*
* @param

\Illuminate\Notifications\Notification

$notification

* @return string
*/
public function routeNotificationForSlack($notification)
{
return 'https://hooks.slack.com/services/...';
}
}

Localizing Notifications

Laravel allows you to send notifications in a locale other than the HTTP request's current locale, and will even remember
this locale if the notification is queued.
To accomplish this, the Illuminate\Notifications\Notification class offers a locale method to set the desired
language. The application will change into this locale when the notification is being evaluated and then revert back to the
previous locale when evaluation is complete:
$user->notify((new InvoicePaid($invoice))->locale('es'));

Localization of multiple notifiable entries may also be achieved via the Notification facade:
Notification::locale('es')->send(
$users, new InvoicePaid($invoice)
);

User Preferred Locales

Sometimes, applications store each user's preferred locale. By implementing the HasLocalePreference contract on
your notifiable model, you may instruct Laravel to use this stored locale when sending a notification:

Page 593 of 1307

Laravel 9.x

use Illuminate\Contracts\Translation\HasLocalePreference;
class User extends Model implements HasLocalePreference
{
/**
* Get the user's preferred locale.
*
* @return string
*/
public function preferredLocale()
{
return $this->locale;
}
}

Once you have implemented the interface, Laravel will automatically use the preferred locale when sending notifications
and mailables to the model. Therefore, there is no need to call the locale method when using this interface:
$user->notify(new InvoicePaid($invoice));

Notification Events

Notification Sending Event
When a notification is sending, the Illuminate\Notifications\Events\NotificationSending event is dispatched by
the notification system. This contains the "notifiable" entity and the notification instance itself. You may register listeners
for this event in your application's EventServiceProvider :
use App\Listeners\CheckNotificationStatus;
use Illuminate\Notifications\Events\NotificationSending;
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
NotificationSending::class => [
CheckNotificationStatus::class,
],
];

The notification will not be sent if an event listener for the NotificationSending event returns false from its
handle method:

Page 594 of 1307

Laravel 9.x

use Illuminate\Notifications\Events\NotificationSending;
/**
* Handle the event.
*
* @param

\Illuminate\Notifications\Events\NotificationSending

$event

* @return void
*/
public function handle(NotificationSending $event)
{
return false;
}

Within an event listener, you may access the notifiable , notification , and channel properties on the event to
learn more about the notification recipient or the notification itself:
/**
* Handle the event.
*
* @param

\Illuminate\Notifications\Events\NotificationSending

$event

* @return void
*/
public function handle(NotificationSending $event)
{
// $event->channel
// $event->notifiable
// $event->notification
}

Notification Sent Event
When a notification is sent, the Illuminate\Notifications\Events\NotificationSent event is dispatched by the
notification system. This contains the "notifiable" entity and the notification instance itself. You may register listeners for
this event in your EventServiceProvider :
use App\Listeners\LogNotification;
use Illuminate\Notifications\Events\NotificationSent;
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
NotificationSent::class => [
LogNotification::class,
],
];

After registering listeners in your EventServiceProvider , use the event:generate Artisan
command to quickly generate listener classes.

Page 595 of 1307

Laravel 9.x

Within an event listener, you may access the notifiable , notification , channel , and response properties on
the event to learn more about the notification recipient or the notification itself:
/**
* Handle the event.
*
* @param

\Illuminate\Notifications\Events\NotificationSent

$event

* @return void
*/
public function handle(NotificationSent $event)
{
// $event->channel
// $event->notifiable
// $event->notification
// $event->response
}

Custom Channels

Laravel ships with a handful of notification channels, but you may want to write your own drivers to deliver notifications via
other channels. Laravel makes it simple. To get started, define a class that contains a send method. The method should
receive two arguments: a $notifiable and a $notification .
Within the send method, you may call methods on the notification to retrieve a message object understood by your
channel and then send the notification to the $notifiable instance however you wish:
<?php
namespace App\Notifications;
use Illuminate\Notifications\Notification;
class VoiceChannel
{
/**
* Send the given notification.
*
* @param

mixed

* @param

\Illuminate\Notifications\Notification

$notifiable
$notification

* @return void
*/
public function send($notifiable, Notification $notification)
{
$message = $notification->toVoice($notifiable);
// Send notification to the $notifiable instance...
}
}

Once your notification channel class has been defined, you may return the class name from the via method of any of
your notifications. In this example, the toVoice method of your notification can return whatever object you choose to
represent voice messages. For example, you might define your own VoiceMessage class to represent these messages:

Page 596 of 1307

Laravel 9.x

<?php
namespace App\Notifications;
use App\Notifications\Messages\VoiceMessage;
use App\Notifications\VoiceChannel;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification
{
use Queueable;
/**
* Get the notification channels.
*
* @param

mixed

$notifiable

* @return array|string
*/
public function via($notifiable)
{
return [VoiceChannel::class];
}
/**
* Get the voice representation of the notification.
*
* @param

mixed

$notifiable

* @return VoiceMessage
*/
public function toVoice($notifiable)
{
// ...
}
}

Page 597 of 1307

Laravel 9.x

Package Development
Introduction
A Note On Facades
Package Discovery
Service Providers
Resources
Configuration
Migrations
Routes
Translations
Views
View Components
"About" Artisan Command
Commands
Public Assets
Publishing File Groups

Introduction

Packages are the primary way of adding functionality to Laravel. Packages might be anything from a great way to work with
dates like Carbon or a package that allows you to associate files with Eloquent models like Spatie's Laravel Media Library.
There are different types of packages. Some packages are stand-alone, meaning they work with any PHP framework.
Carbon and PHPUnit are examples of stand-alone packages. Any of these packages may be used with Laravel by requiring
them in your composer.json file.
On the other hand, other packages are specifically intended for use with Laravel. These packages may have routes,
controllers, views, and configuration specifically intended to enhance a Laravel application. This guide primarily covers the
development of those packages that are Laravel specific.

A Note On Facades

When writing a Laravel application, it generally does not matter if you use contracts or facades since both provide
essentially equal levels of testability. However, when writing packages, your package will not typically have access to all of
Laravel's testing helpers. If you would like to be able to write your package tests as if the package were installed inside a
typical Laravel application, you may use the Orchestral Testbench package.

Package Discovery

In a Laravel application's config/app.php configuration file, the providers option defines a list of service providers
that should be loaded by Laravel. When someone installs your package, you will typically want your service provider to be
included in this list. Instead of requiring users to manually add your service provider to the list, you may define the provider
in the extra section of your package's composer.json file. In addition to service providers, you may also list any
facades you would like to be registered:

Page 598 of 1307

Laravel 9.x

"extra": {
"laravel": {
"providers": [
"Barryvdh\\Debugbar\\ServiceProvider"
],
"aliases": {
"Debugbar": "Barryvdh\\Debugbar\\Facade"
}
}
},

Once your package has been configured for discovery, Laravel will automatically register its service providers and facades
when it is installed, creating a convenient installation experience for your package's users.

Opting Out Of Package Discovery

If you are the consumer of a package and would like to disable package discovery for a package, you may list the package
name in the extra section of your application's composer.json file:
"extra": {
"laravel": {
"dont-discover": [
"barryvdh/laravel-debugbar"
]
}
},

You may disable package discovery for all packages using the * character inside of your application's dont-discover
directive:
"extra": {
"laravel": {
"dont-discover": [
"*"
]
}
},

Service Providers

Service providers are the connection point between your package and Laravel. A service provider is responsible for binding
things into Laravel's service container and informing Laravel where to load package resources such as views,
configuration, and localization files.
A service provider extends the Illuminate\Support\ServiceProvider class and contains two methods: register
and boot . The base ServiceProvider class is located in the illuminate/support Composer package, which you
should add to your own package's dependencies. To learn more about the structure and purpose of service providers,
check out their documentation.

Resources

Configuration

Page 599 of 1307

Laravel 9.x

Typically, you will need to publish your package's configuration file to the application's config directory. This will allow
users of your package to easily override your default configuration options. To allow your configuration files to be
published, call the publishes method from the boot method of your service provider:
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->publishes([
__DIR__.'/../config/courier.php' => config_path('courier.php'),
]);
}

Now, when users of your package execute Laravel's vendor:publish command, your file will be copied to the specified
publish location. Once your configuration has been published, its values may be accessed like any other configuration file:
$value = config('courier.option');

You should not define closures in your configuration files. They can not be serialized correctly
when users execute the config:cache Artisan command.
Default Package Configuration
You may also merge your own package configuration file with the application's published copy. This will allow your users to
define only the options they actually want to override in the published copy of the configuration file. To merge the
configuration file values, use the mergeConfigFrom method within your service provider's register method.
The mergeConfigFrom method accepts the path to your package's configuration file as its first argument and the name
of the application's copy of the configuration file as its second argument:
/**
* Register any application services.
*
* @return void
*/
public function register()
{
$this->mergeConfigFrom(
__DIR__.'/../config/courier.php', 'courier'
);
}

This method only merges the first level of the configuration array. If your users partially define a
multi-dimensional configuration array, the missing options will not be merged.

Page 600 of 1307

Laravel 9.x

Routes

If your package contains routes, you may load them using the loadRoutesFrom method. This method will automatically
determine if the application's routes are cached and will not load your routes file if the routes have already been cached:
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->loadRoutesFrom(__DIR__.'/../routes/web.php');
}

Migrations

If your package contains database migrations, you may use the loadMigrationsFrom method to inform Laravel how to
load them. The loadMigrationsFrom method accepts the path to your package's migrations as its only argument:
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->loadMigrationsFrom(__DIR__.'/../database/migrations');
}

Once your package's migrations have been registered, they will automatically be run when the php artisan migrate
command is executed. You do not need to export them to the application's database/migrations directory.

Translations

If your package contains translation files, you may use the loadTranslationsFrom method to inform Laravel how to load
them. For example, if your package is named courier , you should add the following to your service provider's boot
method:
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');
}

Package translations are referenced using the package::file.line syntax convention. So, you may load the courier
package's welcome line from the messages file like so:
echo trans('courier::messages.welcome');

Page 601 of 1307

Laravel 9.x

Publishing Translations
If you would like to publish your package's translations to the application's lang/vendor directory, you may use the
service provider's publishes method. The publishes method accepts an array of package paths and their desired
publish locations. For example, to publish the translation files for the courier package, you may do the following:
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');
$this->publishes([
__DIR__.'/../lang' => $this->app->langPath('vendor/courier'),
]);
}

Now, when users of your package execute Laravel's vendor:publish Artisan command, your package's translations will
be published to the specified publish location.

Views

To register your package's views with Laravel, you need to tell Laravel where the views are located. You may do this using
the service provider's loadViewsFrom method. The loadViewsFrom method accepts two arguments: the path to your
view templates and your package's name. For example, if your package's name is courier , you would add the following
to your service provider's boot method:
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');
}

Package views are referenced using the package::view syntax convention. So, once your view path is registered in a
service provider, you may load the dashboard view from the courier package like so:
Route::get('/dashboard', function () {
return view('courier::dashboard');
});

Overriding Package Views
When you use the loadViewsFrom method, Laravel actually registers two locations for your views: the application's
resources/views/vendor directory and the directory you specify. So, using the courier package as an example,
Laravel will first check if a custom version of the view has been placed in the resources/views/vendor/courier
directory by the developer. Then, if the view has not been customized, Laravel will search the package view directory you
specified in your call to loadViewsFrom . This makes it easy for package users to customize / override your package's
views.
Page 602 of 1307

Laravel 9.x

Publishing Views
If you would like to make your views available for publishing to the application's resources/views/vendor directory, you
may use the service provider's publishes method. The publishes method accepts an array of package view paths
and their desired publish locations:
/**
* Bootstrap the package services.
*
* @return void
*/
public function boot()
{
$this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');
$this->publishes([
__DIR__.'/../resources/views' => resource_path('views/vendor/courier'),
]);
}

Now, when users of your package execute Laravel's vendor:publish Artisan command, your package's views will be
copied to the specified publish location.

View Components

If you are building a package that utilizes Blade components or placing components in non-conventional directories, you
will need to manually register your component class and its HTML tag alias so that Laravel knows where to find the
component. You should typically register your components in the boot method of your package's service provider:
use Illuminate\Support\Facades\Blade;
use VendorPackage\View\Components\AlertComponent;
/**
* Bootstrap your package's services.
*
* @return void
*/
public function boot()
{
Blade::component('package-alert', AlertComponent::class);
}

Once your component has been registered, it may be rendered using its tag alias:
<x-package-alert/>

Autoloading Package Components
Alternatively, you may use the componentNamespace method to autoload component classes by convention. For
example, a Nightshade package might have Calendar and ColorPicker components that reside within the
Nightshade\Views\Components namespace:

Page 603 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Blade;
/**
* Bootstrap your package's services.
*
* @return void
*/
public function boot()
{
Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');
}

This will allow the usage of package components by their vendor namespace using the package-name:: syntax:
<x-nightshade::calendar />
<x-nightshade::color-picker />

Blade will automatically detect the class that's linked to this component by pascal-casing the component name.
Subdirectories are also supported using "dot" notation.
Anonymous Components
If your package contains anonymous components, they must be placed within a components directory of your package's
"views" directory (as specified by the loadViewsFrom method). Then, you may render them by prefixing the component
name with the package's view namespace:
<x-courier::alert />

"About" Artisan Command

Laravel's built-in about Artisan command provides a synopsis of the application's environment and configuration.
Packages may push additional information to this command's output via the AboutCommand class. Typically, this
information may be added from your package service provider's boot method:
use Illuminate\Foundation\Console\AboutCommand;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
AboutCommand::add('My Package', fn () => ['Version' => '1.0.0']);
}

Commands

To register your package's Artisan commands with Laravel, you may use the commands method. This method expects an
array of command class names. Once the commands have been registered, you may execute them using the Artisan CLI:

Page 604 of 1307

Laravel 9.x

use Courier\Console\Commands\InstallCommand;
use Courier\Console\Commands\NetworkCommand;
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
if ($this->app->runningInConsole()) {
$this->commands([
InstallCommand::class,
NetworkCommand::class,
]);
}
}

Public Assets

Your package may have assets such as JavaScript, CSS, and images. To publish these assets to the application's public
directory, use the service provider's publishes method. In this example, we will also add a public asset group tag,
which may be used to easily publish groups of related assets:
/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->publishes([
__DIR__.'/../public' => public_path('vendor/courier'),
], 'public');
}

Now, when your package's users execute the vendor:publish command, your assets will be copied to the specified
publish location. Since users will typically need to overwrite the assets every time the package is updated, you may use the
--force flag:
php artisan vendor:publish --tag=public --force

Publishing File Groups

You may want to publish groups of package assets and resources separately. For instance, you might want to allow your
users to publish your package's configuration files without being forced to publish your package's assets. You may do this
by "tagging" them when calling the publishes method from a package's service provider. For example, let's use tags to
define two publish groups for the courier package ( courier-config and courier-migrations ) in the boot
method of the package's service provider:

Page 605 of 1307

Laravel 9.x

/**
* Bootstrap any package services.
*
* @return void
*/
public function boot()
{
$this->publishes([
__DIR__.'/../config/package.php' => config_path('package.php')
], 'courier-config');
$this->publishes([
__DIR__.'/../database/migrations/' => database_path('migrations')
], 'courier-migrations');
}

Now your users may publish these groups separately by referencing their tag when executing the vendor:publish
command:
php artisan vendor:publish --tag=courier-config

Page 606 of 1307

Laravel 9.x

Queues
Introduction
Connections Vs. Queues
Driver Notes & Prerequisites
Creating Jobs
Generating Job Classes
Class Structure
Unique Jobs
Job Middleware
Rate Limiting
Preventing Job Overlaps
Throttling Exceptions
Dispatching Jobs
Delayed Dispatching
Synchronous Dispatching
Jobs & Database Transactions
Job Chaining
Customizing The Queue & Connection
Specifying Max Job Attempts / Timeout Values
Error Handling
Job Batching
Defining Batchable Jobs
Dispatching Batches
Adding Jobs To Batches
Inspecting Batches
Cancelling Batches
Batch Failures
Pruning Batches
Queueing Closures
Running The Queue Worker
The queue:work Command
Queue Priorities
Queue Workers & Deployment
Job Expirations & Timeouts
Supervisor Configuration
Dealing With Failed Jobs
Cleaning Up After Failed Jobs
Retrying Failed Jobs
Ignoring Missing Models
Pruning Failed Jobs
Storing Failed Jobs In DynamoDB
Disabling Failed Job Storage
Failed Job Events
Clearing Jobs From Queues
Monitoring Your Queues
Job Events

Introduction

Page 607 of 1307

Laravel 9.x

While building your web application, you may have some tasks, such as parsing and storing an uploaded CSV file, that take
too long to perform during a typical web request. Thankfully, Laravel allows you to easily create queued jobs that may be
processed in the background. By moving time intensive tasks to a queue, your application can respond to web requests
with blazing speed and provide a better user experience to your customers.
Laravel queues provide a unified queueing API across a variety of different queue backends, such as Amazon SQS, Redis,
or even a relational database.
Laravel's queue configuration options are stored in your application's config/queue.php configuration file. In this file,
you will find connection configurations for each of the queue drivers that are included with the framework, including the
database, Amazon SQS, Redis, and Beanstalkd drivers, as well as a synchronous driver that will execute jobs immediately
(for use during local development). A null queue driver is also included which discards queued jobs.
Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered
queues. Check out the full Horizon documentation for more information.

Connections Vs. Queues

Before getting started with Laravel queues, it is important to understand the distinction between "connections" and
"queues". In your config/queue.php configuration file, there is a connections configuration array. This option
defines the connections to backend queue services such as Amazon SQS, Beanstalk, or Redis. However, any given queue
connection may have multiple "queues" which may be thought of as different stacks or piles of queued jobs.
Note that each connection configuration example in the queue configuration file contains a queue attribute. This is the
default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job
without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the
queue attribute of the connection configuration:
use App\Jobs\ProcessPodcast;
// This job is sent to the default connection's default queue...
ProcessPodcast::dispatch();
// This job is sent to the default connection's "emails" queue...
ProcessPodcast::dispatch()->onQueue('emails');

Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue.
However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how
jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For
example, if you push jobs to a high queue, you may run a worker that gives them higher processing priority:
php artisan queue:work --queue=high,default

Driver Notes & Prerequisites

Database
In order to use the database queue driver, you will need a database table to hold the jobs. To generate a migration that
creates this table, run the queue:table Artisan command. Once the migration has been created, you may migrate your
database using the migrate command:

Page 608 of 1307

Laravel 9.x

php artisan queue:table
php artisan migrate

Finally, don't forget to instruct your application to use the database driver by updating the QUEUE_CONNECTION variable
in your application's .env file:
QUEUE_CONNECTION=database

Redis
In order to use the redis queue driver, you should configure a Redis database connection in your
config/database.php configuration file.
Redis Cluster
If your Redis queue connection uses a Redis Cluster, your queue names must contain a key hash tag. This is required in
order to ensure all of the Redis keys for a given queue are placed into the same hash slot:
'redis' => [
'driver' => 'redis',
'connection' => 'default',
'queue' => '{default}',
'retry_after' => 90,
],

Blocking
When using the Redis queue, you may use the block_for configuration option to specify how long the driver should wait
for a job to become available before iterating through the worker loop and re-polling the Redis database.
Adjusting this value based on your queue load can be more efficient than continually polling the Redis database for new
jobs. For instance, you may set the value to 5 to indicate that the driver should block for five seconds while waiting for a
job to become available:
'redis' => [
'driver' => 'redis',
'connection' => 'default',
'queue' => 'default',
'retry_after' => 90,
'block_for' => 5,
],

Setting block_for to 0 will cause queue workers to block indefinitely until a job is available.
This will also prevent signals such as SIGTERM from being handled until the next job has been
processed.
Other Driver Prerequisites
The following dependencies are needed for the listed queue drivers. These dependencies may be installed via the
Composer package manager:

Page 609 of 1307

Laravel 9.x

Amazon SQS: aws/aws-sdk-php ~3.0
Beanstalkd: pda/pheanstalk ~4.0
Redis: predis/predis ~1.0 or phpredis PHP extension

Creating Jobs

Generating Job Classes

By default, all of the queueable jobs for your application are stored in the app/Jobs directory. If the app/Jobs directory
doesn't exist, it will be created when you run the make:job Artisan command:
php artisan make:job ProcessPodcast

The generated class will implement the Illuminate\Contracts\Queue\ShouldQueue interface, indicating to Laravel
that the job should be pushed onto the queue to run asynchronously.
Job stubs may be customized using stub publishing.

Class Structure

Job classes are very simple, normally containing only a handle method that is invoked when the job is processed by the
queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast
publishing service and need to process the uploaded podcast files before they are published:

Page 610 of 1307

Laravel 9.x

<?php
namespace App\Jobs;
use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
class ProcessPodcast implements ShouldQueue
{
use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
/**
* The podcast instance.
*
* @var \App\Models\Podcast
*/
public $podcast;
/**
* Create a new job instance.
*
* @param

App\Models\Podcast

$podcast

* @return void
*/
public function __construct(Podcast $podcast)
{
$this->podcast = $podcast;
}
/**
* Execute the job.
*
* @param

App\Services\AudioProcessor

$processor

* @return void
*/
public function handle(AudioProcessor $processor)
{
// Process uploaded podcast...
}
}

In this example, note that we were able to pass an Eloquent model directly into the queued job's constructor. Because of
the SerializesModels trait that the job is using, Eloquent models and their loaded relationships will be gracefully
serialized and unserialized when the job is processing.
If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the
queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance and its
loaded relationships from the database. This approach to model serialization allows for much smaller job payloads to be
sent to your queue driver.

Page 611 of 1307

Laravel 9.x

Method Dependency Injection
The handle method is invoked when the job is processed by the queue. Note that we are able to type-hint dependencies
on the handle method of the job. The Laravel service container automatically injects these dependencies.
If you would like to take total control over how the container injects dependencies into the handle method, you may use
the container's bindMethod method. The bindMethod method accepts a callback which receives the job and the
container. Within the callback, you are free to invoke the handle method however you wish. Typically, you should call this
method from the boot method of your App\Providers\AppServiceProvider service provider:
handle

use App\Jobs\ProcessPodcast;
use App\Services\AudioProcessor;
$this->app->bindMethod([ProcessPodcast::class, 'handle'], function ($job, $app) {
return $job->handle($app->make(AudioProcessor::class));
});

Binary data, such as raw image contents, should be passed through the base64_encode function
before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when
being placed on the queue.
Queued Relationships
Because loaded relationships also get serialized, the serialized job string can sometimes become quite large. To prevent
relations from being serialized, you can call the withoutRelations method on the model when setting a property value.
This method will return an instance of the model without its loaded relationships:
/**
* Create a new job instance.
*
* @param

\App\Models\Podcast

$podcast

* @return void
*/
public function __construct(Podcast $podcast)
{
$this->podcast = $podcast->withoutRelations();
}

Furthermore, when a job is deserialized and model relationships are re-retrieved from the database, they will be retrieved
in their entirety. Any previous relationship constraints that were applied before the model was serialized during the job
queueing process will not be applied when the job is deserialized. Therefore, if you wish to work with a subset of a given
relationship, you should re-constrain that relationship within your queued job.

Unique Jobs
Unique jobs require a cache driver that supports locks. Currently, the memcached , redis ,
dynamodb , database , file , and array cache drivers support atomic locks. In addition,
unique job constraints do not apply to jobs within batches.

Page 612 of 1307

Laravel 9.x

Sometimes, you may want to ensure that only one instance of a specific job is on the queue at any point in time. You may
do so by implementing the ShouldBeUnique interface on your job class. This interface does not require you to define any
additional methods on your class:
<?php
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
...
}

In the example above, the UpdateSearchIndex job is unique. So, the job will not be dispatched if another instance of the
job is already on the queue and has not finished processing.
In certain cases, you may want to define a specific "key" that makes the job unique or you may want to specify a timeout
beyond which the job no longer stays unique. To accomplish this, you may define uniqueId and uniqueFor properties
or methods on your job class:
<?php
use App\Models\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
/**
* The product instance.
*
* @var \App\Product
*/
public $product;
/**
* The number of seconds after which the job's unique lock will be released.
*
* @var int
*/
public $uniqueFor = 3600;
/**
* The unique ID of the job.
*
* @return string
*/
public function uniqueId()
{
return $this->product->id;
}
}

Page 613 of 1307

Laravel 9.x

In the example above, the UpdateSearchIndex job is unique by a product ID. So, any new dispatches of the job with the
same product ID will be ignored until the existing job has completed processing. In addition, if the existing job is not
processed within one hour, the unique lock will be released and another job with the same unique key can be dispatched to
the queue.
If your application dispatches jobs from multiple web servers or containers, you should ensure that
all of your servers are communicating with the same central cache server so that Laravel can
accurately determine if a job is unique.
Keeping Jobs Unique Until Processing Begins
By default, unique jobs are "unlocked" after a job completes processing or fails all of its retry attempts. However, there
may be situations where you would like your job to unlock immediately before it is processed. To accomplish this, your job
should implement the ShouldBeUniqueUntilProcessing contract instead of the ShouldBeUnique contract:
<?php
use App\Models\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing
{
// ...
}

Unique Job Locks
Behind the scenes, when a ShouldBeUnique job is dispatched, Laravel attempts to acquire a lock with the uniqueId
key. If the lock is not acquired, the job is not dispatched. This lock is released when the job completes processing or fails
all of its retry attempts. By default, Laravel will use the default cache driver to obtain this lock. However, if you wish to use
another driver for acquiring the lock, you may define a uniqueVia method that returns the cache driver that should be
used:
use Illuminate\Support\Facades\Cache;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
...
/**
* Get the cache driver for the unique job lock.
*
* @return \Illuminate\Contracts\Cache\Repository
*/
public function uniqueVia()
{
return Cache::driver('redis');
}
}

Page 614 of 1307

Laravel 9.x

If you only need to limit the concurrent processing of a job, use the WithoutOverlapping job
middleware instead.

Job Middleware

Job middleware allow you to wrap custom logic around the execution of queued jobs, reducing boilerplate in the jobs
themselves. For example, consider the following handle method which leverages Laravel's Redis rate limiting features to
allow only one job to process every five seconds:
use Illuminate\Support\Facades\Redis;
/**
* Execute the job.
*
* @return void
*/
public function handle()
{
Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {
info('Lock obtained...');
// Handle job...
}, function () {
// Could not obtain lock...
return $this->release(5);
});
}

While this code is valid, the implementation of the handle method becomes noisy since it is cluttered with Redis rate
limiting logic. In addition, this rate limiting logic must be duplicated for any other jobs that we want to rate limit.
Instead of rate limiting in the handle method, we could define a job middleware that handles rate limiting. Laravel does not
have a default location for job middleware, so you are welcome to place job middleware anywhere in your application. In
this example, we will place the middleware in an app/Jobs/Middleware directory:

Page 615 of 1307

Laravel 9.x

<?php
namespace App\Jobs\Middleware;
use Illuminate\Support\Facades\Redis;
class RateLimited
{
/**
* Process the queued job.
*
* @param

mixed

$job

* @param

callable

$next

* @return mixed
*/
public function handle($job, $next)
{
Redis::throttle('key')
->block(0)->allow(1)->every(5)
->then(function () use ($job, $next) {
// Lock obtained...
$next($job);
}, function () use ($job) {
// Could not obtain lock...
$job->release(5);
});
}
}

As you can see, like route middleware, job middleware receive the job being processed and a callback that should be
invoked to continue processing the job.
After creating job middleware, they may be attached to a job by returning them from the job's middleware method. This
method does not exist on jobs scaffolded by the make:job Artisan command, so you will need to manually add it to your
job class:
use App\Jobs\Middleware\RateLimited;
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [new RateLimited];
}

Job middleware can also be assigned to queueable event listeners, mailables, and notifications.

Page 616 of 1307

Laravel 9.x

Rate Limiting

Although we just demonstrated how to write your own rate limiting job middleware, Laravel actually includes a rate limiting
middleware that you may utilize to rate limit jobs. Like route rate limiters, job rate limiters are defined using the
RateLimiter facade's for method.
For example, you may wish to allow users to backup their data once per hour while imposing no such limit on premium
customers. To accomplish this, you may define a RateLimiter in the boot method of your AppServiceProvider :
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Facades\RateLimiter;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
RateLimiter::for('backups', function ($job) {
return $job->user->vipCustomer()
? Limit::none()
: Limit::perHour(1)->by($job->user->id);
});
}

In the example above, we defined an hourly rate limit; however, you may easily define a rate limit based on minutes using
the perMinute method. In addition, you may pass any value you wish to the by method of the rate limit; however, this
value is most often used to segment rate limits by customer:
return Limit::perMinute(50)->by($job->user->id);

Once you have defined your rate limit, you may attach the rate limiter to your backup job using the
Illuminate\Queue\Middleware\RateLimited middleware. Each time the job exceeds the rate limit, this middleware
will release the job back to the queue with an appropriate delay based on the rate limit duration.
use Illuminate\Queue\Middleware\RateLimited;
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [new RateLimited('backups')];
}

Releasing a rate limited job back onto the queue will still increment the job's total number of attempts . You may wish to
tune your tries and maxExceptions properties on your job class accordingly. Or, you may wish to use the
retryUntil method to define the amount of time until the job should no longer be attempted.
If you do not want a job to be retried when it is rate limited, you may use the dontRelease method:

Page 617 of 1307

Laravel 9.x

/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [(new RateLimited('backups'))->dontRelease()];
}

If you are using Redis, you may use the

middleware, which is fine-tuned for
Redis and more efficient than the basic rate limiting middleware.
Illuminate\Queue\Middleware\RateLimitedWithRedis

Preventing Job Overlaps

Laravel includes an Illuminate\Queue\Middleware\WithoutOverlapping middleware that allows you to prevent job
overlaps based on an arbitrary key. This can be helpful when a queued job is modifying a resource that should only be
modified by one job at a time.
For example, let's imagine you have a queued job that updates a user's credit score and you want to prevent credit score
update job overlaps for the same user ID. To accomplish this, you can return the WithoutOverlapping middleware from
your job's middleware method:
use Illuminate\Queue\Middleware\WithoutOverlapping;
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [new WithoutOverlapping($this->user->id)];
}

Any overlapping jobs of the same type will be released back to the queue. You may also specify the number of seconds
that must elapse before the released job will be attempted again:
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];
}

If you wish to immediately delete any overlapping jobs so that they will not be retried, you may use the dontRelease
method:
Page 618 of 1307

Laravel 9.x

/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [(new WithoutOverlapping($this->order->id))->dontRelease()];
}

The WithoutOverlapping middleware is powered by Laravel's atomic lock feature. Sometimes, your job may
unexpectedly fail or timeout in such a way that the lock is not released. Therefore, you may explicitly define a lock
expiration time using the expireAfter method. For example, the example below will instruct Laravel to release the
WithoutOverlapping lock three minutes after the job has started processing:
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];
}

The WithoutOverlapping middleware requires a cache driver that supports locks. Currently, the
memcached , redis , dynamodb , database , file , and array cache drivers support
atomic locks.
Sharing Lock Keys Across Job Classes
By default, the WithoutOverlapping middleware will only prevent overlapping jobs of the same class. So, although two
different job classes may use the same lock key, they will not be prevented from overlapping. However, you can instruct
Laravel to apply the key across job classes using the shared method:

Page 619 of 1307

Laravel 9.x

use Illuminate\Queue\Middleware\WithoutOverlapping;
class ProviderIsDown
{
// ...

public function middleware()
{
return [
(new WithoutOverlapping("status:{$this->provider}"))->shared(),
];
}
}
class ProviderIsUp
{
// ...

public function middleware()
{
return [
(new WithoutOverlapping("status:{$this->provider}"))->shared(),
];
}
}

Throttling Exceptions

Laravel includes a Illuminate\Queue\Middleware\ThrottlesExceptions middleware that allows you to throttle
exceptions. Once the job throws a given number of exceptions, all further attempts to execute the job are delayed until a
specified time interval lapses. This middleware is particularly useful for jobs that interact with third-party services that are
unstable.
For example, let's imagine a queued job that interacts with a third-party API that begins throwing exceptions. To throttle
exceptions, you can return the ThrottlesExceptions middleware from your job's middleware method. Typically, this
middleware should be paired with a job that implements time based attempts:

Page 620 of 1307

Laravel 9.x

use Illuminate\Queue\Middleware\ThrottlesExceptions;
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [new ThrottlesExceptions(10, 5)];
}
/**
* Determine the time at which the job should timeout.
*
* @return \DateTime
*/
public function retryUntil()
{
return now()->addMinutes(5);
}

The first constructor argument accepted by the middleware is the number of exceptions the job can throw before being
throttled, while the second constructor argument is the number of minutes that should elapse before the job is attempted
again once it has been throttled. In the code example above, if the job throws 10 exceptions within 5 minutes, we will wait 5
minutes before attempting the job again.
When a job throws an exception but the exception threshold has not yet been reached, the job will typically be retried
immediately. However, you may specify the number of minutes such a job should be delayed by calling the backoff
method when attaching the middleware to the job:
use Illuminate\Queue\Middleware\ThrottlesExceptions;
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [(new ThrottlesExceptions(10, 5))->backoff(5)];
}

Internally, this middleware uses Laravel's cache system to implement rate limiting, and the job's class name is utilized as
the cache "key". You may override this key by calling the by method when attaching the middleware to your job. This may
be useful if you have multiple jobs interacting with the same third-party service and you would like them to share a
common throttling "bucket":

Page 621 of 1307

Laravel 9.x

use Illuminate\Queue\Middleware\ThrottlesExceptions;
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [(new ThrottlesExceptions(10, 10))->by('key')];
}

If you are using Redis, you may use the

Illuminate\Queue\Middleware\ThrottlesExceptionsWithRedis middleware, which is finetuned for Redis and more efficient than the basic exception throttling middleware.

Dispatching Jobs

Once you have written your job class, you may dispatch it using the dispatch method on the job itself. The arguments
passed to the dispatch method will be given to the job's constructor:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;
class PodcastController extends Controller
{
/**
* Store a new podcast.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$podcast = Podcast::create(/* ... */);
// ...
ProcessPodcast::dispatch($podcast);
}
}

If you would like to conditionally dispatch a job, you may use the dispatchIf and dispatchUnless methods:

Page 622 of 1307

Laravel 9.x

ProcessPodcast::dispatchIf($accountActive, $podcast);
ProcessPodcast::dispatchUnless($accountSuspended, $podcast);

In new Laravel applications, the sync driver is the default queue driver. This driver executes jobs synchronously in the
foreground of the current request, which is often convenient during local development. If you would like to actually begin
queueing jobs for background processing, you may specify a different queue driver within your application's
config/queue.php configuration file.

Delayed Dispatching

If you would like to specify that a job should not be immediately available for processing by a queue worker, you may use
the delay method when dispatching the job. For example, let's specify that a job should not be available for processing
until 10 minutes after it has been dispatched:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;
class PodcastController extends Controller
{
/**
* Store a new podcast.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$podcast = Podcast::create(/* ... */);
// ...
ProcessPodcast::dispatch($podcast)
->delay(now()->addMinutes(10));
}
}

The Amazon SQS queue service has a maximum delay time of 15 minutes.
Dispatching After The Response Is Sent To Browser
Alternatively, the dispatchAfterResponse method delays dispatching a job until after the HTTP response is sent to the
user's browser if your web server is using FastCGI. This will still allow the user to begin using the application even though a
queued job is still executing. This should typically only be used for jobs that take about a second, such as sending an
email. Since they are processed within the current HTTP request, jobs dispatched in this fashion do not require a queue
worker to be running in order for them to be processed:
Page 623 of 1307

Laravel 9.x

use App\Jobs\SendNotification;
SendNotification::dispatchAfterResponse();

You may also dispatch a closure and chain the afterResponse method onto the dispatch helper to execute a
closure after the HTTP response has been sent to the browser:
use App\Mail\WelcomeMessage;
use Illuminate\Support\Facades\Mail;
dispatch(function () {
Mail::to('taylor@example.com')->send(new WelcomeMessage);
})->afterResponse();

Synchronous Dispatching

If you would like to dispatch a job immediately (synchronously), you may use the dispatchSync method. When using this
method, the job will not be queued and will be executed immediately within the current process:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;
class PodcastController extends Controller
{
/**
* Store a new podcast.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$podcast = Podcast::create(/* ... */);
// Create podcast...
ProcessPodcast::dispatchSync($podcast);
}
}

Jobs & Database Transactions

While it is perfectly fine to dispatch jobs within database transactions, you should take special care to ensure that your job
will actually be able to execute successfully. When dispatching a job within a transaction, it is possible that the job will be
processed by a worker before the parent transaction has committed. When this happens, any updates you have made to
models or database records during the database transaction(s) may not yet be reflected in the database. In addition, any
models or database records created within the transaction(s) may not exist in the database.

Page 624 of 1307

Laravel 9.x

Thankfully, Laravel provides several methods of working around this problem. First, you may set the after_commit
connection option in your queue connection's configuration array:
'redis' => [
'driver' => 'redis',
// ...
'after_commit' => true,
],

When the after_commit option is true , you may dispatch jobs within database transactions; however, Laravel will wait
until the open parent database transactions have been committed before actually dispatching the job. Of course, if no
database transactions are currently open, the job will be dispatched immediately.
If a transaction is rolled back due to an exception that occurs during the transaction, the jobs that were dispatched during
that transaction will be discarded.
Setting the after_commit configuration option to true will also cause any queued event
listeners, mailables, notifications, and broadcast events to be dispatched after all open database
transactions have been committed.
Specifying Commit Dispatch Behavior Inline
If you do not set the after_commit queue connection configuration option to true , you may still indicate that a
specific job should be dispatched after all open database transactions have been committed. To accomplish this, you may
chain the afterCommit method onto your dispatch operation:
use App\Jobs\ProcessPodcast;
ProcessPodcast::dispatch($podcast)->afterCommit();

Likewise, if the after_commit configuration option is set to true , you may indicate that a specific job should be
dispatched immediately without waiting for any open database transactions to commit:
ProcessPodcast::dispatch($podcast)->beforeCommit();

Job Chaining

Job chaining allows you to specify a list of queued jobs that should be run in sequence after the primary job has executed
successfully. If one job in the sequence fails, the rest of the jobs will not be run. To execute a queued job chain, you may
use the chain method provided by the Bus facade. Laravel's command bus is a lower level component that queued job
dispatching is built on top of:

Page 625 of 1307

Laravel 9.x

use App\Jobs\OptimizePodcast;
use App\Jobs\ProcessPodcast;
use App\Jobs\ReleasePodcast;
use Illuminate\Support\Facades\Bus;
Bus::chain([
new ProcessPodcast,
new OptimizePodcast,
new ReleasePodcast,
])->dispatch();

In addition to chaining job class instances, you may also chain closures:
Bus::chain([
new ProcessPodcast,
new OptimizePodcast,
function () {
Podcast::update(/* ... */);
},
])->dispatch();

Deleting jobs using the $this->delete() method within the job will not prevent chained jobs
from being processed. The chain will only stop executing if a job in the chain fails.
Chain Connection & Queue
If you would like to specify the connection and queue that should be used for the chained jobs, you may use the
onConnection and onQueue methods. These methods specify the queue connection and queue name that should be
used unless the queued job is explicitly assigned a different connection / queue:
Bus::chain([
new ProcessPodcast,
new OptimizePodcast,
new ReleasePodcast,
])->onConnection('redis')->onQueue('podcasts')->dispatch();

Chain Failures
When chaining jobs, you may use the catch method to specify a closure that should be invoked if a job within the chain
fails. The given callback will receive the Throwable instance that caused the job failure:

Page 626 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Bus;
use Throwable;
Bus::chain([
new ProcessPodcast,
new OptimizePodcast,
new ReleasePodcast,
])->catch(function (Throwable $e) {
// A job within the chain has failed...
})->dispatch();

Since chain callbacks are serialized and executed at a later time by the Laravel queue, you should
not use the $this variable within chain callbacks.

Customizing The Queue & Connection

Dispatching To A Particular Queue
By pushing jobs to different queues, you may "categorize" your queued jobs and even prioritize how many workers you
assign to various queues. Keep in mind, this does not push jobs to different queue "connections" as defined by your queue
configuration file, but only to specific queues within a single connection. To specify the queue, use the onQueue method
when dispatching the job:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;
class PodcastController extends Controller
{
/**
* Store a new podcast.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$podcast = Podcast::create(/* ... */);
// Create podcast...
ProcessPodcast::dispatch($podcast)->onQueue('processing');
}
}

Alternatively, you may specify the job's queue by calling the onQueue method within the job's constructor:

Page 627 of 1307

Laravel 9.x

<?php
namespace App\Jobs;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
class ProcessPodcast implements ShouldQueue
{
use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
/**
* Create a new job instance.
*
* @return void
*/
public function __construct()
{
$this->onQueue('processing');
}
}

Dispatching To A Particular Connection
If your application interacts with multiple queue connections, you may specify which connection to push a job to using the
onConnection method:

Page 628 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;
class PodcastController extends Controller
{
/**
* Store a new podcast.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
$podcast = Podcast::create(/* ... */);
// Create podcast...
ProcessPodcast::dispatch($podcast)->onConnection('sqs');
}
}

You may chain the onConnection and onQueue methods together to specify the connection and the queue for a job:
ProcessPodcast::dispatch($podcast)
->onConnection('sqs')
->onQueue('processing');

Alternatively, you may specify the job's connection by calling the onConnection method within the job's constructor:

Page 629 of 1307

Laravel 9.x

<?php
namespace App\Jobs;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
class ProcessPodcast implements ShouldQueue
{
use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
/**
* Create a new job instance.
*
* @return void
*/
public function __construct()
{
$this->onConnection('sqs');
}
}

Specifying Max Job Attempts / Timeout Values

Max Attempts
If one of your queued jobs is encountering an error, you likely do not want it to keep retrying indefinitely. Therefore, Laravel
provides various ways to specify how many times or for how long a job may be attempted.
One approach to specifying the maximum number of times a job may be attempted is via the --tries switch on the
Artisan command line. This will apply to all jobs processed by the worker unless the job being processed specifies the
number of times it may be attempted:
php artisan queue:work --tries=3

If a job exceeds its maximum number of attempts, it will be considered a "failed" job. For more information on handling
failed jobs, consult the failed job documentation. If --tries=0 is provided to the queue:work command, the job will be
retried indefinitely.
You may take a more granular approach by defining the maximum number of times a job may be attempted on the job class
itself. If the maximum number of attempts is specified on the job, it will take precedence over the --tries value provided
on the command line:

Page 630 of 1307

Laravel 9.x

<?php
namespace App\Jobs;
class ProcessPodcast implements ShouldQueue
{
/**
* The number of times the job may be attempted.
*
* @var int
*/
public $tries = 5;
}

Time Based Attempts
As an alternative to defining how many times a job may be attempted before it fails, you may define a time at which the job
should no longer be attempted. This allows a job to be attempted any number of times within a given time frame. To define
the time at which a job should no longer be attempted, add a retryUntil method to your job class. This method should
return a DateTime instance:
/**
* Determine the time at which the job should timeout.
*
* @return \DateTime
*/
public function retryUntil()
{
return now()->addMinutes(10);
}

You may also define a tries property or retryUntil method on your queued event listeners.
Max Exceptions
Sometimes you may wish to specify that a job may be attempted many times, but should fail if the retries are triggered by a
given number of unhandled exceptions (as opposed to being released by the release method directly). To accomplish
this, you may define a maxExceptions property on your job class:

Page 631 of 1307

Laravel 9.x

<?php
namespace App\Jobs;
use Illuminate\Support\Facades\Redis;
class ProcessPodcast implements ShouldQueue
{
/**
* The number of times the job may be attempted.
*
* @var int
*/
public $tries = 25;
/**
* The maximum number of unhandled exceptions to allow before failing.
*
* @var int
*/
public $maxExceptions = 3;
/**
* Execute the job.
*
* @return void
*/
public function handle()
{
Redis::throttle('key')->allow(10)->every(60)->then(function () {
// Lock obtained, process the podcast...
}, function () {
// Unable to obtain lock...
return $this->release(10);
});
}
}

In this example, the job is released for ten seconds if the application is unable to obtain a Redis lock and will continue to be
retried up to 25 times. However, the job will fail if three unhandled exceptions are thrown by the job.
Timeout
The pcntl PHP extension must be installed in order to specify job timeouts.
Often, you know roughly how long you expect your queued jobs to take. For this reason, Laravel allows you to specify a
"timeout" value. By default, the timeout value is 60 seconds. If a job is processing for longer than the number of seconds
specified by the timeout value, the worker processing the job will exit with an error. Typically, the worker will be restarted
automatically by a process manager configured on your server.
The maximum number of seconds that jobs can run may be specified using the --timeout switch on the Artisan
command line:
Page 632 of 1307

Laravel 9.x

php artisan queue:work --timeout=30

If the job exceeds its maximum attempts by continually timing out, it will be marked as failed.
You may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is
specified on the job, it will take precedence over any timeout specified on the command line:
<?php
namespace App\Jobs;
class ProcessPodcast implements ShouldQueue
{
/**
* The number of seconds the job can run before timing out.
*
* @var int
*/
public $timeout = 120;
}

Sometimes, IO blocking processes such as sockets or outgoing HTTP connections may not respect your specified timeout.
Therefore, when using these features, you should always attempt to specify a timeout using their APIs as well. For
example, when using Guzzle, you should always specify a connection and request timeout value.
Failing On Timeout
If you would like to indicate that a job should be marked as failed on timeout, you may define the $failOnTimeout
property on the job class:
/**
* Indicate if the job should be marked as failed on timeout.
*
* @var bool
*/
public $failOnTimeout = true;

Error Handling

If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it
may be attempted again. The job will continue to be released until it has been attempted the maximum number of times
allowed by your application. The maximum number of attempts is defined by the --tries switch used on the
queue:work Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself.
More information on running the queue worker can be found below.
Manually Releasing A Job
Sometimes you may wish to manually release a job back onto the queue so that it can be attempted again at a later time.
You may accomplish this by calling the release method:

Page 633 of 1307

Laravel 9.x

/**
* Execute the job.
*
* @return void
*/
public function handle()
{
// ...
$this->release();
}

By default, the release method will release the job back onto the queue for immediate processing. However, by passing
an integer to the release method you may instruct the queue to not make the job available for processing until a given
number of seconds has elapsed:
$this->release(10);

Manually Failing A Job
Occasionally you may need to manually mark a job as "failed". To do so, you may call the fail method:
/**
* Execute the job.
*
* @return void
*/
public function handle()
{
// ...
$this->fail();
}

If you would like to mark your job as failed because of an exception that you have caught, you may pass the exception to
the fail method. Or, for convenience, you may pass a string error message which will be converted to an exception for
you:
$this->fail($exception);
$this->fail('Something went wrong.');

For more information on failed jobs, check out the documentation on dealing with job failures.

Job Batching

Laravel's job batching feature allows you to easily execute a batch of jobs and then perform some action when the batch of
jobs has completed executing. Before getting started, you should create a database migration to build a table to contain
meta information about your job batches, such as their completion percentage. This migration may be generated using the
queue:batches-table Artisan command:
Page 634 of 1307

Laravel 9.x

php artisan queue:batches-table
php artisan migrate

Defining Batchable Jobs

To define a batchable job, you should create a queueable job as normal; however, you should add the
Illuminate\Bus\Batchable trait to the job class. This trait provides access to a batch method which may be used to
retrieve the current batch that the job is executing within:
<?php
namespace App\Jobs;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
class ImportCsv implements ShouldQueue
{
use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
/**
* Execute the job.
*
* @return void
*/
public function handle()
{
if ($this->batch()->cancelled()) {
// Determine if the batch has been cancelled...
return;
}
// Import a portion of the CSV file...
}
}

Dispatching Batches

To dispatch a batch of jobs, you should use the batch method of the Bus facade. Of course, batching is primarily
useful when combined with completion callbacks. So, you may use the then , catch , and finally methods to define
completion callbacks for the batch. Each of these callbacks will receive an Illuminate\Bus\Batch instance when they
are invoked. In this example, we will imagine we are queueing a batch of jobs that each process a given number of rows
from a CSV file:

Page 635 of 1307

Laravel 9.x

use App\Jobs\ImportCsv;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
use Throwable;
$batch = Bus::batch([
new ImportCsv(1, 100),
new ImportCsv(101, 200),
new ImportCsv(201, 300),
new ImportCsv(301, 400),
new ImportCsv(401, 500),
])->then(function (Batch $batch) {
// All jobs completed successfully...
})->catch(function (Batch $batch, Throwable $e) {
// First batch job failure detected...
})->finally(function (Batch $batch) {
// The batch has finished executing...
})->dispatch();
return $batch->id;

The batch's ID, which may be accessed via the $batch->id property, may be used to query the Laravel command bus for
information about the batch after it has been dispatched.
Since batch callbacks are serialized and executed at a later time by the Laravel queue, you should
not use the $this variable within the callbacks.
Naming Batches
Some tools such as Laravel Horizon and Laravel Telescope may provide more user-friendly debug information for batches if
batches are named. To assign an arbitrary name to a batch, you may call the name method while defining the batch:
$batch = Bus::batch([
// ...
])->then(function (Batch $batch) {
// All jobs completed successfully...
})->name('Import CSV')->dispatch();

Batch Connection & Queue
If you would like to specify the connection and queue that should be used for the batched jobs, you may use the
onConnection and onQueue methods. All batched jobs must execute within the same connection and queue:
$batch = Bus::batch([
// ...
])->then(function (Batch $batch) {
// All jobs completed successfully...
})->onConnection('redis')->onQueue('imports')->dispatch();

Chains Within Batches

Page 636 of 1307

Laravel 9.x

You may define a set of chained jobs within a batch by placing the chained jobs within an array. For example, we may
execute two job chains in parallel and execute a callback when both job chains have finished processing:
use App\Jobs\ReleasePodcast;
use App\Jobs\SendPodcastReleaseNotification;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
Bus::batch([
[
new ReleasePodcast(1),
new SendPodcastReleaseNotification(1),
],
[
new ReleasePodcast(2),
new SendPodcastReleaseNotification(2),
],
])->then(function (Batch $batch) {
// ...
})->dispatch();

Adding Jobs To Batches

Sometimes it may be useful to add additional jobs to a batch from within a batched job. This pattern can be useful when
you need to batch thousands of jobs which may take too long to dispatch during a web request. So, instead, you may wish
to dispatch an initial batch of "loader" jobs that hydrate the batch with even more jobs:
$batch = Bus::batch([
new LoadImportBatch,
new LoadImportBatch,
new LoadImportBatch,
])->then(function (Batch $batch) {
// All jobs completed successfully...
})->name('Import Contacts')->dispatch();

In this example, we will use the LoadImportBatch job to hydrate the batch with additional jobs. To accomplish this, we
may use the add method on the batch instance that may be accessed via the job's batch method:

Page 637 of 1307

Laravel 9.x

use App\Jobs\ImportContacts;
use Illuminate\Support\Collection;
/**
* Execute the job.
*
* @return void
*/
public function handle()
{
if ($this->batch()->cancelled()) {
return;
}
$this->batch()->add(Collection::times(1000, function () {
return new ImportContacts;
}));
}

You may only add jobs to a batch from within a job that belongs to the same batch.

Inspecting Batches

The Illuminate\Bus\Batch instance that is provided to batch completion callbacks has a variety of properties and
methods to assist you in interacting with and inspecting a given batch of jobs:

Page 638 of 1307

Laravel 9.x

// The UUID of the batch...
$batch->id;
// The name of the batch (if applicable)...
$batch->name;
// The number of jobs assigned to the batch...
$batch->totalJobs;
// The number of jobs that have not been processed by the queue...
$batch->pendingJobs;
// The number of jobs that have failed...
$batch->failedJobs;
// The number of jobs that have been processed thus far...
$batch->processedJobs();
// The completion percentage of the batch (0-100)...
$batch->progress();
// Indicates if the batch has finished executing...
$batch->finished();
// Cancel the execution of the batch...
$batch->cancel();
// Indicates if the batch has been cancelled...
$batch->cancelled();

Returning Batches From Routes
All Illuminate\Bus\Batch instances are JSON serializable, meaning you can return them directly from one of your
application's routes to retrieve a JSON payload containing information about the batch, including its completion progress.
This makes it convenient to display information about the batch's completion progress in your application's UI.
To retrieve a batch by its ID, you may use the Bus facade's findBatch method:
use Illuminate\Support\Facades\Bus;
use Illuminate\Support\Facades\Route;
Route::get('/batch/{batchId}', function (string $batchId) {
return Bus::findBatch($batchId);
});

Cancelling Batches

Sometimes you may need to cancel a given batch's execution. This can be accomplished by calling the cancel method
on the Illuminate\Bus\Batch instance:

Page 639 of 1307

Laravel 9.x

/**
* Execute the job.
*
* @return void
*/
public function handle()
{
if ($this->user->exceedsImportLimit()) {
return $this->batch()->cancel();
}
if ($this->batch()->cancelled()) {
return;
}
}

As you may have noticed in the previous examples, batched jobs should typically determine if their corresponding batch
has been cancelled before continuing execution. However, for convenience, you may assign the SkipIfBatchCancelled
middleware to the job instead. As its name indicates, this middleware will instruct Laravel to not process the job if its
corresponding batch has been cancelled:
use Illuminate\Queue\Middleware\SkipIfBatchCancelled;
/**
* Get the middleware the job should pass through.
*
* @return array
*/
public function middleware()
{
return [new SkipIfBatchCancelled];
}

Batch Failures

When a batched job fails, the catch callback (if assigned) will be invoked. This callback is only invoked for the first job
that fails within the batch.
Allowing Failures
When a job within a batch fails, Laravel will automatically mark the batch as "cancelled". If you wish, you may disable this
behavior so that a job failure does not automatically mark the batch as cancelled. This may be accomplished by calling the
allowFailures method while dispatching the batch:
$batch = Bus::batch([
// ...
])->then(function (Batch $batch) {
// All jobs completed successfully...
})->allowFailures()->dispatch();

Retrying Failed Batch Jobs
For convenience, Laravel provides a queue:retry-batch Artisan command that allows you to easily retry all of the failed
jobs for a given batch. The queue:retry-batch command accepts the UUID of the batch whose failed jobs should be
retried:
Page 640 of 1307

Laravel 9.x

php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5

Pruning Batches

Without pruning, the job_batches table can accumulate records very quickly. To mitigate this, you should schedule the
queue:prune-batches Artisan command to run daily:
$schedule->command('queue:prune-batches')->daily();

By default, all finished batches that are more than 24 hours old will be pruned. You may use the hours option when
calling the command to determine how long to retain batch data. For example, the following command will delete all
batches that finished over 48 hours ago:
$schedule->command('queue:prune-batches --hours=48')->daily();

Sometimes, your jobs_batches table may accumulate batch records for batches that never completed successfully,
such as batches where a job failed and that job was never retried successfully. You may instruct the queue:prunebatches command to prune these unfinished batch records using the unfinished option:
$schedule->command('queue:prune-batches --hours=48 --unfinished=72')->daily();

Likewise, your jobs_batches table may also accumulate batch records for cancelled batches. You may instruct the
queue:prune-batches command to prune these cancelled batch records using the cancelled option:
$schedule->command('queue:prune-batches --hours=48 --cancelled=72')->daily();

Queueing Closures

Instead of dispatching a job class to the queue, you may also dispatch a closure. This is great for quick, simple tasks that
need to be executed outside of the current request cycle. When dispatching closures to the queue, the closure's code
content is cryptographically signed so that it can not be modified in transit:
$podcast = App\Podcast::find(1);
dispatch(function () use ($podcast) {
$podcast->publish();
});

Using the catch method, you may provide a closure that should be executed if the queued closure fails to complete
successfully after exhausting all of your queue's configured retry attempts:
use Throwable;
dispatch(function () use ($podcast) {
$podcast->publish();
})->catch(function (Throwable $e) {
// This job has failed...
});

Page 641 of 1307

Laravel 9.x

Since catch callbacks are serialized and executed at a later time by the Laravel queue, you
should not use the $this variable within catch callbacks.

Running The Queue Worker
The queue:work Command

Laravel includes an Artisan command that will start a queue worker and process new jobs as they are pushed onto the
queue. You may run the worker using the queue:work Artisan command. Note that once the queue:work command has
started, it will continue to run until it is manually stopped or you close your terminal:
php artisan queue:work

To keep the queue:work process running permanently in the background, you should use a
process monitor such as Supervisor to ensure that the queue worker does not stop running.
You may include the -v flag when invoking the queue:work command if you would like the processed job IDs to be
included in the command's output:
php artisan queue:work -v

Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will
not notice changes in your code base after they have been started. So, during your deployment process, be sure to restart
your queue workers. In addition, remember that any static state created or modified by your application will not be
automatically reset between jobs.
Alternatively, you may run the queue:listen command. When using the queue:listen command, you don't have to
manually restart the worker when you want to reload your updated code or reset the application state; however, this
command is significantly less efficient than the queue:work command:
php artisan queue:listen

Running Multiple Queue Workers
To assign multiple workers to a queue and process jobs concurrently, you should simply start multiple queue:work
processes. This can either be done locally via multiple tabs in your terminal or in production using your process manager's
configuration settings. When using Supervisor, you may use the numprocs configuration value.
Specifying The Connection & Queue
You may also specify which queue connection the worker should utilize. The connection name passed to the work
command should correspond to one of the connections defined in your config/queue.php configuration file:
php artisan queue:work redis

By default, the queue:work command only processes jobs for the default queue on a given connection. However, you
may customize your queue worker even further by only processing particular queues for a given connection. For example,

Page 642 of 1307

Laravel 9.x

if all of your emails are processed in an emails queue on your redis queue connection, you may issue the following
command to start a worker that only processes that queue:
php artisan queue:work redis --queue=emails

Processing A Specified Number Of Jobs
The --once option may be used to instruct the worker to only process a single job from the queue:
php artisan queue:work --once

The --max-jobs option may be used to instruct the worker to process the given number of jobs and then exit. This
option may be useful when combined with Supervisor so that your workers are automatically restarted after processing a
given number of jobs, releasing any memory they may have accumulated:
php artisan queue:work --max-jobs=1000

Processing All Queued Jobs & Then Exiting
The --stop-when-empty option may be used to instruct the worker to process all jobs and then exit gracefully. This
option can be useful when processing Laravel queues within a Docker container if you wish to shutdown the container after
the queue is empty:
php artisan queue:work --stop-when-empty

Processing Jobs For A Given Number Of Seconds
The --max-time option may be used to instruct the worker to process jobs for the given number of seconds and then
exit. This option may be useful when combined with Supervisor so that your workers are automatically restarted after
processing jobs for a given amount of time, releasing any memory they may have accumulated:
# Process jobs for one hour and then exit...
php artisan queue:work --max-time=3600

Worker Sleep Duration
When jobs are available on the queue, the worker will keep processing jobs with no delay in between jobs. However, the
sleep option determines how many seconds the worker will "sleep" if there are no jobs available. Of course, while
sleeping, the worker will not process any new jobs:
php artisan queue:work --sleep=3

Resource Considerations
Daemon queue workers do not "reboot" the framework before processing each job. Therefore, you should release any
heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you
should free the memory with imagedestroy when you are done processing the image.

Queue Priorities

Sometimes you may wish to prioritize how your queues are processed. For example, in your config/queue.php
configuration file, you may set the default queue for your redis connection to low . However, occasionally you may
wish to push a job to a high priority queue like so:

Page 643 of 1307

Laravel 9.x

dispatch((new Job)->onQueue('high'));

To start a worker that verifies that all of the high queue jobs are processed before continuing to any jobs on the low
queue, pass a comma-delimited list of queue names to the work command:
php artisan queue:work --queue=high,low

Queue Workers & Deployment

Since queue workers are long-lived processes, they will not notice changes to your code without being restarted. So, the
simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You
may gracefully restart all of the workers by issuing the queue:restart command:
php artisan queue:restart

This command will instruct all queue workers to gracefully exit after they finish processing their current job so that no
existing jobs are lost. Since the queue workers will exit when the queue:restart command is executed, you should be
running a process manager such as Supervisor to automatically restart the queue workers.
The queue uses the cache to store restart signals, so you should verify that a cache driver is
properly configured for your application before using this feature.

Job Expirations & Timeouts

Job Expiration
In your config/queue.php configuration file, each queue connection defines a retry_after option. This option
specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example,
if the value of retry_after is set to 90 , the job will be released back onto the queue if it has been processing for 90
seconds without being released or deleted. Typically, you should set the retry_after value to the maximum number of
seconds your jobs should reasonably take to complete processing.
The only queue connection which does not contain a retry_after value is Amazon SQS. SQS will
retry the job based on the Default Visibility Timeout which is managed within the AWS console.
Worker Timeouts
The queue:work Artisan command exposes a --timeout option. By default, the --timeout value is 60 seconds. If a
job is processing for longer than the number of seconds specified by the timeout value, the worker processing the job will
exit with an error. Typically, the worker will be restarted automatically by a process manager configured on your server:
php artisan queue:work --timeout=60

The retry_after configuration option and the --timeout CLI option are different, but work together to ensure that
jobs are not lost and that jobs are only successfully processed once.

Page 644 of 1307

Laravel 9.x

The --timeout value should always be at least several seconds shorter than your retry_after
configuration value. This will ensure that a worker processing a frozen job is always terminated
before the job is retried. If your --timeout option is longer than your retry_after
configuration value, your jobs may be processed twice.

Supervisor Configuration

In production, you need a way to keep your queue:work processes running. A queue:work process may stop running
for a variety of reasons, such as an exceeded worker timeout or the execution of the queue:restart command.
For this reason, you need to configure a process monitor that can detect when your queue:work processes exit and
automatically restart them. In addition, process monitors can allow you to specify how many queue:work processes you
would like to run concurrently. Supervisor is a process monitor commonly used in Linux environments and we will discuss
how to configure it in the following documentation.
Installing Supervisor
Supervisor is a process monitor for the Linux operating system, and will automatically restart your queue:work
processes if they fail. To install Supervisor on Ubuntu, you may use the following command:
sudo apt-get install supervisor

If configuring and managing Supervisor yourself sounds overwhelming, consider using Laravel
Forge, which will automatically install and configure Supervisor for your production Laravel
projects.
Configuring Supervisor
Supervisor configuration files are typically stored in the /etc/supervisor/conf.d directory. Within this directory, you
may create any number of configuration files that instruct supervisor how your processes should be monitored. For
example, let's create a laravel-worker.conf file that starts and monitors queue:work processes:
[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=forge
numprocs=8
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log
stopwaitsecs=3600

In this example, the numprocs directive will instruct Supervisor to run eight queue:work processes and monitor all of
them, automatically restarting them if they fail. You should change the command directive of the configuration to reflect
your desired queue connection and worker options.
Page 645 of 1307

Laravel 9.x

You should ensure that the value of stopwaitsecs is greater than the number of seconds
consumed by your longest running job. Otherwise, Supervisor may kill the job before it is finished
processing.
Starting Supervisor
Once the configuration file has been created, you may update the Supervisor configuration and start the processes using
the following commands:
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start laravel-worker:*

For more information on Supervisor, consult the Supervisor documentation.

Dealing With Failed Jobs

Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to
specify the maximum number of times a job should be attempted. After an asynchronous job has exceeded this number of
attempts, it will be inserted into the failed_jobs database table. Synchronously dispatched jobs that fail are not stored
in this table and their exceptions are immediately handled by the application.
A migration to create the failed_jobs table is typically already present in new Laravel applications. However, if your
application does not contain a migration for this table, you may use the queue:failed-table command to create the
migration:
php artisan queue:failed-table
php artisan migrate

When running a queue worker process, you may specify the maximum number of times a job should be attempted using
the --tries switch on the queue:work command. If you do not specify a value for the --tries option, jobs will only
be attempted once or as many times as specified by the job class' $tries property:
php artisan queue:work redis --tries=3

Using the --backoff option, you may specify how many seconds Laravel should wait before retrying a job that has
encountered an exception. By default, a job is immediately released back onto the queue so that it may be attempted
again:
php artisan queue:work redis --tries=3 --backoff=3

If you would like to configure how many seconds Laravel should wait before retrying a job that has encountered an
exception on a per-job basis, you may do so by defining a backoff property on your job class:

Page 646 of 1307

Laravel 9.x

/**
* The number of seconds to wait before retrying the job.
*
* @var int
*/
public $backoff = 3;

If you require more complex logic for determining the job's backoff time, you may define a backoff method on your job
class:
/**
* Calculate the number of seconds to wait before retrying the job.
*
* @return int
*/
public function backoff()
{
return 3;
}

You may easily configure "exponential" backoffs by returning an array of backoff values from the backoff method. In this
example, the retry delay will be 1 second for the first retry, 5 seconds for the second retry, and 10 seconds for the third
retry:
/**
* Calculate the number of seconds to wait before retrying the job.
*
* @return array
*/
public function backoff()
{
return [1, 5, 10];
}

Cleaning Up After Failed Jobs

When a particular job fails, you may want to send an alert to your users or revert any actions that were partially completed
by the job. To accomplish this, you may define a failed method on your job class. The Throwable instance that
caused the job to fail will be passed to the failed method:

Page 647 of 1307

Laravel 9.x

<?php
namespace App\Jobs;
use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Throwable;
class ProcessPodcast implements ShouldQueue
{
use InteractsWithQueue, Queueable, SerializesModels;
/**
* The podcast instance.
*
* @var \App\Podcast
*/
public $podcast;
/**
* Create a new job instance.
*
* @param

\App\Models\Podcast

$podcast

* @return void
*/
public function __construct(Podcast $podcast)
{
$this->podcast = $podcast;
}
/**
* Execute the job.
*
* @param

\App\Services\AudioProcessor

$processor

* @return void
*/
public function handle(AudioProcessor $processor)
{
// Process uploaded podcast...
}
/**
* Handle a job failure.
*
* @param

\Throwable

$exception

* @return void
*/
public function failed(Throwable $exception)
{
// Send user notification of failure, etc...

Page 648 of 1307

Laravel 9.x

}
}

A new instance of the job is instantiated before invoking the failed method; therefore, any class
property modifications that may have occurred within the handle method will be lost.

Retrying Failed Jobs

To view all of the failed jobs that have been inserted into your failed_jobs database table, you may use the
queue:failed Artisan command:
php artisan queue:failed

The queue:failed command will list the job ID, connection, queue, failure time, and other information about the job. The
job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of ce7bb17c-cdd8-41f0-a8ec7b4fef4e5ece , issue the following command:
php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece

If necessary, you may pass multiple IDs to the command:
php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c34f94a33c24d

You may also retry all of the failed jobs for a particular queue:
php artisan queue:retry --queue=name

To retry all of your failed jobs, execute the queue:retry command and pass all as the ID:
php artisan queue:retry all

If you would like to delete a failed job, you may use the queue:forget command:
php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d

When using Horizon, you should use the horizon:forget command to delete a failed job instead
of the queue:forget command.
To delete all of your failed jobs from the failed_jobs table, you may use the queue:flush command:
php artisan queue:flush

Ignoring Missing Models
Page 649 of 1307

Laravel 9.x

When injecting an Eloquent model into a job, the model is automatically serialized before being placed on the queue and
re-retrieved from the database when the job is processed. However, if the model has been deleted while the job was
waiting to be processed by a worker, your job may fail with a ModelNotFoundException .
For convenience, you may choose to automatically delete jobs with missing models by setting your job's
deleteWhenMissingModels property to true . When this property is set to true , Laravel will quietly discard the job
without raising an exception:
/**
* Delete the job if its models no longer exist.
*
* @var bool
*/
public $deleteWhenMissingModels = true;

Pruning Failed Jobs

You may prune the records in your application's failed_jobs table by invoking the queue:prune-failed Artisan
command:
php artisan queue:prune-failed

By default, all the failed job records that are more than 24 hours old will be pruned. If you provide the --hours option to
the command, only the failed job records that were inserted within the last N number of hours will be retained. For
example, the following command will delete all the failed job records that were inserted more than 48 hours ago:
php artisan queue:prune-failed --hours=48

Storing Failed Jobs In DynamoDB

Laravel also provides support for storing your failed job records in DynamoDB instead of a relational database table.
However, you must create a DynamoDB table to store all of the failed job records. Typically, this table should be named
failed_jobs , but you should name the table based on the value of the queue.failed.table configuration value
within your application's queue configuration file.
The failed_jobs table should have a string primary partition key named application and a string primary sort key
named uuid . The application portion of the key will contain your application's name as defined by the name
configuration value within your application's app configuration file. Since the application name is part of the DynamoDB
table's key, you can use the same table to store failed jobs for multiple Laravel applications.
In addition, ensure that you install the AWS SDK so that your Laravel application can communicate with Amazon
DynamoDB:
composer require aws/aws-sdk-php

Next, set the queue.failed.driver configuration option's value to dynamodb . In addition, you should define key ,
secret , and region configuration options within the failed job configuration array. These options will be used to
authenticate with AWS. When using the dynamodb driver, the queue.failed.database configuration option is
unnecessary:

Page 650 of 1307

Laravel 9.x

'failed' => [
'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),
'key' => env('AWS_ACCESS_KEY_ID'),
'secret' => env('AWS_SECRET_ACCESS_KEY'),
'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
'table' => 'failed_jobs',
],

Disabling Failed Job Storage

You may instruct Laravel to discard failed jobs without storing them by setting the queue.failed.driver configuration
option's value to null . Typically, this may be accomplished via the QUEUE_FAILED_DRIVER environment variable:
QUEUE_FAILED_DRIVER=null

Failed Job Events

If you would like to register an event listener that will be invoked when a job fails, you may use the Queue facade's
failing method. For example, we may attach a closure to this event from the boot method of the
AppServiceProvider that is included with Laravel:

Page 651 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobFailed;
class AppServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Queue::failing(function (JobFailed $event) {
// $event->connectionName
// $event->job
// $event->exception
});
}
}

Clearing Jobs From Queues
When using Horizon, you should use the horizon:clear command to clear jobs from the queue
instead of the queue:clear command.
If you would like to delete all jobs from the default queue of the default connection, you may do so using the
queue:clear Artisan command:
php artisan queue:clear

You may also provide the connection argument and queue option to delete jobs from a specific connection and queue:
php artisan queue:clear redis --queue=emails

Page 652 of 1307

Laravel 9.x

Clearing jobs from queues is only available for the SQS, Redis, and database queue drivers. In
addition, the SQS message deletion process takes up to 60 seconds, so jobs sent to the SQS queue
up to 60 seconds after you clear the queue might also be deleted.

Monitoring Your Queues

If your queue receives a sudden influx of jobs, it could become overwhelmed, leading to a long wait time for jobs to
complete. If you wish, Laravel can alert you when your queue job count exceeds a specified threshold.
To get started, you should schedule the queue:monitor command to run every minute. The command accepts the
names of the queues you wish to monitor as well as your desired job count threshold:
php artisan queue:monitor redis:default,redis:deployments --max=100

Scheduling this command alone is not enough to trigger a notification alerting you of the queue's overwhelmed status.
When the command encounters a queue that has a job count exceeding your threshold, an
Illuminate\Queue\Events\QueueBusy event will be dispatched. You may listen for this event within your application's
EventServiceProvider in order to send a notification to you or your development team:
use App\Notifications\QueueHasLongWaitTime;
use Illuminate\Queue\Events\QueueBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;
/**
* Register any other events for your application.
*
* @return void
*/
public function boot()
{
Event::listen(function (QueueBusy $event) {
Notification::route('mail', 'dev@example.com')
->notify(new QueueHasLongWaitTime(
$event->connection,
$event->queue,
$event->size
));
});
}

Job Events

Using the before and after methods on the Queue facade, you may specify callbacks to be executed before or after
a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for
a dashboard. Typically, you should call these methods from the boot method of a service provider. For example, we may
use the AppServiceProvider that is included with Laravel:

Page 653 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobProcessed;
use Illuminate\Queue\Events\JobProcessing;
class AppServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Queue::before(function (JobProcessing $event) {
// $event->connectionName
// $event->job
// $event->job->payload()
});
Queue::after(function (JobProcessed $event) {
// $event->connectionName
// $event->job
// $event->job->payload()
});
}
}

Using the looping method on the Queue facade, you may specify callbacks that execute before the worker attempts to
fetch a job from a queue. For example, you might register a closure to rollback any transactions that were left open by a
previously failed job:
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Queue;
Queue::looping(function () {
while (DB::transactionLevel() > 0) {
DB::rollBack();
}
});

Page 654 of 1307

Laravel 9.x

Rate Limiting

Introduction
Cache Configuration
Basic Usage
Manually Incrementing Attempts
Clearing Attempts

Introduction

Laravel includes a simple to use rate limiting abstraction which, in conjunction with your application's cache, provides an
easy way to limit any action during a specified window of time.
If you are interested in rate limiting incoming HTTP requests, please consult the rate limiter
middleware documentation.

Cache Configuration

Typically, the rate limiter utilizes your default application cache as defined by the default key within your application's
cache configuration file. However, you may specify which cache driver the rate limiter should use by defining a
limiter key within your application's cache configuration file:
'default' => 'memcached',
'limiter' => 'redis',

Basic Usage

The Illuminate\Support\Facades\RateLimiter facade may be used to interact with the rate limiter. The simplest
method offered by the rate limiter is the attempt method, which rate limits a given callback for a given number of
seconds.
The attempt method returns false when the callback has no remaining attempts available; otherwise, the attempt
method will return the callback's result or true . The first argument accepted by the attempt method is a rate limiter
"key", which may be any string of your choosing that represents the action being rate limited:
use Illuminate\Support\Facades\RateLimiter;
$executed = RateLimiter::attempt(
'send-message:'.$user->id,
$perMinute = 5,
function() {
// Send message...
}
);
if (! $executed) {
return 'Too many messages sent!';
}

Page 655 of 1307

Laravel 9.x

Manually Incrementing Attempts

If you would like to manually interact with the rate limiter, a variety of other methods are available. For example, you may
invoke the tooManyAttempts method to determine if a given rate limiter key has exceeded its maximum number of
allowed attempts per minute:
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {
return 'Too many attempts!';
}

Alternatively, you may use the remaining method to retrieve the number of attempts remaining for a given key. If a given
key has retries remaining, you may invoke the hit method to increment the number of total attempts:
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::remaining('send-message:'.$user->id, $perMinute = 5)) {
RateLimiter::hit('send-message:'.$user->id);
// Send message...
}

Determining Limiter Availability
When a key has no more attempts left, the availableIn method returns the number of seconds remaining until more
attempts will be available:
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {
$seconds = RateLimiter::availableIn('send-message:'.$user->id);
return 'You may try again in '.$seconds.' seconds.';
}

Clearing Attempts

You may reset the number of attempts for a given rate limiter key using the clear method. For example, you may reset
the number of attempts when a given message is read by the receiver:

Page 656 of 1307

Laravel 9.x

use App\Models\Message;
use Illuminate\Support\Facades\RateLimiter;
/**
* Mark the message as read.
*
* @param

\App\Models\Message

$message

* @return \App\Models\Message
*/
public function read(Message $message)
{
$message->markAsRead();
RateLimiter::clear('send-message:'.$message->user_id);
return $message;
}

Page 657 of 1307

Laravel 9.x

Task Scheduling

Introduction
Defining Schedules
Scheduling Artisan Commands
Scheduling Queued Jobs
Scheduling Shell Commands
Schedule Frequency Options
Timezones
Preventing Task Overlaps
Running Tasks On One Server
Background Tasks
Maintenance Mode
Running The Scheduler
Running The Scheduler Locally
Task Output
Task Hooks
Events

Introduction

In the past, you may have written a cron configuration entry for each task you needed to schedule on your server. However,
this can quickly become a pain because your task schedule is no longer in source control and you must SSH into your
server to view your existing cron entries or add additional entries.
Laravel's command scheduler offers a fresh approach to managing scheduled tasks on your server. The scheduler allows
you to fluently and expressively define your command schedule within your Laravel application itself. When using the
scheduler, only a single cron entry is needed on your server. Your task schedule is defined in the
app/Console/Kernel.php file's schedule method. To help you get started, a simple example is defined within the
method.

Defining Schedules

You may define all of your scheduled tasks in the schedule method of your application's App\Console\Kernel class.
To get started, let's take a look at an example. In this example, we will schedule a closure to be called every day at
midnight. Within the closure we will execute a database query to clear a table:

Page 658 of 1307

Laravel 9.x

<?php
namespace App\Console;
use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;
use Illuminate\Support\Facades\DB;
class Kernel extends ConsoleKernel
{
/**
* Define the application's command schedule.
*
* @param

\Illuminate\Console\Scheduling\Schedule

$schedule

* @return void
*/
protected function schedule(Schedule $schedule)
{
$schedule->call(function () {
DB::table('recent_users')->delete();
})->daily();
}
}

In addition to scheduling using closures, you may also schedule invokable objects. Invokable objects are simple PHP
classes that contain an __invoke method:
$schedule->call(new DeleteRecentUsers)->daily();

If you would like to view an overview of your scheduled tasks and the next time they are scheduled to run, you may use the
schedule:list Artisan command:
php artisan schedule:list

Scheduling Artisan Commands

In addition to scheduling closures, you may also schedule Artisan commands and system commands. For example, you
may use the command method to schedule an Artisan command using either the command's name or class.
When scheduling Artisan commands using the command's class name, you may pass an array of additional command-line
arguments that should be provided to the command when it is invoked:
use App\Console\Commands\SendEmailsCommand;
$schedule->command('emails:send Taylor --force')->daily();
$schedule->command(SendEmailsCommand::class, ['Taylor', '--force'])->daily();

Scheduling Queued Jobs

The job method may be used to schedule a queued job. This method provides a convenient way to schedule queued jobs
without using the call method to define closures to queue the job:

Page 659 of 1307

Laravel 9.x

use App\Jobs\Heartbeat;
$schedule->job(new Heartbeat)->everyFiveMinutes();

Optional second and third arguments may be provided to the job method which specifies the queue name and queue
connection that should be used to queue the job:
use App\Jobs\Heartbeat;
// Dispatch the job to the "heartbeats" queue on the "sqs" connection...
$schedule->job(new Heartbeat, 'heartbeats', 'sqs')->everyFiveMinutes();

Scheduling Shell Commands

The exec method may be used to issue a command to the operating system:
$schedule->exec('node /home/forge/script.js')->daily();

Schedule Frequency Options

We've already seen a few examples of how you may configure a task to run at specified intervals. However, there are many
more task schedule frequencies that you may assign to a task:

Page 660 of 1307

Laravel 9.x

Method
->cron('* * * * *');
->everyMinute();
->everyTwoMinutes();
->everyThreeMinutes();
->everyFourMinutes();
->everyFiveMinutes();
->everyTenMinutes();
->everyFifteenMinutes();
->everyThirtyMinutes();
->hourly();
->hourlyAt(17);
->everyOddHour();
->everyTwoHours();
->everyThreeHours();
->everyFourHours();
->everySixHours();
->daily();
->dailyAt('13:00');
->twiceDaily(1, 13);
->twiceDailyAt(1, 13, 15);
->weekly();
->weeklyOn(1, '8:00');
->monthly();
->monthlyOn(4, '15:00');
->twiceMonthly(1, 16, '13:00');
->lastDayOfMonth('15:00');
->quarterly();
->quarterlyOn(4, '14:00');
->yearly();
->yearlyOn(6, 1, '17:00');
->timezone('America/New_York');

Description
Run the task on a custom cron schedule
Run the task every minute
Run the task every two minutes
Run the task every three minutes
Run the task every four minutes
Run the task every five minutes
Run the task every ten minutes
Run the task every fifteen minutes
Run the task every thirty minutes
Run the task every hour
Run the task every hour at 17 minutes past the hour
Run the task every odd hour
Run the task every two hours
Run the task every three hours
Run the task every four hours
Run the task every six hours
Run the task every day at midnight
Run the task every day at 13:00
Run the task daily at 1:00 & 13:00
Run the task daily at 1:15 & 13:15
Run the task every Sunday at 00:00
Run the task every week on Monday at 8:00
Run the task on the first day of every month at 00:00
Run the task every month on the 4th at 15:00
Run the task monthly on the 1st and 16th at 13:00
Run the task on the last day of the month at 15:00
Run the task on the first day of every quarter at 00:00
Run the task every quarter on the 4th at 14:00
Run the task on the first day of every year at 00:00
Run the task every year on June 1st at 17:00
Set the timezone for the task

Page 661 of 1307

Laravel 9.x

These methods may be combined with additional constraints to create even more finely tuned schedules that only run on
certain days of the week. For example, you may schedule a command to run weekly on Monday:
// Run once per week on Monday at 1 PM...
$schedule->call(function () {
//
})->weekly()->mondays()->at('13:00');
// Run hourly from 8 AM to 5 PM on weekdays...
$schedule->command('foo')
->weekdays()
->hourly()
->timezone('America/Chicago')
->between('8:00', '17:00');

A list of additional schedule constraints may be found below:
Method
->weekdays();
->weekends();
->sundays();
->mondays();
->tuesdays();
->wednesdays();
->thursdays();
->fridays();
->saturdays();
->days(array|mixed);
->between($startTime, $endTime);
->unlessBetween($startTime, $endTime);
->when(Closure);
->environments($env);

Description
Limit the task to weekdays
Limit the task to weekends
Limit the task to Sunday
Limit the task to Monday
Limit the task to Tuesday
Limit the task to Wednesday
Limit the task to Thursday
Limit the task to Friday
Limit the task to Saturday
Limit the task to specific days
Limit the task to run between start and end times
Limit the task to not run between start and end times
Limit the task based on a truth test
Limit the task to specific environments

Day Constraints
The days method may be used to limit the execution of a task to specific days of the week. For example, you may
schedule a command to run hourly on Sundays and Wednesdays:
$schedule->command('emails:send')
->hourly()
->days([0, 3]);

Alternatively, you may use the constants available on the Illuminate\Console\Scheduling\Schedule class when
defining the days on which a task should run:
Page 662 of 1307

Laravel 9.x

use Illuminate\Console\Scheduling\Schedule;
$schedule->command('emails:send')
->hourly()
->days([Schedule::SUNDAY, Schedule::WEDNESDAY]);

Between Time Constraints
The between method may be used to limit the execution of a task based on the time of day:
$schedule->command('emails:send')
->hourly()
->between('7:00', '22:00');

Similarly, the unlessBetween method can be used to exclude the execution of a task for a period of time:
$schedule->command('emails:send')
->hourly()
->unlessBetween('23:00', '4:00');

Truth Test Constraints
The when method may be used to limit the execution of a task based on the result of a given truth test. In other words, if
the given closure returns true , the task will execute as long as no other constraining conditions prevent the task from
running:
$schedule->command('emails:send')->daily()->when(function () {
return true;
});

The skip method may be seen as the inverse of when . If the skip method returns true , the scheduled task will not
be executed:
$schedule->command('emails:send')->daily()->skip(function () {
return true;
});

When using chained when methods, the scheduled command will only execute if all when conditions return true .
Environment Constraints
The environments method may be used to execute tasks only on the given environments (as defined by the APP_ENV
environment variable):
$schedule->command('emails:send')
->daily()
->environments(['staging', 'production']);

Timezones

Using the timezone method, you may specify that a scheduled task's time should be interpreted within a given timezone:

Page 663 of 1307

Laravel 9.x

$schedule->command('report:generate')
->timezone('America/New_York')
->at('2:00')

If you are repeatedly assigning the same timezone to all of your scheduled tasks, you may wish to define a
scheduleTimezone method in your App\Console\Kernel class. This method should return the default timezone that
should be assigned to all scheduled tasks:
/**
* Get the timezone that should be used by default for scheduled events.
*
* @return \DateTimeZone|string|null
*/
protected function scheduleTimezone()
{
return 'America/Chicago';
}

Remember that some timezones utilize daylight savings time. When daylight saving time changes
occur, your scheduled task may run twice or even not run at all. For this reason, we recommend
avoiding timezone scheduling when possible.

Preventing Task Overlaps

By default, scheduled tasks will be run even if the previous instance of the task is still running. To prevent this, you may
use the withoutOverlapping method:
$schedule->command('emails:send')->withoutOverlapping();

In this example, the emails:send Artisan command will be run every minute if it is not already running. The
withoutOverlapping method is especially useful if you have tasks that vary drastically in their execution time,
preventing you from predicting exactly how long a given task will take.
If needed, you may specify how many minutes must pass before the "without overlapping" lock expires. By default, the
lock will expire after 24 hours:
$schedule->command('emails:send')->withoutOverlapping(10);

Behind the scenes, the withoutOverlapping method utilizes your application's cache to obtain locks. If necessary, you
can clear these cache locks using the schedule:clear-cache Artisan command. This is typically only necessary if a
task becomes stuck due to an unexpected server problem.

Running Tasks On One Server
To utilize this feature, your application must be using the database , memcached , dynamodb , or
redis cache driver as your application's default cache driver. In addition, all servers must be
communicating with the same central cache server.

Page 664 of 1307

Laravel 9.x

If your application's scheduler is running on multiple servers, you may limit a scheduled job to only execute on a single
server. For instance, assume you have a scheduled task that generates a new report every Friday night. If the task
scheduler is running on three worker servers, the scheduled task will run on all three servers and generate the report three
times. Not good!
To indicate that the task should run on only one server, use the onOneServer method when defining the scheduled task.
The first server to obtain the task will secure an atomic lock on the job to prevent other servers from running the same task
at the same time:
$schedule->command('report:generate')
->fridays()
->at('17:00')
->onOneServer();

Naming Single Server Jobs
Sometimes you may need to schedule the same job to be dispatched with different parameters, while still instructing
Laravel to run each permutation of the job on a single server. To accomplish this, you may assign each schedule definition
a unique name via the name method:
$schedule->job(new CheckUptime('https://laravel.com'))
->name('check_uptime:laravel.com')
->everyFiveMinutes()
->onOneServer();
$schedule->job(new CheckUptime('https://vapor.laravel.com'))
->name('check_uptime:vapor.laravel.com')
->everyFiveMinutes()
->onOneServer();

Similarly, scheduled closures must be assigned a name if they are intended to be run on one server:
$schedule->call(fn () => User::resetApiRequestCount())
->name('reset-api-request-count')
->daily()
->onOneServer();

Background Tasks

By default, multiple tasks scheduled at the same time will execute sequentially based on the order they are defined in your
schedule method. If you have long-running tasks, this may cause subsequent tasks to start much later than anticipated.
If you would like to run tasks in the background so that they may all run simultaneously, you may use the
runInBackground method:
$schedule->command('analytics:report')
->daily()
->runInBackground();

The runInBackground method may only be used when scheduling tasks via the command and
exec methods.

Page 665 of 1307

Laravel 9.x

Maintenance Mode

Your application's scheduled tasks will not run when the application is in maintenance mode, since we don't want your
tasks to interfere with any unfinished maintenance you may be performing on your server. However, if you would like to
force a task to run even in maintenance mode, you may call the evenInMaintenanceMode method when defining the
task:
$schedule->command('emails:send')->evenInMaintenanceMode();

Running The Scheduler

Now that we have learned how to define scheduled tasks, let's discuss how to actually run them on our server. The
schedule:run Artisan command will evaluate all of your scheduled tasks and determine if they need to run based on the
server's current time.
So, when using Laravel's scheduler, we only need to add a single cron configuration entry to our server that runs the
schedule:run command every minute. If you do not know how to add cron entries to your server, consider using a
service such as Laravel Forge which can manage the cron entries for you:
* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1

Running The Scheduler Locally

Typically, you would not add a scheduler cron entry to your local development machine. Instead, you may use the
schedule:work Artisan command. This command will run in the foreground and invoke the scheduler every minute until
you terminate the command:
php artisan schedule:work

Task Output

The Laravel scheduler provides several convenient methods for working with the output generated by scheduled tasks.
First, using the sendOutputTo method, you may send the output to a file for later inspection:
$schedule->command('emails:send')
->daily()
->sendOutputTo($filePath);

If you would like to append the output to a given file, you may use the appendOutputTo method:
$schedule->command('emails:send')
->daily()
->appendOutputTo($filePath);

Using the emailOutputTo method, you may email the output to an email address of your choice. Before emailing the
output of a task, you should configure Laravel's email services:
$schedule->command('report:generate')
->daily()
->sendOutputTo($filePath)
->emailOutputTo('taylor@example.com');

Page 666 of 1307

Laravel 9.x

If you only want to email the output if the scheduled Artisan or system command terminates with a non-zero exit code, use
the emailOutputOnFailure method:
$schedule->command('report:generate')
->daily()
->emailOutputOnFailure('taylor@example.com');

The emailOutputTo , emailOutputOnFailure , sendOutputTo , and appendOutputTo
methods are exclusive to the command and exec methods.

Task Hooks

Using the before and after methods, you may specify code to be executed before and after the scheduled task is
executed:
$schedule->command('emails:send')
->daily()
->before(function () {
// The task is about to execute...
})
->after(function () {
// The task has executed...
});

The onSuccess and onFailure methods allow you to specify code to be executed if the scheduled task succeeds or
fails. A failure indicates that the scheduled Artisan or system command terminated with a non-zero exit code:
$schedule->command('emails:send')
->daily()
->onSuccess(function () {
// The task succeeded...
})
->onFailure(function () {
// The task failed...
});

If output is available from your command, you may access it in your after , onSuccess or onFailure hooks by typehinting an Illuminate\Support\Stringable instance as the $output argument of your hook's closure definition:
use Illuminate\Support\Stringable;
$schedule->command('emails:send')
->daily()
->onSuccess(function (Stringable $output) {
// The task succeeded...
})
->onFailure(function (Stringable $output) {
// The task failed...
});

Page 667 of 1307

Laravel 9.x

Pinging URLs
Using the pingBefore and thenPing methods, the scheduler can automatically ping a given URL before or after a task
is executed. This method is useful for notifying an external service, such as Envoyer, that your scheduled task is beginning
or has finished execution:
$schedule->command('emails:send')
->daily()
->pingBefore($url)
->thenPing($url);

The pingBeforeIf and thenPingIf methods may be used to ping a given URL only if a given condition is true :
$schedule->command('emails:send')
->daily()
->pingBeforeIf($condition, $url)
->thenPingIf($condition, $url);

The pingOnSuccess and pingOnFailure methods may be used to ping a given URL only if the task succeeds or fails.
A failure indicates that the scheduled Artisan or system command terminated with a non-zero exit code:
$schedule->command('emails:send')
->daily()
->pingOnSuccess($successUrl)
->pingOnFailure($failureUrl);

All of the ping methods require the Guzzle HTTP library. Guzzle is typically installed in all new Laravel projects by default,
but, you may manually install Guzzle into your project using the Composer package manager if it has been accidentally
removed:
composer require guzzlehttp/guzzle

Events

If needed, you may listen to events dispatched by the scheduler. Typically, event listener mappings will be defined within
your application's App\Providers\EventServiceProvider class:

Page 668 of 1307

Laravel 9.x

/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
'Illuminate\Console\Events\ScheduledTaskStarting' => [
'App\Listeners\LogScheduledTaskStarting',
],
'Illuminate\Console\Events\ScheduledTaskFinished' => [
'App\Listeners\LogScheduledTaskFinished',
],
'Illuminate\Console\Events\ScheduledBackgroundTaskFinished' => [
'App\Listeners\LogScheduledBackgroundTaskFinished',
],
'Illuminate\Console\Events\ScheduledTaskSkipped' => [
'App\Listeners\LogScheduledTaskSkipped',
],
'Illuminate\Console\Events\ScheduledTaskFailed' => [
'App\Listeners\LogScheduledTaskFailed',
],
];

Page 669 of 1307

Laravel 9.x

Chapter 6

Security

Page 670 of 1307

Laravel 9.x

Authentication

Introduction
Starter Kits
Database Considerations
Ecosystem Overview
Authentication Quickstart
Install A Starter Kit
Retrieving The Authenticated User
Protecting Routes
Login Throttling
Manually Authenticating Users
Remembering Users
Other Authentication Methods
HTTP Basic Authentication
Stateless HTTP Basic Authentication
Logging Out
Invalidating Sessions On Other Devices
Password Confirmation
Configuration
Routing
Protecting Routes
Adding Custom Guards
Closure Request Guards
Adding Custom User Providers
The User Provider Contract
The Authenticatable Contract
Social Authentication
Events

Introduction

Many web applications provide a way for their users to authenticate with the application and "login". Implementing this
feature in web applications can be a complex and potentially risky endeavor. For this reason, Laravel strives to give you the
tools you need to implement authentication quickly, securely, and easily.
At its core, Laravel's authentication facilities are made up of "guards" and "providers". Guards define how users are
authenticated for each request. For example, Laravel ships with a session guard which maintains state using session
storage and cookies.
Providers define how users are retrieved from your persistent storage. Laravel ships with support for retrieving users using
Eloquent and the database query builder. However, you are free to define additional providers as needed for your
application.
Your application's authentication configuration file is located at config/auth.php . This file contains several welldocumented options for tweaking the behavior of Laravel's authentication services.
Guards and providers should not be confused with "roles" and "permissions". To learn more about
authorizing user actions via permissions, please refer to the authorization documentation.

Page 671 of 1307

Laravel 9.x

Starter Kits

Want to get started fast? Install a Laravel application starter kit in a fresh Laravel application. After migrating your
database, navigate your browser to /register or any other URL that is assigned to your application. The starter kits will
take care of scaffolding your entire authentication system!
Even if you choose not to use a starter kit in your final Laravel application, installing the Laravel Breeze starter kit
can be a wonderful opportunity to learn how to implement all of Laravel's authentication functionality in an actual
Laravel project. Since Laravel Breeze creates authentication controllers, routes, and views for you, you can examine the
code within these files to learn how Laravel's authentication features may be implemented.

Database Considerations

By default, Laravel includes an App\Models\User Eloquent model in your app/Models directory. This model may be
used with the default Eloquent authentication driver. If your application is not using Eloquent, you may use the database
authentication provider which uses the Laravel query builder.
When building the database schema for the App\Models\User model, make sure the password column is at least 60
characters in length. Of course, the users table migration that is included in new Laravel applications already creates a
column that exceeds this length.
Also, you should verify that your users (or equivalent) table contains a nullable, string remember_token column of 100
characters. This column will be used to store a token for users that select the "remember me" option when logging into
your application. Again, the default users table migration that is included in new Laravel applications already contains
this column.

Ecosystem Overview

Laravel offers several packages related to authentication. Before continuing, we'll review the general authentication
ecosystem in Laravel and discuss each package's intended purpose.
First, consider how authentication works. When using a web browser, a user will provide their username and password via a
login form. If these credentials are correct, the application will store information about the authenticated user in the user's
session. A cookie issued to the browser contains the session ID so that subsequent requests to the application can
associate the user with the correct session. After the session cookie is received, the application will retrieve the session
data based on the session ID, note that the authentication information has been stored in the session, and will consider the
user as "authenticated".
When a remote service needs to authenticate to access an API, cookies are not typically used for authentication because
there is no web browser. Instead, the remote service sends an API token to the API on each request. The application may
validate the incoming token against a table of valid API tokens and "authenticate" the request as being performed by the
user associated with that API token.
Laravel's Built-in Browser Authentication Services
Laravel includes built-in authentication and session services which are typically accessed via the Auth and Session
facades. These features provide cookie-based authentication for requests that are initiated from web browsers. They
provide methods that allow you to verify a user's credentials and authenticate the user. In addition, these services will
automatically store the proper authentication data in the user's session and issue the user's session cookie. A discussion
of how to use these services is contained within this documentation.
Application Starter Kits
As discussed in this documentation, you can interact with these authentication services manually to build your
application's own authentication layer. However, to help you get started more quickly, we have released free packages that
provide robust, modern scaffolding of the entire authentication layer. These packages are Laravel Breeze, Laravel
Jetstream, and Laravel Fortify.

Page 672 of 1307

Laravel 9.x

Laravel Breeze is a simple, minimal implementation of all of Laravel's authentication features, including login, registration,
password reset, email verification, and password confirmation. Laravel Breeze's view layer is comprised of simple Blade
templates styled with Tailwind CSS. To get started, check out the documentation on Laravel's application starter kits.
Laravel Fortify is a headless authentication backend for Laravel that implements many of the features found in this
documentation, including cookie-based authentication as well as other features such as two-factor authentication and
email verification. Fortify provides the authentication backend for Laravel Jetstream or may be used independently in
combination with Laravel Sanctum to provide authentication for an SPA that needs to authenticate with Laravel.
Laravel Jetstream is a robust application starter kit that consumes and exposes Laravel Fortify's authentication services
with a beautiful, modern UI powered by Tailwind CSS, Livewire, and / or Inertia. Laravel Jetstream includes optional support
for two-factor authentication, team support, browser session management, profile management, and built-in integration
with Laravel Sanctum to offer API token authentication. Laravel's API authentication offerings are discussed below.
Laravel's API Authentication Services
Laravel provides two optional packages to assist you in managing API tokens and authenticating requests made with API
tokens: Passport and Sanctum. Please note that these libraries and Laravel's built-in cookie based authentication libraries
are not mutually exclusive. These libraries primarily focus on API token authentication while the built-in authentication
services focus on cookie based browser authentication. Many applications will use both Laravel's built-in cookie based
authentication services and one of Laravel's API authentication packages.
Passport
Passport is an OAuth2 authentication provider, offering a variety of OAuth2 "grant types" which allow you to issue various
types of tokens. In general, this is a robust and complex package for API authentication. However, most applications do not
require the complex features offered by the OAuth2 spec, which can be confusing for both users and developers. In
addition, developers have been historically confused about how to authenticate SPA applications or mobile applications
using OAuth2 authentication providers like Passport.
Sanctum
In response to the complexity of OAuth2 and developer confusion, we set out to build a simpler, more streamlined
authentication package that could handle both first-party web requests from a web browser and API requests via tokens.
This goal was realized with the release of Laravel Sanctum, which should be considered the preferred and recommended
authentication package for applications that will be offering a first-party web UI in addition to an API, or will be powered by
a single-page application (SPA) that exists separately from the backend Laravel application, or applications that offer a
mobile client.
Laravel Sanctum is a hybrid web / API authentication package that can manage your application's entire authentication
process. This is possible because when Sanctum based applications receive a request, Sanctum will first determine if the
request includes a session cookie that references an authenticated session. Sanctum accomplishes this by calling
Laravel's built-in authentication services which we discussed earlier. If the request is not being authenticated via a session
cookie, Sanctum will inspect the request for an API token. If an API token is present, Sanctum will authenticate the request
using that token. To learn more about this process, please consult Sanctum's "how it works" documentation.
Laravel Sanctum is the API package we have chosen to include with the Laravel Jetstream application starter kit because
we believe it is the best fit for the majority of web application's authentication needs.
Summary & Choosing Your Stack
In summary, if your application will be accessed using a browser and you are building a monolithic Laravel application, your
application will use Laravel's built-in authentication services.
Next, if your application offers an API that will be consumed by third parties, you will choose between Passport or Sanctum
to provide API token authentication for your application. In general, Sanctum should be preferred when possible since it is
a simple, complete solution for API authentication, SPA authentication, and mobile authentication, including support for
"scopes" or "abilities".

Page 673 of 1307

Laravel 9.x

If you are building a single-page application (SPA) that will be powered by a Laravel backend, you should use Laravel
Sanctum. When using Sanctum, you will either need to manually implement your own backend authentication routes or
utilize Laravel Fortify as a headless authentication backend service that provides routes and controllers for features such
as registration, password reset, email verification, and more.
Passport may be chosen when your application absolutely needs all of the features provided by the OAuth2 specification.
And, if you would like to get started quickly, we are pleased to recommend Laravel Breeze as a quick way to start a new
Laravel application that already uses our preferred authentication stack of Laravel's built-in authentication services and
Laravel Sanctum.

Authentication Quickstart
This portion of the documentation discusses authenticating users via the Laravel application starter
kits, which includes UI scaffolding to help you get started quickly. If you would like to integrate with
Laravel's authentication systems directly, check out the documentation on manually authenticating
users.

Install A Starter Kit

First, you should install a Laravel application starter kit. Our current starter kits, Laravel Breeze and Laravel Jetstream,
offer beautifully designed starting points for incorporating authentication into your fresh Laravel application.
Laravel Breeze is a minimal, simple implementation of all of Laravel's authentication features, including login, registration,
password reset, email verification, and password confirmation. Laravel Breeze's view layer is made up of simple Blade
templates styled with Tailwind CSS. Breeze also offers an Inertia based scaffolding option using Vue or React.
Laravel Jetstream is a more robust application starter kit that includes support for scaffolding your application with
Livewire or Inertia and Vue. In addition, Jetstream features optional support for two-factor authentication, teams, profile
management, browser session management, API support via Laravel Sanctum, account deletion, and more.

Retrieving The Authenticated User

After installing an authentication starter kit and allowing users to register and authenticate with your application, you will
often need to interact with the currently authenticated user. While handling an incoming request, you may access the
authenticated user via the Auth facade's user method:
use Illuminate\Support\Facades\Auth;
// Retrieve the currently authenticated user...
$user = Auth::user();
// Retrieve the currently authenticated user's ID...
$id = Auth::id();

Alternatively, once a user is authenticated, you may access the authenticated user via an Illuminate\Http\Request
instance. Remember, type-hinted classes will automatically be injected into your controller methods. By type-hinting the
Illuminate\Http\Request object, you may gain convenient access to the authenticated user from any controller
method in your application via the request's user method:

Page 674 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class FlightController extends Controller
{
/**
* Update the flight information for an existing flight.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function update(Request $request)
{
// $request->user()
}
}

Determining If The Current User Is Authenticated
To determine if the user making the incoming HTTP request is authenticated, you may use the check method on the
Auth facade. This method will return true if the user is authenticated:
use Illuminate\Support\Facades\Auth;
if (Auth::check()) {
// The user is logged in...
}

Even though it is possible to determine if a user is authenticated using the check method, you will
typically use a middleware to verify that the user is authenticated before allowing the user access
to certain routes / controllers. To learn more about this, check out the documentation on protecting
routes.

Protecting Routes

Route middleware can be used to only allow authenticated users to access a given route. Laravel ships with an auth
middleware, which references the Illuminate\Auth\Middleware\Authenticate class. Since this middleware is already
registered in your application's HTTP kernel, all you need to do is attach the middleware to a route definition:
Route::get('/flights', function () {
// Only authenticated users may access this route...
})->middleware('auth');

Redirecting Unauthenticated Users
When the auth middleware detects an unauthenticated user, it will redirect the user to the login named route. You
may modify this behavior by updating the redirectTo function in your application's
app/Http/Middleware/Authenticate.php file:
Page 675 of 1307

Laravel 9.x

/**
* Get the path the user should be redirected to.
*
* @param

\Illuminate\Http\Request

$request

* @return string
*/
protected function redirectTo($request)
{
return route('login');
}

Specifying A Guard
When attaching the auth middleware to a route, you may also specify which "guard" should be used to authenticate the
user. The guard specified should correspond to one of the keys in the guards array of your auth.php configuration
file:
Route::get('/flights', function () {
// Only authenticated users may access this route...
})->middleware('auth:admin');

Login Throttling

If you are using the Laravel Breeze or Laravel Jetstream starter kits, rate limiting will automatically be applied to login
attempts. By default, the user will not be able to login for one minute if they fail to provide the correct credentials after
several attempts. The throttling is unique to the user's username / email address and their IP address.
If you would like to rate limit other routes in your application, check out the rate limiting
documentation.

Manually Authenticating Users

You are not required to use the authentication scaffolding included with Laravel's application starter kits. If you choose not
to use this scaffolding, you will need to manage user authentication using the Laravel authentication classes directly. Don't
worry, it's a cinch!
We will access Laravel's authentication services via the Auth facade, so we'll need to make sure to import the Auth
facade at the top of the class. Next, let's check out the attempt method. The attempt method is normally used to
handle authentication attempts from your application's "login" form. If authentication is successful, you should regenerate
the user's session to prevent session fixation:

Page 676 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
class LoginController extends Controller
{
/**
* Handle an authentication attempt.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function authenticate(Request $request)
{
$credentials = $request->validate([
'email' => ['required', 'email'],
'password' => ['required'],
]);
if (Auth::attempt($credentials)) {
$request->session()->regenerate();
return redirect()->intended('dashboard');
}
return back()->withErrors([
'email' => 'The provided credentials do not match our records.',
])->onlyInput('email');
}
}

The attempt method accepts an array of key / value pairs as its first argument. The values in the array will be used to
find the user in your database table. So, in the example above, the user will be retrieved by the value of the email
column. If the user is found, the hashed password stored in the database will be compared with the password value
passed to the method via the array. You should not hash the incoming request's password value, since the framework
will automatically hash the value before comparing it to the hashed password in the database. An authenticated session
will be started for the user if the two hashed passwords match.
Remember, Laravel's authentication services will retrieve users from your database based on your authentication guard's
"provider" configuration. In the default config/auth.php configuration file, the Eloquent user provider is specified and it
is instructed to use the App\Models\User model when retrieving users. You may change these values within your
configuration file based on the needs of your application.
The attempt method will return true if authentication was successful. Otherwise, false will be returned.
The intended method provided by Laravel's redirector will redirect the user to the URL they were attempting to access
before being intercepted by the authentication middleware. A fallback URI may be given to this method in case the
intended destination is not available.
Specifying Additional Conditions
If you wish, you may also add extra query conditions to the authentication query in addition to the user's email and
password. To accomplish this, we may simply add the query conditions to the array passed to the attempt method. For
Page 677 of 1307

Laravel 9.x

example, we may verify that the user is marked as "active":
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
// Authentication was successful...
}

For complex query conditions, you may provide a closure in your array of credentials. This closure will be invoked with the
query instance, allowing you to customize the query based on your application's needs:
if (Auth::attempt([
'email' => $email,
'password' => $password,
fn ($query) => $query->has('activeSubscription'),
])) {
// Authentication was successful...
}

In these examples, email is not a required option, it is merely used as an example. You should
use whatever column name corresponds to a "username" in your database table.
The attemptWhen method, which receives a closure as its second argument, may be used to perform more extensive
inspection of the potential user before actually authenticating the user. The closure receives the potential user and should
return true or false to indicate if the user may be authenticated:
if (Auth::attemptWhen([
'email' => $email,
'password' => $password,
], function ($user) {
return $user->isNotBanned();
})) {
// Authentication was successful...
}

Accessing Specific Guard Instances
Via the Auth facade's guard method, you may specify which guard instance you would like to utilize when
authenticating the user. This allows you to manage authentication for separate parts of your application using entirely
separate authenticatable models or user tables.
The guard name passed to the guard method should correspond to one of the guards configured in your auth.php
configuration file:
if (Auth::guard('admin')->attempt($credentials)) {
// ...
}

Remembering Users

Many web applications provide a "remember me" checkbox on their login form. If you would like to provide "remember me"
functionality in your application, you may pass a boolean value as the second argument to the attempt method.

Page 678 of 1307

Laravel 9.x

When this value is true , Laravel will keep the user authenticated indefinitely or until they manually logout. Your users
table must include the string remember_token column, which will be used to store the "remember me" token. The
users table migration included with new Laravel applications already includes this column:
use Illuminate\Support\Facades\Auth;
if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {
// The user is being remembered...
}

If your application offers "remember me" functionality, you may use the viaRemember method to determine if the
currently authenticated user was authenticated using the "remember me" cookie:
use Illuminate\Support\Facades\Auth;
if (Auth::viaRemember()) {
// ...
}

Other Authentication Methods

Authenticate A User Instance
If you need to set an existing user instance as the currently authenticated user, you may pass the user instance to the
Auth facade's login method. The given user instance must be an implementation of the
Illuminate\Contracts\Auth\Authenticatable contract. The App\Models\User model included with Laravel
already implements this interface. This method of authentication is useful when you already have a valid user instance,
such as directly after a user registers with your application:
use Illuminate\Support\Facades\Auth;
Auth::login($user);

You may pass a boolean value as the second argument to the login method. This value indicates if "remember me"
functionality is desired for the authenticated session. Remember, this means that the session will be authenticated
indefinitely or until the user manually logs out of the application:
Auth::login($user, $remember = true);

If needed, you may specify an authentication guard before calling the login method:
Auth::guard('admin')->login($user);

Authenticate A User By ID
To authenticate a user using their database record's primary key, you may use the loginUsingId method. This method
accepts the primary key of the user you wish to authenticate:
Auth::loginUsingId(1);

You may pass a boolean value as the second argument to the loginUsingId method. This value indicates if "remember
me" functionality is desired for the authenticated session. Remember, this means that the session will be authenticated
indefinitely or until the user manually logs out of the application:
Page 679 of 1307

Laravel 9.x

Auth::loginUsingId(1, $remember = true);

Authenticate A User Once
You may use the once method to authenticate a user with the application for a single request. No sessions or cookies will
be utilized when calling this method:
if (Auth::once($credentials)) {
//
}

HTTP Basic Authentication

HTTP Basic Authentication provides a quick way to authenticate users of your application without setting up a dedicated
"login" page. To get started, attach the auth.basic middleware to a route. The auth.basic middleware is included
with the Laravel framework, so you do not need to define it:
Route::get('/profile', function () {
// Only authenticated users may access this route...
})->middleware('auth.basic');

Once the middleware has been attached to the route, you will automatically be prompted for credentials when accessing
the route in your browser. By default, the auth.basic middleware will assume the email column on your users
database table is the user's "username".
A Note On FastCGI
If you are using PHP FastCGI and Apache to serve your Laravel application, HTTP Basic authentication may not work
correctly. To correct these problems, the following lines may be added to your application's .htaccess file:
RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

Stateless HTTP Basic Authentication

You may also use HTTP Basic Authentication without setting a user identifier cookie in the session. This is primarily helpful
if you choose to use HTTP Authentication to authenticate requests to your application's API. To accomplish this, define a
middleware that calls the onceBasic method. If no response is returned by the onceBasic method, the request may be
passed further into the application:

Page 680 of 1307

Laravel 9.x

<?php
namespace App\Http\Middleware;
use Illuminate\Support\Facades\Auth;
class AuthenticateOnceWithBasicAuth
{
/**
* Handle an incoming request.
*
* @param

\Illuminate\Http\Request

* @param

\Closure

$request

$next

* @return mixed
*/
public function handle($request, $next)
{
return Auth::onceBasic() ?: $next($request);
}
}

Next, register the route middleware and attach it to a route:
Route::get('/api/user', function () {
// Only authenticated users may access this route...
})->middleware('auth.basic.once');

Logging Out

To manually log users out of your application, you may use the logout method provided by the Auth facade. This will
remove the authentication information from the user's session so that subsequent requests are not authenticated.
In addition to calling the logout method, it is recommended that you invalidate the user's session and regenerate their
CSRF token. After logging the user out, you would typically redirect the user to the root of your application:

Page 681 of 1307

Laravel 9.x

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
/**
* Log the user out of the application.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function logout(Request $request)
{
Auth::logout();
$request->session()->invalidate();
$request->session()->regenerateToken();
return redirect('/');
}

Invalidating Sessions On Other Devices

Laravel also provides a mechanism for invalidating and "logging out" a user's sessions that are active on other devices
without invalidating the session on their current device. This feature is typically utilized when a user is changing or
updating their password and you would like to invalidate sessions on other devices while keeping the current device
authenticated.
Before getting started, you should make sure that the Illuminate\Session\Middleware\AuthenticateSession
middleware is included on the routes that should receive session authentication. Typically, you should place this
middleware on a route group definition so that it can be applied to the majority of your application's routes. By default, the
AuthenticateSession middleware may be attached to a route using the auth.session route middleware key as
defined in your application's HTTP kernel:
Route::middleware(['auth', 'auth.session'])->group(function () {
Route::get('/', function () {
// ...
});
});

Then, you may use the logoutOtherDevices method provided by the Auth facade. This method requires the user to
confirm their current password, which your application should accept through an input form:
use Illuminate\Support\Facades\Auth;
Auth::logoutOtherDevices($currentPassword);

When the logoutOtherDevices method is invoked, the user's other sessions will be invalidated entirely, meaning they
will be "logged out" of all guards they were previously authenticated by.

Password Confirmation

While building your application, you may occasionally have actions that should require the user to confirm their password
before the action is performed or before the user is redirected to a sensitive area of the application. Laravel includes builtin middleware to make this process a breeze. Implementing this feature will require you to define two routes: one route to
Page 682 of 1307

Laravel 9.x

display a view asking the user to confirm their password and another route to confirm that the password is valid and
redirect the user to their intended destination.
The following documentation discusses how to integrate with Laravel's password confirmation
features directly; however, if you would like to get started more quickly, the Laravel application
starter kits include support for this feature!

Configuration

After confirming their password, a user will not be asked to confirm their password again for three hours. However, you
may configure the length of time before the user is re-prompted for their password by changing the value of the
password_timeout configuration value within your application's config/auth.php configuration file.

Routing

The Password Confirmation Form
First, we will define a route to display a view that requests the user to confirm their password:
Route::get('/confirm-password', function () {
return view('auth.confirm-password');
})->middleware('auth')->name('password.confirm');

As you might expect, the view that is returned by this route should have a form containing a password field. In addition,
feel free to include text within the view that explains that the user is entering a protected area of the application and must
confirm their password.
Confirming The Password
Next, we will define a route that will handle the form request from the "confirm password" view. This route will be
responsible for validating the password and redirecting the user to their intended destination:
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Redirect;
Route::post('/confirm-password', function (Request $request) {
if (! Hash::check($request->password, $request->user()->password)) {
return back()->withErrors([
'password' => ['The provided password does not match our records.']
]);
}
$request->session()->passwordConfirmed();
return redirect()->intended();
})->middleware(['auth', 'throttle:6,1']);

Before moving on, let's examine this route in more detail. First, the request's password field is determined to actually
match the authenticated user's password. If the password is valid, we need to inform Laravel's session that the user has
confirmed their password. The passwordConfirmed method will set a timestamp in the user's session that Laravel can
use to determine when the user last confirmed their password. Finally, we can redirect the user to their intended
destination.
Page 683 of 1307

Laravel 9.x

Protecting Routes

You should ensure that any route that performs an action which requires recent password confirmation is assigned the
password.confirm middleware. This middleware is included with the default installation of Laravel and will automatically
store the user's intended destination in the session so that the user may be redirected to that location after confirming
their password. After storing the user's intended destination in the session, the middleware will redirect the user to the
password.confirm named route:
Route::get('/settings', function () {
// ...
})->middleware(['password.confirm']);
Route::post('/settings', function () {
// ...
})->middleware(['password.confirm']);

Adding Custom Guards

You may define your own authentication guards using the extend method on the Auth facade. You should place your
call to the extend method within a service provider. Since Laravel already ships with an AuthServiceProvider , we
can place the code in that provider:
<?php
namespace App\Providers;
use App\Services\Auth\JwtGuard;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;
class AuthServiceProvider extends ServiceProvider
{
/**
* Register any application authentication / authorization services.
*
* @return void
*/
public function boot()
{
$this->registerPolicies();
Auth::extend('jwt', function ($app, $name, array $config) {
// Return an instance of Illuminate\Contracts\Auth\Guard...
return new JwtGuard(Auth::createUserProvider($config['provider']));
});
}
}

As you can see in the example above, the callback passed to the extend method should return an implementation of
Illuminate\Contracts\Auth\Guard . This interface contains a few methods you will need to implement to define a
custom guard. Once your custom guard has been defined, you may reference the guard in the guards configuration of
your auth.php configuration file:

Page 684 of 1307

Laravel 9.x

'guards' => [
'api' => [
'driver' => 'jwt',
'provider' => 'users',
],
],

Closure Request Guards

The simplest way to implement a custom, HTTP request based authentication system is by using the Auth::viaRequest
method. This method allows you to quickly define your authentication process using a single closure.
To get started, call the Auth::viaRequest method within the boot method of your AuthServiceProvider . The
viaRequest method accepts an authentication driver name as its first argument. This name can be any string that
describes your custom guard. The second argument passed to the method should be a closure that receives the incoming
HTTP request and returns a user instance or, if authentication fails, null :
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
/**
* Register any application authentication / authorization services.
*
* @return void
*/
public function boot()
{
$this->registerPolicies();
Auth::viaRequest('custom-token', function (Request $request) {
return User::where('token', (string) $request->token)->first();
});
}

Once your custom authentication driver has been defined, you may configure it as a driver within the guards
configuration of your auth.php configuration file:
'guards' => [
'api' => [
'driver' => 'custom-token',
],
],

Finally, you may reference the guard when assigning the authentication middleware to a route:
Route::middleware('auth:api')->group(function () {
// ...
}

Adding Custom User Providers
Page 685 of 1307

Laravel 9.x

If you are not using a traditional relational database to store your users, you will need to extend Laravel with your own
authentication user provider. We will use the provider method on the Auth facade to define a custom user provider.
The user provider resolver should return an implementation of Illuminate\Contracts\Auth\UserProvider :
<?php
namespace App\Providers;
use App\Extensions\MongoUserProvider;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;
class AuthServiceProvider extends ServiceProvider
{
/**
* Register any application authentication / authorization services.
*
* @return void
*/
public function boot()
{
$this->registerPolicies();
Auth::provider('mongo', function ($app, array $config) {
// Return an instance of Illuminate\Contracts\Auth\UserProvider...
return new MongoUserProvider($app->make('mongo.connection'));
});
}
}

After you have registered the provider using the provider method, you may switch to the new user provider in your
auth.php configuration file. First, define a provider that uses your new driver:
'providers' => [
'users' => [
'driver' => 'mongo',
],
],

Finally, you may reference this provider in your guards configuration:
'guards' => [
'web' => [
'driver' => 'session',
'provider' => 'users',
],
],

The User Provider Contract
Illuminate\Contracts\Auth\UserProvider

implementations are responsible for fetching an
implementation out of a persistent storage system, such as MySQL,

Illuminate\Contracts\Auth\Authenticatable

Page 686 of 1307

Laravel 9.x

MongoDB, etc. These two interfaces allow the Laravel authentication mechanisms to continue functioning regardless of
how the user data is stored or what type of class is used to represent the authenticated user:
Let's take a look at the Illuminate\Contracts\Auth\UserProvider contract:
<?php
namespace Illuminate\Contracts\Auth;
interface UserProvider
{
public function retrieveById($identifier);
public function retrieveByToken($identifier, $token);
public function updateRememberToken(Authenticatable $user, $token);
public function retrieveByCredentials(array $credentials);
public function validateCredentials(Authenticatable $user, array $credentials);
}

The retrieveById function typically receives a key representing the user, such as an auto-incrementing ID from a
MySQL database. The Authenticatable implementation matching the ID should be retrieved and returned by the
method.
The retrieveByToken function retrieves a user by their unique $identifier and "remember me" $token , typically
stored in a database column like remember_token . As with the previous method, the Authenticatable
implementation with a matching token value should be returned by this method.
The updateRememberToken method updates the $user instance's remember_token with the new $token . A fresh
token is assigned to users on a successful "remember me" authentication attempt or when the user is logging out.
The retrieveByCredentials method receives the array of credentials passed to the Auth::attempt method when
attempting to authenticate with an application. The method should then "query" the underlying persistent storage for the
user matching those credentials. Typically, this method will run a query with a "where" condition that searches for a user
record with a "username" matching the value of $credentials['username'] . The method should return an
implementation of Authenticatable . This method should not attempt to do any password validation or
authentication.
The validateCredentials method should compare the given $user with the $credentials to authenticate the
user. For example, this method will typically use the Hash::check method to compare the value of $user>getAuthPassword() to the value of $credentials['password'] . This method should return true or false
indicating whether the password is valid.

The Authenticatable Contract

Now that we have explored each of the methods on the UserProvider , let's take a look at the Authenticatable
contract. Remember, user providers should return implementations of this interface from the retrieveById ,
retrieveByToken , and retrieveByCredentials methods:

Page 687 of 1307

Laravel 9.x

<?php
namespace Illuminate\Contracts\Auth;
interface Authenticatable
{
public function getAuthIdentifierName();
public function getAuthIdentifier();
public function getAuthPassword();
public function getRememberToken();
public function setRememberToken($value);
public function getRememberTokenName();
}

This interface is simple. The getAuthIdentifierName method should return the name of the "primary key" field of the
user and the getAuthIdentifier method should return the "primary key" of the user. When using a MySQL back-end,
this would likely be the auto-incrementing primary key assigned to the user record. The getAuthPassword method
should return the user's hashed password.
This interface allows the authentication system to work with any "user" class, regardless of what ORM or storage
abstraction layer you are using. By default, Laravel includes a App\Models\User class in the app/Models directory
which implements this interface.

Events

Laravel dispatches a variety of events during the authentication process. You may attach listeners to these events in your
EventServiceProvider :

Page 688 of 1307

Laravel 9.x

/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
'Illuminate\Auth\Events\Registered' => [
'App\Listeners\LogRegisteredUser',
],
'Illuminate\Auth\Events\Attempting' => [
'App\Listeners\LogAuthenticationAttempt',
],
'Illuminate\Auth\Events\Authenticated' => [
'App\Listeners\LogAuthenticated',
],
'Illuminate\Auth\Events\Login' => [
'App\Listeners\LogSuccessfulLogin',
],
'Illuminate\Auth\Events\Failed' => [
'App\Listeners\LogFailedLogin',
],
'Illuminate\Auth\Events\Validated' => [
'App\Listeners\LogValidated',
],
'Illuminate\Auth\Events\Verified' => [
'App\Listeners\LogVerified',
],
'Illuminate\Auth\Events\Logout' => [
'App\Listeners\LogSuccessfulLogout',
],
'Illuminate\Auth\Events\CurrentDeviceLogout' => [
'App\Listeners\LogCurrentDeviceLogout',
],
'Illuminate\Auth\Events\OtherDeviceLogout' => [
'App\Listeners\LogOtherDeviceLogout',
],
'Illuminate\Auth\Events\Lockout' => [
'App\Listeners\LogLockout',
],
'Illuminate\Auth\Events\PasswordReset' => [
'App\Listeners\LogPasswordReset',
],
];

Page 689 of 1307

Laravel 9.x

Authorization
Introduction
Gates
Writing Gates
Authorizing Actions
Gate Responses
Intercepting Gate Checks
Inline Authorization
Creating Policies
Generating Policies
Registering Policies
Writing Policies
Policy Methods
Policy Responses
Methods Without Models
Guest Users
Policy Filters
Authorizing Actions Using Policies
Via The User Model
Via Controller Helpers
Via Middleware
Via Blade Templates
Supplying Additional Context

Introduction

In addition to providing built-in authentication services, Laravel also provides a simple way to authorize user actions
against a given resource. For example, even though a user is authenticated, they may not be authorized to update or delete
certain Eloquent models or database records managed by your application. Laravel's authorization features provide an
easy, organized way of managing these types of authorization checks.
Laravel provides two primary ways of authorizing actions: gates and policies. Think of gates and policies like routes and
controllers. Gates provide a simple, closure-based approach to authorization while policies, like controllers, group logic
around a particular model or resource. In this documentation, we'll explore gates first and then examine policies.
You do not need to choose between exclusively using gates or exclusively using policies when building an application. Most
applications will most likely contain some mixture of gates and policies, and that is perfectly fine! Gates are most
applicable to actions that are not related to any model or resource, such as viewing an administrator dashboard. In
contrast, policies should be used when you wish to authorize an action for a particular model or resource.

Gates

Writing Gates
Gates are a great way to learn the basics of Laravel's authorization features; however, when
building robust Laravel applications you should consider using policies to organize your
authorization rules.

Page 690 of 1307

Laravel 9.x

Gates are simply closures that determine if a user is authorized to perform a given action. Typically, gates are defined
within the boot method of the App\Providers\AuthServiceProvider class using the Gate facade. Gates always
receive a user instance as their first argument and may optionally receive additional arguments such as a relevant Eloquent
model.
In this example, we'll define a gate to determine if a user can update a given App\Models\Post model. The gate will
accomplish this by comparing the user's id against the user_id of the user that created the post:
use App\Models\Post;
use App\Models\User;
use Illuminate\Support\Facades\Gate;
/**
* Register any authentication / authorization services.
*
* @return void
*/
public function boot()
{
$this->registerPolicies();
Gate::define('update-post', function (User $user, Post $post) {
return $user->id === $post->user_id;
});
}

Like controllers, gates may also be defined using a class callback array:
use App\Policies\PostPolicy;
use Illuminate\Support\Facades\Gate;
/**
* Register any authentication / authorization services.
*
* @return void
*/
public function boot()
{
$this->registerPolicies();
Gate::define('update-post', [PostPolicy::class, 'update']);
}

Authorizing Actions

To authorize an action using gates, you should use the allows or denies methods provided by the Gate facade.
Note that you are not required to pass the currently authenticated user to these methods. Laravel will automatically take
care of passing the user into the gate closure. It is typical to call the gate authorization methods within your application's
controllers before performing an action that requires authorization:

Page 691 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;
class PostController extends Controller
{
/**
* Update the given post.
*
* @param

\Illuminate\Http\Request

* @param

\App\Models\Post

$request

$post

* @return \Illuminate\Http\Response
*/
public function update(Request $request, Post $post)
{
if (! Gate::allows('update-post', $post)) {
abort(403);
}
// Update the post...
}
}

If you would like to determine if a user other than the currently authenticated user is authorized to perform an action, you
may use the forUser method on the Gate facade:
if (Gate::forUser($user)->allows('update-post', $post)) {
// The user can update the post...
}
if (Gate::forUser($user)->denies('update-post', $post)) {
// The user can't update the post...
}

You may authorize multiple actions at a time using the any or none methods:
if (Gate::any(['update-post', 'delete-post'], $post)) {
// The user can update or delete the post...
}
if (Gate::none(['update-post', 'delete-post'], $post)) {
// The user can't update or delete the post...
}

Authorizing Or Throwing Exceptions
If you would like to attempt to authorize an action and automatically throw an
Illuminate\Auth\Access\AuthorizationException if the user is not allowed to perform the given action, you may

Page 692 of 1307

Laravel 9.x

use the Gate facade's authorize method. Instances of AuthorizationException are automatically converted to a
403 HTTP response by Laravel's exception handler:
Gate::authorize('update-post', $post);
// The action is authorized...

Supplying Additional Context
The gate methods for authorizing abilities ( allows , denies , check , any , none , authorize , can , cannot )
and the authorization Blade directives ( @can , @cannot , @canany ) can receive an array as their second argument.
These array elements are passed as parameters to the gate closure, and can be used for additional context when making
authorization decisions:
use App\Models\Category;
use App\Models\User;
use Illuminate\Support\Facades\Gate;
Gate::define('create-post', function (User $user, Category $category, $pinned) {
if (! $user->canPublishToGroup($category->group)) {
return false;
} elseif ($pinned && ! $user->canPinPosts()) {
return false;
}
return true;
});
if (Gate::check('create-post', [$category, $pinned])) {
// The user can create the post...
}

Gate Responses

So far, we have only examined gates that return simple boolean values. However, sometimes you may wish to return a more
detailed response, including an error message. To do so, you may return an Illuminate\Auth\Access\Response from
your gate:
use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;
Gate::define('edit-settings', function (User $user) {
return $user->isAdmin
? Response::allow()
: Response::deny('You must be an administrator.');
});

Even when you return an authorization response from your gate, the Gate::allows method will still return a simple
boolean value; however, you may use the Gate::inspect method to get the full authorization response returned by the
gate:

Page 693 of 1307

Laravel 9.x

$response = Gate::inspect('edit-settings');
if ($response->allowed()) {
// The action is authorized...
} else {
echo $response->message();
}

When using the Gate::authorize method, which throws an AuthorizationException if the action is not authorized,
the error message provided by the authorization response will be propagated to the HTTP response:
Gate::authorize('edit-settings');
// The action is authorized...

Customizing The HTTP Response Status
When an action is denied via a Gate, a 403 HTTP response is returned; however, it can sometimes be useful to return an
alternative HTTP status code. You may customize the HTTP status code returned for a failed authorization check using the
denyWithStatus static constructor on the Illuminate\Auth\Access\Response class:
use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;
Gate::define('edit-settings', function (User $user) {
return $user->isAdmin
? Response::allow()
: Response::denyWithStatus(404);
});

Because hiding resources via a 404 response is such a common pattern for web applications, the denyAsNotFound
method is offered for convenience:
use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;
Gate::define('edit-settings', function (User $user) {
return $user->isAdmin
? Response::allow()
: Response::denyAsNotFound();
});

Intercepting Gate Checks

Sometimes, you may wish to grant all abilities to a specific user. You may use the before method to define a closure that
is run before all other authorization checks:

Page 694 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Gate;
Gate::before(function ($user, $ability) {
if ($user->isAdministrator()) {
return true;
}
});

If the before closure returns a non-null result that result will be considered the result of the authorization check.
You may use the after method to define a closure to be executed after all other authorization checks:
Gate::after(function ($user, $ability, $result, $arguments) {
if ($user->isAdministrator()) {
return true;
}
});

Similar to the before method, if the after closure returns a non-null result that result will be considered the result of
the authorization check.

Inline Authorization

Occasionally, you may wish to determine if the currently authenticated user is authorized to perform a given action without
writing a dedicated gate that corresponds to the action. Laravel allows you to perform these types of "inline" authorization
checks via the Gate::allowIf and Gate::denyIf methods:
use Illuminate\Support\Facades\Gate;
Gate::allowIf(fn ($user) => $user->isAdministrator());
Gate::denyIf(fn ($user) => $user->banned());

If the action is not authorized or if no user is currently authenticated, Laravel will automatically throw an
Illuminate\Auth\Access\AuthorizationException exception. Instances of AuthorizationException are
automatically converted to a 403 HTTP response by Laravel's exception handler.

Creating Policies
Generating Policies

Policies are classes that organize authorization logic around a particular model or resource. For example, if your
application is a blog, you may have a App\Models\Post model and a corresponding App\Policies\PostPolicy to
authorize user actions such as creating or updating posts.
You may generate a policy using the make:policy Artisan command. The generated policy will be placed in the
app/Policies directory. If this directory does not exist in your application, Laravel will create it for you:
php artisan make:policy PostPolicy

The make:policy command will generate an empty policy class. If you would like to generate a class with example policy
methods related to viewing, creating, updating, and deleting the resource, you may provide a --model option when
executing the command:

Page 695 of 1307

Laravel 9.x

php artisan make:policy PostPolicy --model=Post

Registering Policies

Once the policy class has been created, it needs to be registered. Registering policies is how we can inform Laravel which
policy to use when authorizing actions against a given model type.
The App\Providers\AuthServiceProvider included with fresh Laravel applications contains a policies property
which maps your Eloquent models to their corresponding policies. Registering a policy will instruct Laravel which policy to
utilize when authorizing actions against a given Eloquent model:
<?php
namespace App\Providers;
use App\Models\Post;
use App\Policies\PostPolicy;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Gate;
class AuthServiceProvider extends ServiceProvider
{
/**
* The policy mappings for the application.
*
* @var array
*/
protected $policies = [
Post::class => PostPolicy::class,
];
/**
* Register any application authentication / authorization services.
*
* @return void
*/
public function boot()
{
$this->registerPolicies();
//
}
}

Policy Auto-Discovery
Instead of manually registering model policies, Laravel can automatically discover policies as long as the model and policy
follow standard Laravel naming conventions. Specifically, the policies must be in a Policies directory at or above the
directory that contains your models. So, for example, the models may be placed in the app/Models directory while the
policies may be placed in the app/Policies directory. In this situation, Laravel will check for policies in
app/Models/Policies then app/Policies . In addition, the policy name must match the model name and have a
Policy suffix. So, a User model would correspond to a UserPolicy policy class.
If you would like to define your own policy discovery logic, you may register a custom policy discovery callback using the
Gate::guessPolicyNamesUsing method. Typically, this method should be called from the boot method of your
Page 696 of 1307

Laravel 9.x

application's AuthServiceProvider :
use Illuminate\Support\Facades\Gate;
Gate::guessPolicyNamesUsing(function ($modelClass) {
// Return the name of the policy class for the given model...
});

Any policies that are explicitly mapped in your AuthServiceProvider will take precedence over
any potentially auto-discovered policies.

Writing Policies
Policy Methods

Once the policy class has been registered, you may add methods for each action it authorizes. For example, let's define an
update method on our PostPolicy which determines if a given App\Models\User can update a given
App\Models\Post instance.
The update method will receive a User and a Post instance as its arguments, and should return true or false
indicating whether the user is authorized to update the given Post . So, in this example, we will verify that the user's id
matches the user_id on the post:
<?php
namespace App\Policies;
use App\Models\Post;
use App\Models\User;
class PostPolicy
{
/**
* Determine if the given post can be updated by the user.
*
* @param

\App\Models\User

$user

* @param

\App\Models\Post

$post

* @return bool
*/
public function update(User $user, Post $post)
{
return $user->id === $post->user_id;
}
}

You may continue to define additional methods on the policy as needed for the various actions it authorizes. For example,
you might define view or delete methods to authorize various Post related actions, but remember you are free to
give your policy methods any name you like.
If you used the --model option when generating your policy via the Artisan console, it will already contain methods for
the viewAny , view , create , update , delete , restore , and forceDelete actions.

Page 697 of 1307

Laravel 9.x

All policies are resolved via the Laravel service container, allowing you to type-hint any needed
dependencies in the policy's constructor to have them automatically injected.

Policy Responses

So far, we have only examined policy methods that return simple boolean values. However, sometimes you may wish to
return a more detailed response, including an error message. To do so, you may return an
Illuminate\Auth\Access\Response instance from your policy method:
use App\Models\Post;
use App\Models\User;
use Illuminate\Auth\Access\Response;
/**
* Determine if the given post can be updated by the user.
*
* @param

\App\Models\User

$user

* @param

\App\Models\Post

$post

* @return \Illuminate\Auth\Access\Response
*/
public function update(User $user, Post $post)
{
return $user->id === $post->user_id
? Response::allow()
: Response::deny('You do not own this post.');
}

When returning an authorization response from your policy, the Gate::allows method will still return a simple boolean
value; however, you may use the Gate::inspect method to get the full authorization response returned by the gate:
use Illuminate\Support\Facades\Gate;
$response = Gate::inspect('update', $post);
if ($response->allowed()) {
// The action is authorized...
} else {
echo $response->message();
}

When using the Gate::authorize method, which throws an AuthorizationException if the action is not authorized,
the error message provided by the authorization response will be propagated to the HTTP response:
Gate::authorize('update', $post);
// The action is authorized...

Customizing The HTTP Response Status
When an action is denied via a policy method, a 403 HTTP response is returned; however, it can sometimes be useful to
return an alternative HTTP status code. You may customize the HTTP status code returned for a failed authorization check
Page 698 of 1307

Laravel 9.x

using the denyWithStatus static constructor on the Illuminate\Auth\Access\Response class:
use App\Models\Post;
use App\Models\User;
use Illuminate\Auth\Access\Response;
/**
* Determine if the given post can be updated by the user.
*
* @param

\App\Models\User

$user

* @param

\App\Models\Post

$post

* @return \Illuminate\Auth\Access\Response
*/
public function update(User $user, Post $post)
{
return $user->id === $post->user_id
? Response::allow()
: Response::denyWithStatus(404);
}

Because hiding resources via a 404 response is such a common pattern for web applications, the denyAsNotFound
method is offered for convenience:
use App\Models\Post;
use App\Models\User;
use Illuminate\Auth\Access\Response;
/**
* Determine if the given post can be updated by the user.
*
* @param

\App\Models\User

$user

* @param

\App\Models\Post

$post

* @return \Illuminate\Auth\Access\Response
*/
public function update(User $user, Post $post)
{
return $user->id === $post->user_id
? Response::allow()
: Response::denyAsNotFound();
}

Methods Without Models

Some policy methods only receive an instance of the currently authenticated user. This situation is most common when
authorizing create actions. For example, if you are creating a blog, you may wish to determine if a user is authorized to
create any posts at all. In these situations, your policy method should only expect to receive a user instance:

Page 699 of 1307

Laravel 9.x

/**
* Determine if the given user can create posts.
*
* @param

\App\Models\User

$user

* @return bool
*/
public function create(User $user)
{
return $user->role == 'writer';
}

Guest Users

By default, all gates and policies automatically return false if the incoming HTTP request was not initiated by an
authenticated user. However, you may allow these authorization checks to pass through to your gates and policies by
declaring an "optional" type-hint or supplying a null default value for the user argument definition:
<?php
namespace App\Policies;
use App\Models\Post;
use App\Models\User;
class PostPolicy
{
/**
* Determine if the given post can be updated by the user.
*
* @param

\App\Models\User

$user

* @param

\App\Models\Post

$post

* @return bool
*/
public function update(?User $user, Post $post)
{
return optional($user)->id === $post->user_id;
}
}

Policy Filters

For certain users, you may wish to authorize all actions within a given policy. To accomplish this, define a before method
on the policy. The before method will be executed before any other methods on the policy, giving you an opportunity to
authorize the action before the intended policy method is actually called. This feature is most commonly used for
authorizing application administrators to perform any action:

Page 700 of 1307

Laravel 9.x

use App\Models\User;
/**
* Perform pre-authorization checks.
*
* @param

\App\Models\User

* @param

string

$user

$ability

* @return void|bool
*/
public function before(User $user, $ability)
{
if ($user->isAdministrator()) {
return true;
}
}

If you would like to deny all authorization checks for a particular type of user then you may return false from the
before method. If null is returned, the authorization check will fall through to the policy method.
The before method of a policy class will not be called if the class doesn't contain a method with
a name matching the name of the ability being checked.

Authorizing Actions Using Policies
Via The User Model

The App\Models\User model that is included with your Laravel application includes two helpful methods for authorizing
actions: can and cannot . The can and cannot methods receive the name of the action you wish to authorize and
the relevant model. For example, let's determine if a user is authorized to update a given App\Models\Post model.
Typically, this will be done within a controller method:

Page 701 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\Request;
class PostController extends Controller
{
/**
* Update the given post.
*
* @param

\Illuminate\Http\Request

* @param

\App\Models\Post

$request

$post

* @return \Illuminate\Http\Response
*/
public function update(Request $request, Post $post)
{
if ($request->user()->cannot('update', $post)) {
abort(403);
}
// Update the post...
}
}

If a policy is registered for the given model, the can method will automatically call the appropriate policy and return the
boolean result. If no policy is registered for the model, the can method will attempt to call the closure-based Gate
matching the given action name.
Actions That Don't Require Models
Remember, some actions may correspond to policy methods like create that do not require a model instance. In these
situations, you may pass a class name to the can method. The class name will be used to determine which policy to use
when authorizing the action:

Page 702 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\Request;
class PostController extends Controller
{
/**
* Create a post.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
if ($request->user()->cannot('create', Post::class)) {
abort(403);
}
// Create the post...
}
}

Via Controller Helpers

In addition to helpful methods provided to the App\Models\User model, Laravel provides a helpful authorize method
to any of your controllers which extend the App\Http\Controllers\Controller base class.
Like the can method, this method accepts the name of the action you wish to authorize and the relevant model. If the
action is not authorized, the authorize method will throw an Illuminate\Auth\Access\AuthorizationException
exception which the Laravel exception handler will automatically convert to an HTTP response with a 403 status code:

Page 703 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\Request;
class PostController extends Controller
{
/**
* Update the given blog post.
*
* @param

\Illuminate\Http\Request

* @param

\App\Models\Post

$request

$post

* @return \Illuminate\Http\Response
*
* @throws \Illuminate\Auth\Access\AuthorizationException
*/
public function update(Request $request, Post $post)
{
$this->authorize('update', $post);
// The current user can update the blog post...
}
}

Actions That Don't Require Models
As previously discussed, some policy methods like create do not require a model instance. In these situations, you
should pass a class name to the authorize method. The class name will be used to determine which policy to use when
authorizing the action:
use App\Models\Post;
use Illuminate\Http\Request;
/**
* Create a new blog post.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*
* @throws \Illuminate\Auth\Access\AuthorizationException
*/
public function create(Request $request)
{
$this->authorize('create', Post::class);
// The current user can create blog posts...
}

Authorizing Resource Controllers
If you are utilizing resource controllers, you may make use of the authorizeResource method in your controller's
constructor. This method will attach the appropriate can middleware definitions to the resource controller's methods.
Page 704 of 1307

Laravel 9.x

The authorizeResource method accepts the model's class name as its first argument, and the name of the route /
request parameter that will contain the model's ID as its second argument. You should ensure your resource controller is
created using the --model flag so that it has the required method signatures and type hints:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\Request;
class PostController extends Controller
{
/**
* Create the controller instance.
*
* @return void
*/
public function __construct()
{
$this->authorizeResource(Post::class, 'post');
}
}

The following controller methods will be mapped to their corresponding policy method. When requests are routed to the
given controller method, the corresponding policy method will automatically be invoked before the controller method is
executed:
Controller Method
index
show
create
store
edit
update
destroy

Policy Method
viewAny
view
create
create
update
update
delete

You may use the make:policy command with the --model option to quickly generate a policy
class for a given model: php artisan make:policy PostPolicy --model=Post .

Via Middleware

Laravel includes a middleware that can authorize actions before the incoming request even reaches your routes or
controllers. By default, the Illuminate\Auth\Middleware\Authorize middleware is assigned the can key in your

Page 705 of 1307

Laravel 9.x

App\Http\Kernel

post:

class. Let's explore an example of using the can middleware to authorize that a user can update a

use App\Models\Post;
Route::put('/post/{post}', function (Post $post) {
// The current user may update the post...
})->middleware('can:update,post');

In this example, we're passing the can middleware two arguments. The first is the name of the action we wish to
authorize and the second is the route parameter we wish to pass to the policy method. In this case, since we are using
implicit model binding, a App\Models\Post model will be passed to the policy method. If the user is not authorized to
perform the given action, an HTTP response with a 403 status code will be returned by the middleware.
For convenience, you may also attach the can middleware to your route using the can method:
use App\Models\Post;
Route::put('/post/{post}', function (Post $post) {
// The current user may update the post...
})->can('update', 'post');

Actions That Don't Require Models
Again, some policy methods like create do not require a model instance. In these situations, you may pass a class name
to the middleware. The class name will be used to determine which policy to use when authorizing the action:
Route::post('/post', function () {
// The current user may create posts...
})->middleware('can:create,App\Models\Post');

Specifying the entire class name within a string middleware definition can become cumbersome. For that reason, you may
choose to attach the can middleware to your route using the can method:
use App\Models\Post;
Route::post('/post', function () {
// The current user may create posts...
})->can('create', Post::class);

Via Blade Templates

When writing Blade templates, you may wish to display a portion of the page only if the user is authorized to perform a
given action. For example, you may wish to show an update form for a blog post only if the user can actually update the
post. In this situation, you may use the @can and @cannot directives:

Page 706 of 1307

Laravel 9.x

@can('update', $post)
<!-- The current user can update the post... -->
@elsecan('create', App\Models\Post::class)
<!-- The current user can create new posts... -->
@else
<!-- ... -->
@endcan
@cannot('update', $post)
<!-- The current user cannot update the post... -->
@elsecannot('create', App\Models\Post::class)
<!-- The current user cannot create new posts... -->
@endcannot

These directives are convenient shortcuts for writing @if and @unless statements. The @can and @cannot
statements above are equivalent to the following statements:
@if (Auth::user()->can('update', $post))
<!-- The current user can update the post... -->
@endif
@unless (Auth::user()->can('update', $post))
<!-- The current user cannot update the post... -->
@endunless

You may also determine if a user is authorized to perform any action from a given array of actions. To accomplish this, use
the @canany directive:
@canany(['update', 'view', 'delete'], $post)
<!-- The current user can update, view, or delete the post... -->
@elsecanany(['create'], \App\Models\Post::class)
<!-- The current user can create a post... -->
@endcanany

Actions That Don't Require Models
Like most of the other authorization methods, you may pass a class name to the @can and @cannot directives if the
action does not require a model instance:
@can('create', App\Models\Post::class)
<!-- The current user can create posts... -->
@endcan
@cannot('create', App\Models\Post::class)
<!-- The current user can't create posts... -->
@endcannot

Supplying Additional Context

When authorizing actions using policies, you may pass an array as the second argument to the various authorization
functions and helpers. The first element in the array will be used to determine which policy should be invoked, while the
rest of the array elements are passed as parameters to the policy method and can be used for additional context when
making authorization decisions. For example, consider the following PostPolicy method definition which contains an
additional $category parameter:
Page 707 of 1307

Laravel 9.x

/**
* Determine if the given post can be updated by the user.
*
* @param

\App\Models\User

$user

* @param

\App\Models\Post

$post

* @param

int

$category

* @return bool
*/
public function update(User $user, Post $post, int $category)
{
return $user->id === $post->user_id &&
$user->canUpdateCategory($category);
}

When attempting to determine if the authenticated user can update a given post, we can invoke this policy method like so:
/**
* Update the given blog post.
*
* @param

\Illuminate\Http\Request

* @param

\App\Models\Post

$request

$post

* @return \Illuminate\Http\Response
*
* @throws \Illuminate\Auth\Access\AuthorizationException
*/
public function update(Request $request, Post $post)
{
$this->authorize('update', [$post, $request->category]);
// The current user can update the blog post...
}

Page 708 of 1307

Laravel 9.x

Email Verification

Introduction
Model Preparation
Database Preparation
Routing
The Email Verification Notice
The Email Verification Handler
Resending The Verification Email
Protecting Routes
Customization
Events

Introduction

Many web applications require users to verify their email addresses before using the application. Rather than forcing you to
re-implement this feature by hand for each application you create, Laravel provides convenient built-in services for
sending and verifying email verification requests.
Want to get started fast? Install one of the Laravel application starter kits in a fresh Laravel
application. The starter kits will take care of scaffolding your entire authentication system,
including email verification support.

Model Preparation

Before getting started, verify that your App\Models\User model implements the
Illuminate\Contracts\Auth\MustVerifyEmail contract:
<?php
namespace App\Models;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable implements MustVerifyEmail
{
use Notifiable;
// ...
}

Once this interface has been added to your model, newly registered users will automatically be sent an email containing an
email verification link. As you can see by examining your application's App\Providers\EventServiceProvider , Laravel
already contains a SendEmailVerificationNotification listener that is attached to the
Illuminate\Auth\Events\Registered event. This event listener will send the email verification link to the user.
If you are manually implementing registration within your application instead of using a starter kit, you should ensure that
you are dispatching the Illuminate\Auth\Events\Registered event after a user's registration is successful:
Page 709 of 1307

Laravel 9.x

use Illuminate\Auth\Events\Registered;
event(new Registered($user));

Database Preparation

Next, your users table must contain an email_verified_at column to store the date and time that the user's email
address was verified. By default, the users table migration included with the Laravel framework already includes this
column. So, all you need to do is run your database migrations:
php artisan migrate

Routing

To properly implement email verification, three routes will need to be defined. First, a route will be needed to display a
notice to the user that they should click the email verification link in the verification email that Laravel sent them after
registration.
Second, a route will be needed to handle requests generated when the user clicks the email verification link in the email.
Third, a route will be needed to resend a verification link if the user accidentally loses the first verification link.

The Email Verification Notice

As mentioned previously, a route should be defined that will return a view instructing the user to click the email verification
link that was emailed to them by Laravel after registration. This view will be displayed to users when they try to access
other parts of the application without verifying their email address first. Remember, the link is automatically emailed to the
user as long as your App\Models\User model implements the MustVerifyEmail interface:
Route::get('/email/verify', function () {
return view('auth.verify-email');
})->middleware('auth')->name('verification.notice');

The route that returns the email verification notice should be named verification.notice . It is important that the
route is assigned this exact name since the verified middleware included with Laravel will automatically redirect to this
route name if a user has not verified their email address.
When manually implementing email verification, you are required to define the contents of the
verification notice view yourself. If you would like scaffolding that includes all necessary
authentication and verification views, check out the Laravel application starter kits.

The Email Verification Handler

Next, we need to define a route that will handle requests generated when the user clicks the email verification link that was
emailed to them. This route should be named verification.verify and be assigned the auth and signed
middlewares:

Page 710 of 1307

Laravel 9.x

use Illuminate\Foundation\Auth\EmailVerificationRequest;
Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {
$request->fulfill();
return redirect('/home');
})->middleware(['auth', 'signed'])->name('verification.verify');

Before moving on, let's take a closer look at this route. First, you'll notice we are using an EmailVerificationRequest
request type instead of the typical Illuminate\Http\Request instance. The EmailVerificationRequest is a form
request that is included with Laravel. This request will automatically take care of validating the request's id and hash
parameters.
Next, we can proceed directly to calling the fulfill method on the request. This method will call the
markEmailAsVerified method on the authenticated user and dispatch the Illuminate\Auth\Events\Verified
event. The markEmailAsVerified method is available to the default App\Models\User model via the
Illuminate\Foundation\Auth\User base class. Once the user's email address has been verified, you may redirect
them wherever you wish.

Resending The Verification Email

Sometimes a user may misplace or accidentally delete the email address verification email. To accommodate this, you may
wish to define a route to allow the user to request that the verification email be resent. You may then make a request to this
route by placing a simple form submission button within your verification notice view:
use Illuminate\Http\Request;
Route::post('/email/verification-notification', function (Request $request) {
$request->user()->sendEmailVerificationNotification();
return back()->with('message', 'Verification link sent!');
})->middleware(['auth', 'throttle:6,1'])->name('verification.send');

Protecting Routes

Route middleware may be used to only allow verified users to access a given route. Laravel ships with a verified
middleware, which references the Illuminate\Auth\Middleware\EnsureEmailIsVerified class. Since this
middleware is already registered in your application's HTTP kernel, all you need to do is attach the middleware to a route
definition. Typically, this middleware is paired with the auth middleware:
Route::get('/profile', function () {
// Only verified users may access this route...
})->middleware(['auth', 'verified']);

If an unverified user attempts to access a route that has been assigned this middleware, they will automatically be
redirected to the verification.notice named route.

Customization

Verification Email Customization
Although the default email verification notification should satisfy the requirements of most applications, Laravel allows you
to customize how the email verification mail message is constructed.

Page 711 of 1307

Laravel 9.x

To get started, pass a closure to the toMailUsing method provided by the
Illuminate\Auth\Notifications\VerifyEmail notification. The closure will receive the notifiable model instance that
is receiving the notification as well as the signed email verification URL that the user must visit to verify their email
address. The closure should return an instance of Illuminate\Notifications\Messages\MailMessage . Typically, you
should call the toMailUsing method from the boot method of your application's
App\Providers\AuthServiceProvider class:
use Illuminate\Auth\Notifications\VerifyEmail;
use Illuminate\Notifications\Messages\MailMessage;
/**
* Register any authentication / authorization services.
*
* @return void
*/
public function boot()
{
// ...
VerifyEmail::toMailUsing(function ($notifiable, $url) {
return (new MailMessage)
->subject('Verify Email Address')
->line('Click the button below to verify your email address.')
->action('Verify Email Address', $url);
});
}

To learn more about mail notifications, please consult the mail notification documentation.

Events

When using the Laravel application starter kits, Laravel dispatches events during the email verification process. If you are
manually handling email verification for your application, you may wish to manually dispatch these events after verification
is completed. You may attach listeners to these events in your application's EventServiceProvider :
use App\Listeners\LogVerifiedUser;
use Illuminate\Auth\Events\Verified;
/**
* The event listener mappings for the application.
*
* @var array
*/
protected $listen = [
Verified::class => [
LogVerifiedUser::class,
],
];

Page 712 of 1307

Laravel 9.x

Introduction
Configuration
Using The Encrypter

Encryption

Introduction

Laravel's encryption services provide a simple, convenient interface for encrypting and decrypting text via OpenSSL using
AES-256 and AES-128 encryption. All of Laravel's encrypted values are signed using a message authentication code
(MAC) so that their underlying value can not be modified or tampered with once encrypted.

Configuration

Before using Laravel's encrypter, you must set the key configuration option in your config/app.php configuration file.
This configuration value is driven by the APP_KEY environment variable. You should use the php artisan
key:generate command to generate this variable's value since the key:generate command will use PHP's secure
random bytes generator to build a cryptographically secure key for your application. Typically, the value of the APP_KEY
environment variable will be generated for you during Laravel's installation.

Using The Encrypter

Encrypting A Value
You may encrypt a value using the encryptString method provided by the Crypt facade. All encrypted values are
encrypted using OpenSSL and the AES-256-CBC cipher. Furthermore, all encrypted values are signed with a message
authentication code (MAC). The integrated message authentication code will prevent the decryption of any values that
have been tampered with by malicious users:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Crypt;
class DigitalOceanTokenController extends Controller
{
/**
* Store a DigitalOcean API token for the user.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function storeSecret(Request $request)
{
$request->user()->fill([
'token' => Crypt::encryptString($request->token),
])->save();
}
}

Page 713 of 1307

Laravel 9.x

Decrypting A Value
You may decrypt values using the decryptString method provided by the Crypt facade. If the value can not be
properly decrypted, such as when the message authentication code is invalid, an
Illuminate\Contracts\Encryption\DecryptException will be thrown:
use Illuminate\Contracts\Encryption\DecryptException;
use Illuminate\Support\Facades\Crypt;
try {
$decrypted = Crypt::decryptString($encryptedValue);
} catch (DecryptException $e) {
//
}

Page 714 of 1307

Laravel 9.x

Hashing
Introduction
Configuration
Basic Usage
Hashing Passwords
Verifying That A Password Matches A Hash
Determining If A Password Needs To Be Rehashed

Introduction

The Laravel Hash facade provides secure Bcrypt and Argon2 hashing for storing user passwords. If you are using one of
the Laravel application starter kits, Bcrypt will be used for registration and authentication by default.
Bcrypt is a great choice for hashing passwords because its "work factor" is adjustable, which means that the time it takes
to generate a hash can be increased as hardware power increases. When hashing passwords, slow is good. The longer an
algorithm takes to hash a password, the longer it takes malicious users to generate "rainbow tables" of all possible string
hash values that may be used in brute force attacks against applications.

Configuration

The default hashing driver for your application is configured in your application's config/hashing.php configuration
file. There are currently several supported drivers: Bcrypt and Argon2 (Argon2i and Argon2id variants).

Basic Usage

Hashing Passwords

You may hash a password by calling the make method on the Hash facade:

Page 715 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
class PasswordController extends Controller
{
/**
* Update the password for the user.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function update(Request $request)
{
// Validate the new password length...
$request->user()->fill([
'password' => Hash::make($request->newPassword)
])->save();
}
}

Adjusting The Bcrypt Work Factor
If you are using the Bcrypt algorithm, the make method allows you to manage the work factor of the algorithm using the
rounds option; however, the default work factor managed by Laravel is acceptable for most applications:
$hashed = Hash::make('password', [
'rounds' => 12,
]);

Adjusting The Argon2 Work Factor
If you are using the Argon2 algorithm, the make method allows you to manage the work factor of the algorithm using the
memory , time , and threads options; however, the default values managed by Laravel are acceptable for most
applications:
$hashed = Hash::make('password', [
'memory' => 1024,
'time' => 2,
'threads' => 2,
]);

For more information on these options, please refer to the official PHP documentation regarding
Argon hashing.

Verifying That A Password Matches A Hash
Page 716 of 1307

Laravel 9.x

The check method provided by the Hash facade allows you to verify that a given plain-text string corresponds to a
given hash:
if (Hash::check('plain-text', $hashedPassword)) {
// The passwords match...
}

Determining If A Password Needs To Be Rehashed

The needsRehash method provided by the Hash facade allows you to determine if the work factor used by the hasher
has changed since the password was hashed. Some applications choose to perform this check during the application's
authentication process:
if (Hash::needsRehash($hashed)) {
$hashed = Hash::make('plain-text');
}

Page 717 of 1307

Laravel 9.x

Resetting Passwords

Introduction
Model Preparation
Database Preparation
Configuring Trusted Hosts
Routing
Requesting The Password Reset Link
Resetting The Password
Deleting Expired Tokens
Customization

Introduction

Most web applications provide a way for users to reset their forgotten passwords. Rather than forcing you to re-implement
this by hand for every application you create, Laravel provides convenient services for sending password reset links and
secure resetting passwords.
Want to get started fast? Install a Laravel application starter kit in a fresh Laravel application.
Laravel's starter kits will take care of scaffolding your entire authentication system, including
resetting forgotten passwords.

Model Preparation

Before using the password reset features of Laravel, your application's App\Models\User model must use the
Illuminate\Notifications\Notifiable trait. Typically, this trait is already included on the default
App\Models\User model that is created with new Laravel applications.
Next, verify that your App\Models\User model implements the Illuminate\Contracts\Auth\CanResetPassword
contract. The App\Models\User model included with the framework already implements this interface, and uses the
Illuminate\Auth\Passwords\CanResetPassword trait to include the methods needed to implement the interface.

Database Preparation

A table must be created to store your application's password reset tokens. The migration for this table is included in the
default Laravel application, so you only need to migrate your database to create this table:
php artisan migrate

Configuring Trusted Hosts

By default, Laravel will respond to all requests it receives regardless of the content of the HTTP request's Host header. In
addition, the Host header's value will be used when generating absolute URLs to your application during a web request.
Typically, you should configure your web server, such as Nginx or Apache, to only send requests to your application that
match a given host name. However, if you do not have the ability to customize your web server directly and need to instruct
Laravel to only respond to certain host names, you may do so by enabling the App\Http\Middleware\TrustHosts
middleware for your application. This is particularly important when your application offers password reset functionality.
To learn more about this middleware, please consult the TrustHosts middleware documentation.

Page 718 of 1307

Laravel 9.x

Routing

To properly implement support for allowing users to reset their passwords, we will need to define several routes. First, we
will need a pair of routes to handle allowing the user to request a password reset link via their email address. Second, we
will need a pair of routes to handle actually resetting the password once the user visits the password reset link that is
emailed to them and completes the password reset form.

Requesting The Password Reset Link

The Password Reset Link Request Form
First, we will define the routes that are needed to request password reset links. To get started, we will define a route that
returns a view with the password reset link request form:
Route::get('/forgot-password', function () {
return view('auth.forgot-password');
})->middleware('guest')->name('password.request');

The view that is returned by this route should have a form containing an email field, which will allow the user to request
a password reset link for a given email address.
Handling The Form Submission
Next, we will define a route that handles the form submission request from the "forgot password" view. This route will be
responsible for validating the email address and sending the password reset request to the corresponding user:
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
Route::post('/forgot-password', function (Request $request) {
$request->validate(['email' => 'required|email']);
$status = Password::sendResetLink(
$request->only('email')
);
return $status === Password::RESET_LINK_SENT
? back()->with(['status' => __($status)])
: back()->withErrors(['email' => __($status)]);
})->middleware('guest')->name('password.email');

Before moving on, let's examine this route in more detail. First, the request's email attribute is validated. Next, we will
use Laravel's built-in "password broker" (via the Password facade) to send a password reset link to the user. The
password broker will take care of retrieving the user by the given field (in this case, the email address) and sending the
user a password reset link via Laravel's built-in notification system.
The sendResetLink method returns a "status" slug. This status may be translated using Laravel's localization helpers in
order to display a user-friendly message to the user regarding the status of their request. The translation of the password
reset status is determined by your application's lang/{lang}/passwords.php language file. An entry for each possible
value of the status slug is located within the passwords language file.
You may be wondering how Laravel knows how to retrieve the user record from your application's database when calling
the Password facade's sendResetLink method. The Laravel password broker utilizes your authentication system's
"user providers" to retrieve database records. The user provider used by the password broker is configured within the
passwords configuration array of your config/auth.php configuration file. To learn more about writing custom user
providers, consult the authentication documentation.
Page 719 of 1307

Laravel 9.x

When manually implementing password resets, you are required to define the contents of the views
and routes yourself. If you would like scaffolding that includes all necessary authentication and
verification logic, check out the Laravel application starter kits.

Resetting The Password

The Password Reset Form
Next, we will define the routes necessary to actually reset the password once the user clicks on the password reset link
that has been emailed to them and provides a new password. First, let's define the route that will display the reset
password form that is displayed when the user clicks the reset password link. This route will receive a token parameter
that we will use later to verify the password reset request:
Route::get('/reset-password/{token}', function ($token) {
return view('auth.reset-password', ['token' => $token]);
})->middleware('guest')->name('password.reset');

The view that is returned by this route should display a form containing an email field, a password field, a
password_confirmation field, and a hidden token field, which should contain the value of the secret $token
received by our route.
Handling The Form Submission
Of course, we need to define a route to actually handle the password reset form submission. This route will be responsible
for validating the incoming request and updating the user's password in the database:

Page 720 of 1307

Laravel 9.x

use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
Route::post('/reset-password', function (Request $request) {
$request->validate([
'token' => 'required',
'email' => 'required|email',
'password' => 'required|min:8|confirmed',
]);
$status = Password::reset(
$request->only('email', 'password', 'password_confirmation', 'token'),
function ($user, $password) {
$user->forceFill([
'password' => Hash::make($password)
])->setRememberToken(Str::random(60));
$user->save();
event(new PasswordReset($user));
}
);
return $status === Password::PASSWORD_RESET
? redirect()->route('login')->with('status', __($status))
: back()->withErrors(['email' => [__($status)]]);
})->middleware('guest')->name('password.update');

Before moving on, let's examine this route in more detail. First, the request's token , email , and password attributes
are validated. Next, we will use Laravel's built-in "password broker" (via the Password facade) to validate the password
reset request credentials.
If the token, email address, and password given to the password broker are valid, the closure passed to the reset
method will be invoked. Within this closure, which receives the user instance and the plain-text password provided to the
password reset form, we may update the user's password in the database.
The reset method returns a "status" slug. This status may be translated using Laravel's localization helpers in order to
display a user-friendly message to the user regarding the status of their request. The translation of the password reset
status is determined by your application's lang/{lang}/passwords.php language file. An entry for each possible value
of the status slug is located within the passwords language file.
Before moving on, you may be wondering how Laravel knows how to retrieve the user record from your application's
database when calling the Password facade's reset method. The Laravel password broker utilizes your authentication
system's "user providers" to retrieve database records. The user provider used by the password broker is configured
within the passwords configuration array of your config/auth.php configuration file. To learn more about writing
custom user providers, consult the authentication documentation.

Deleting Expired Tokens

Password reset tokens that have expired will still be present within your database. However, you may easily delete these
records using the auth:clear-resets Artisan command:

Page 721 of 1307

Laravel 9.x

php artisan auth:clear-resets

If you would like to automate this process, consider adding the command to your application's scheduler:
$schedule->command('auth:clear-resets')->everyFifteenMinutes();

Customization

Reset Link Customization
You may customize the password reset link URL using the createUrlUsing method provided by the ResetPassword
notification class. This method accepts a closure which receives the user instance that is receiving the notification as well
as the password reset link token. Typically, you should call this method from your
App\Providers\AuthServiceProvider service provider's boot method:
use Illuminate\Auth\Notifications\ResetPassword;
/**
* Register any authentication / authorization services.
*
* @return void
*/
public function boot()
{
$this->registerPolicies();
ResetPassword::createUrlUsing(function ($user, string $token) {
return 'https://example.com/reset-password?token='.$token;
});
}

Reset Email Customization
You may easily modify the notification class used to send the password reset link to the user. To get started, override the
sendPasswordResetNotification method on your App\Models\User model. Within this method, you may send the
notification using any notification class of your own creation. The password reset $token is the first argument received
by the method. You may use this $token to build the password reset URL of your choice and send your notification to the
user:
use App\Notifications\ResetPasswordNotification;
/**
* Send a password reset notification to the user.
*
* @param

string

$token

* @return void
*/
public function sendPasswordResetNotification($token)
{
$url = 'https://example.com/reset-password?token='.$token;
$this->notify(new ResetPasswordNotification($url));
}

Page 722 of 1307

Laravel 9.x

Chapter 7

Database

Page 723 of 1307

Laravel 9.x

Database: Getting Started

Introduction
Configuration
Read & Write Connections
Running SQL Queries
Using Multiple Database Connections
Listening For Query Events
Monitoring Cumulative Query Time
Database Transactions
Connecting To The Database CLI
Inspecting Your Databases
Monitoring Your Databases

Introduction

Almost every modern web application interacts with a database. Laravel makes interacting with databases extremely
simple across a variety of supported databases using raw SQL, a fluent query builder, and the Eloquent ORM. Currently,
Laravel provides first-party support for five databases:
MariaDB 10.3+ (Version Policy)
MySQL 5.7+ (Version Policy)
PostgreSQL 10.0+ (Version Policy)
SQLite 3.8.8+
SQL Server 2017+ (Version Policy)

Configuration

The configuration for Laravel's database services is located in your application's config/database.php configuration
file. In this file, you may define all of your database connections, as well as specify which connection should be used by
default. Most of the configuration options within this file are driven by the values of your application's environment
variables. Examples for most of Laravel's supported database systems are provided in this file.
By default, Laravel's sample environment configuration is ready to use with Laravel Sail, which is a Docker configuration for
developing Laravel applications on your local machine. However, you are free to modify your database configuration as
needed for your local database.
SQLite Configuration
SQLite databases are contained within a single file on your filesystem. You can create a new SQLite database using the
touch command in your terminal: touch database/database.sqlite . After the database has been created, you may
easily configure your environment variables to point to this database by placing the absolute path to the database in the
DB_DATABASE environment variable:
DB_CONNECTION=sqlite
DB_DATABASE=/absolute/path/to/database.sqlite

To enable foreign key constraints for SQLite connections, you should set the DB_FOREIGN_KEYS environment variable to
true :
DB_FOREIGN_KEYS=true

Microsoft SQL Server Configuration
Page 724 of 1307

Laravel 9.x

To use a Microsoft SQL Server database, you should ensure that you have the sqlsrv and pdo_sqlsrv PHP extensions
installed as well as any dependencies they may require such as the Microsoft SQL ODBC driver.
Configuration Using URLs
Typically, database connections are configured using multiple configuration values such as host , database ,
username , password , etc. Each of these configuration values has its own corresponding environment variable. This
means that when configuring your database connection information on a production server, you need to manage several
environment variables.
Some managed database providers such as AWS and Heroku provide a single database "URL" that contains all of the
connection information for the database in a single string. An example database URL may look something like the following:
mysql://root:password@127.0.0.1/forge?charset=UTF-8

These URLs typically follow a standard schema convention:
driver://username:password@host:port/database?options

For convenience, Laravel supports these URLs as an alternative to configuring your database with multiple configuration
options. If the url (or corresponding DATABASE_URL environment variable) configuration option is present, it will be
used to extract the database connection and credential information.

Read & Write Connections

Sometimes you may wish to use one database connection for SELECT statements, and another for INSERT, UPDATE, and
DELETE statements. Laravel makes this a breeze, and the proper connections will always be used whether you are using
raw queries, the query builder, or the Eloquent ORM.
To see how read / write connections should be configured, let's look at this example:
'mysql' => [
'read' => [
'host' => [
'192.168.1.1',
'196.168.1.2',
],
],
'write' => [
'host' => [
'196.168.1.3',
],
],
'sticky' => true,
'driver' => 'mysql',
'database' => 'database',
'username' => 'root',
'password' => '',
'charset' => 'utf8mb4',
'collation' => 'utf8mb4_unicode_ci',
'prefix' => '',
],

Note that three keys have been added to the configuration array: read , write and sticky . The read and write
keys have array values containing a single key: host . The rest of the database options for the read and write
connections will be merged from the main mysql configuration array.
Page 725 of 1307

Laravel 9.x

You only need to place items in the read and write arrays if you wish to override the values from the main mysql
array. So, in this case, 192.168.1.1 will be used as the host for the "read" connection, while 192.168.1.3 will be used
for the "write" connection. The database credentials, prefix, character set, and all other options in the main mysql array
will be shared across both connections. When multiple values exist in the host configuration array, a database host will
be randomly chosen for each request.
The sticky Option
The sticky option is an optional value that can be used to allow the immediate reading of records that have been written
to the database during the current request cycle. If the sticky option is enabled and a "write" operation has been
performed against the database during the current request cycle, any further "read" operations will use the "write"
connection. This ensures that any data written during the request cycle can be immediately read back from the database
during that same request. It is up to you to decide if this is the desired behavior for your application.

Running SQL Queries

Once you have configured your database connection, you may run queries using the DB facade. The DB facade provides
methods for each type of query: select , update , insert , delete , and statement .
Running A Select Query
To run a basic SELECT query, you may use the select method on the DB facade:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
class UserController extends Controller
{
/**
* Show a list of all of the application's users.
*
* @return \Illuminate\Http\Response
*/
public function index()
{
$users = DB::select('select * from users where active = ?', [1]);
return view('user.index', ['users' => $users]);
}
}

The first argument passed to the select method is the SQL query, while the second argument is any parameter bindings
that need to be bound to the query. Typically, these are the values of the where clause constraints. Parameter binding
provides protection against SQL injection.
The select method will always return an array of results. Each result within the array will be a PHP stdClass object
representing a record from the database:

Page 726 of 1307

Laravel 9.x

use Illuminate\Support\Facades\DB;
$users = DB::select('select * from users');
foreach ($users as $user) {
echo $user->name;
}

Selecting Scalar Values
Sometimes your database query may result in a single, scalar value. Instead of being required to retrieve the query's scalar
result from a record object, Laravel allows you to retrieve this value directly using the scalar method:
$burgers = DB::scalar(
"select count(case when food = 'burger' then 1 end) as burgers from menu"
);

Using Named Bindings
Instead of using ? to represent your parameter bindings, you may execute a query using named bindings:
$results = DB::select('select * from users where id = :id', ['id' => 1]);

Running An Insert Statement
To execute an insert statement, you may use the insert method on the DB facade. Like select , this method
accepts the SQL query as its first argument and bindings as its second argument:
use Illuminate\Support\Facades\DB;
DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);

Running An Update Statement
The update method should be used to update existing records in the database. The number of rows affected by the
statement is returned by the method:
use Illuminate\Support\Facades\DB;
$affected = DB::update(
'update users set votes = 100 where name = ?',
['Anita']
);

Running A Delete Statement
The delete method should be used to delete records from the database. Like update , the number of rows affected will
be returned by the method:
use Illuminate\Support\Facades\DB;
$deleted = DB::delete('delete from users');

Running A General Statement
Page 727 of 1307

Laravel 9.x

Some database statements do not return any value. For these types of operations, you may use the statement method
on the DB facade:
DB::statement('drop table users');

Running An Unprepared Statement
Sometimes you may want to execute an SQL statement without binding any values. You may use the DB facade's
unprepared method to accomplish this:
DB::unprepared('update users set votes = 100 where name = "Dries"');

Since unprepared statements do not bind parameters, they may be vulnerable to SQL injection. You
should never allow user controlled values within an unprepared statement.
Implicit Commits
When using the DB facade's statement and unprepared methods within transactions you must be careful to avoid
statements that cause implicit commits. These statements will cause the database engine to indirectly commit the entire
transaction, leaving Laravel unaware of the database's transaction level. An example of such a statement is creating a
database table:
DB::unprepared('create table a (col varchar(1) null)');

Please refer to the MySQL manual for a list of all statements that trigger implicit commits.

Using Multiple Database Connections

If your application defines multiple connections in your config/database.php configuration file, you may access each
connection via the connection method provided by the DB facade. The connection name passed to the connection
method should correspond to one of the connections listed in your config/database.php configuration file or
configured at runtime using the config helper:
use Illuminate\Support\Facades\DB;
$users = DB::connection('sqlite')->select(/* ... */);

You may access the raw, underlying PDO instance of a connection using the getPdo method on a connection instance:
$pdo = DB::connection()->getPdo();

Listening For Query Events

If you would like to specify a closure that is invoked for each SQL query executed by your application, you may use the DB
facade's listen method. This method can be useful for logging queries or debugging. You may register your query
listener closure in the boot method of a service provider:

Page 728 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
DB::listen(function ($query) {
// $query->sql;
// $query->bindings;
// $query->time;
});
}
}

Monitoring Cumulative Query Time

A common performance bottleneck of modern web applications is the amount of time they spend querying databases.
Thankfully, Laravel can invoke a closure or callback of your choice when it spends too much time querying the database
during a single request. To get started, provide a query time threshold (in milliseconds) and closure to the
whenQueryingForLongerThan method. You may invoke this method in the boot method of a service provider:

Page 729 of 1307

Laravel 9.x

<?php
namespace App\Providers;
use Illuminate\Database\Connection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
use Illuminate\Database\Events\QueryExecuted;
class AppServiceProvider extends ServiceProvider
{
/**
* Register any application services.
*
* @return void
*/
public function register()
{
//
}
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
DB::whenQueryingForLongerThan(500, function (Connection $connection, QueryExecuted
$event) {
// Notify development team...
});
}
}

Database Transactions

You may use the transaction method provided by the DB facade to run a set of operations within a database
transaction. If an exception is thrown within the transaction closure, the transaction will automatically be rolled back and
the exception is re-thrown. If the closure executes successfully, the transaction will automatically be committed. You don't
need to worry about manually rolling back or committing while using the transaction method:
use Illuminate\Support\Facades\DB;
DB::transaction(function () {
DB::update('update users set votes = 1');
DB::delete('delete from posts');
});

Handling Deadlocks
The transaction method accepts an optional second argument which defines the number of times a transaction should
be retried when a deadlock occurs. Once these attempts have been exhausted, an exception will be thrown:
Page 730 of 1307

Laravel 9.x

use Illuminate\Support\Facades\DB;
DB::transaction(function () {
DB::update('update users set votes = 1');
DB::delete('delete from posts');
}, 5);

Manually Using Transactions
If you would like to begin a transaction manually and have complete control over rollbacks and commits, you may use the
beginTransaction method provided by the DB facade:
use Illuminate\Support\Facades\DB;
DB::beginTransaction();

You can rollback the transaction via the rollBack method:
DB::rollBack();

Lastly, you can commit a transaction via the commit method:
DB::commit();

The DB facade's transaction methods control the transactions for both the query builder and
Eloquent ORM.

Connecting To The Database CLI

If you would like to connect to your database's CLI, you may use the db Artisan command:
php artisan db

If needed, you may specify a database connection name to connect to a database connection that is not the default
connection:
php artisan db mysql

Inspecting Your Databases

Using the db:show and db:table Artisan commands, you can get valuable insight into your database and its
associated tables. To see an overview of your database, including its size, type, number of open connections, and a
summary of its tables, you may use the db:show command:
php artisan db:show

Page 731 of 1307

Laravel 9.x

You may specify which database connection should be inspected by providing the database connection name to the
command via the --database option:
php artisan db:show --database=pgsql

If you would like to include table row counts and database view details within the output of the command, you may provide
the --counts and --views options, respectively. On large databases, retrieving row counts and view details can be
slow:
php artisan db:show --counts --views

Table Overview
If you would like to get an overview of an individual table within your database, you may execute the db:table Artisan
command. This command provides a general overview of a database table, including its columns, types, attributes, keys,
and indexes:
php artisan db:table users

Monitoring Your Databases

Using the db:monitor Artisan command, you can instruct Laravel to dispatch an
Illuminate\Database\Events\DatabaseBusy event if your database is managing more than a specified number of
open connections.
To get started, you should schedule the db:monitor command to run every minute. The command accepts the names of
the database connection configurations that you wish to monitor as well as the maximum number of open connections that
should be tolerated before dispatching an event:
php artisan db:monitor --databases=mysql,pgsql --max=100

Scheduling this command alone is not enough to trigger a notification alerting you of the number of open connections.
When the command encounters a database that has an open connection count that exceeds your threshold, a
DatabaseBusy event will be dispatched. You should listen for this event within your application's
EventServiceProvider in order to send a notification to you or your development team:

Page 732 of 1307

Laravel 9.x

use App\Notifications\DatabaseApproachingMaxConnections;
use Illuminate\Database\Events\DatabaseBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;
/**
* Register any other events for your application.
*
* @return void
*/
public function boot()
{
Event::listen(function (DatabaseBusy $event) {
Notification::route('mail', 'dev@example.com')
->notify(new DatabaseApproachingMaxConnections(
$event->connectionName,
$event->connections
));
});
}

Page 733 of 1307

Laravel 9.x

Database: Query Builder

Introduction
Running Database Queries
Chunking Results
Streaming Results Lazily
Aggregates
Select Statements
Raw Expressions
Joins
Unions
Basic Where Clauses
Where Clauses
Or Where Clauses
Where Not Clauses
JSON Where Clauses
Additional Where Clauses
Logical Grouping
Advanced Where Clauses
Where Exists Clauses
Subquery Where Clauses
Full Text Where Clauses
Ordering, Grouping, Limit & Offset
Ordering
Grouping
Limit & Offset
Conditional Clauses
Insert Statements
Upserts
Update Statements
Updating JSON Columns
Increment & Decrement
Delete Statements
Pessimistic Locking
Debugging

Introduction

Laravel's database query builder provides a convenient, fluent interface to creating and running database queries. It can be
used to perform most database operations in your application and works perfectly with all of Laravel's supported database
systems.
The Laravel query builder uses PDO parameter binding to protect your application against SQL injection attacks. There is
no need to clean or sanitize strings passed to the query builder as query bindings.
PDO does not support binding column names. Therefore, you should never allow user input to
dictate the column names referenced by your queries, including "order by" columns.

Page 734 of 1307

Laravel 9.x

Running Database Queries

Retrieving All Rows From A Table
You may use the table method provided by the DB facade to begin a query. The table method returns a fluent query
builder instance for the given table, allowing you to chain more constraints onto the query and then finally retrieve the
results of the query using the get method:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
class UserController extends Controller
{
/**
* Show a list of all of the application's users.
*
* @return \Illuminate\Http\Response
*/
public function index()
{
$users = DB::table('users')->get();
return view('user.index', ['users' => $users]);
}
}

The get method returns an Illuminate\Support\Collection instance containing the results of the query where
each result is an instance of the PHP stdClass object. You may access each column's value by accessing the column as
a property of the object:
use Illuminate\Support\Facades\DB;
$users = DB::table('users')->get();
foreach ($users as $user) {
echo $user->name;
}

Laravel collections provide a variety of extremely powerful methods for mapping and reducing data.
For more information on Laravel collections, check out the collection documentation.
Retrieving A Single Row / Column From A Table
If you just need to retrieve a single row from a database table, you may use the DB facade's first method. This
method will return a single stdClass object:

Page 735 of 1307

Laravel 9.x

$user = DB::table('users')->where('name', 'John')->first();
return $user->email;

If you don't need an entire row, you may extract a single value from a record using the value method. This method will
return the value of the column directly:
$email = DB::table('users')->where('name', 'John')->value('email');

To retrieve a single row by its id column value, use the find method:
$user = DB::table('users')->find(3);

Retrieving A List Of Column Values
If you would like to retrieve an Illuminate\Support\Collection instance containing the values of a single column, you
may use the pluck method. In this example, we'll retrieve a collection of user titles:
use Illuminate\Support\Facades\DB;
$titles = DB::table('users')->pluck('title');
foreach ($titles as $title) {
echo $title;
}

You may specify the column that the resulting collection should use as its keys by providing a second argument to the
pluck method:
$titles = DB::table('users')->pluck('title', 'name');
foreach ($titles as $name => $title) {
echo $title;
}

Chunking Results

If you need to work with thousands of database records, consider using the chunk method provided by the DB facade.
This method retrieves a small chunk of results at a time and feeds each chunk into a closure for processing. For example,
let's retrieve the entire users table in chunks of 100 records at a time:
use Illuminate\Support\Facades\DB;
DB::table('users')->orderBy('id')->chunk(100, function ($users) {
foreach ($users as $user) {
//
}
});

You may stop further chunks from being processed by returning false from the closure:

Page 736 of 1307

Laravel 9.x

DB::table('users')->orderBy('id')->chunk(100, function ($users) {
// Process the records...
return false;
});

If you are updating database records while chunking results, your chunk results could change in unexpected ways. If you
plan to update the retrieved records while chunking, it is always best to use the chunkById method instead. This method
will automatically paginate the results based on the record's primary key:
DB::table('users')->where('active', false)
->chunkById(100, function ($users) {
foreach ($users as $user) {
DB::table('users')
->where('id', $user->id)
->update(['active' => true]);
}
});

When updating or deleting records inside the chunk callback, any changes to the primary key or
foreign keys could affect the chunk query. This could potentially result in records not being
included in the chunked results.

Streaming Results Lazily

The lazy method works similarly to the chunk method in the sense that it executes the query in chunks. However,
instead of passing each chunk into a callback, the lazy() method returns a LazyCollection , which lets you interact
with the results as a single stream:
use Illuminate\Support\Facades\DB;
DB::table('users')->orderBy('id')->lazy()->each(function ($user) {
//
});

Once again, if you plan to update the retrieved records while iterating over them, it is best to use the lazyById or
lazyByIdDesc methods instead. These methods will automatically paginate the results based on the record's primary
key:
DB::table('users')->where('active', false)
->lazyById()->each(function ($user) {
DB::table('users')
->where('id', $user->id)
->update(['active' => true]);
});

Page 737 of 1307

Laravel 9.x

When updating or deleting records while iterating over them, any changes to the primary key or
foreign keys could affect the chunk query. This could potentially result in records not being
included in the results.

Aggregates

The query builder also provides a variety of methods for retrieving aggregate values like count , max , min , avg , and
sum . You may call any of these methods after constructing your query:
use Illuminate\Support\Facades\DB;
$users = DB::table('users')->count();
$price = DB::table('orders')->max('price');

Of course, you may combine these methods with other clauses to fine-tune how your aggregate value is calculated:
$price = DB::table('orders')
->where('finalized', 1)
->avg('price');

Determining If Records Exist
Instead of using the count method to determine if any records exist that match your query's constraints, you may use
the exists and doesntExist methods:
if (DB::table('orders')->where('finalized', 1)->exists()) {
// ...
}
if (DB::table('orders')->where('finalized', 1)->doesntExist()) {
// ...
}

Select Statements

Specifying A Select Clause
You may not always want to select all columns from a database table. Using the select method, you can specify a
custom "select" clause for the query:
use Illuminate\Support\Facades\DB;
$users = DB::table('users')
->select('name', 'email as user_email')
->get();

The distinct method allows you to force the query to return distinct results:
$users = DB::table('users')->distinct()->get();

Page 738 of 1307

Laravel 9.x

If you already have a query builder instance and you wish to add a column to its existing select clause, you may use the
addSelect method:
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();

Raw Expressions

Sometimes you may need to insert an arbitrary string into a query. To create a raw string expression, you may use the
raw method provided by the DB facade:
$users = DB::table('users')
->select(DB::raw('count(*) as user_count, status'))
->where('status', '<>', 1)
->groupBy('status')
->get();

Raw statements will be injected into the query as strings, so you should be extremely careful to
avoid creating SQL injection vulnerabilities.

Raw Methods

Instead of using the DB::raw method, you may also use the following methods to insert a raw expression into various
parts of your query. Remember, Laravel can not guarantee that any query using raw expressions is protected against
SQL injection vulnerabilities.
selectRaw

The selectRaw method can be used in place of addSelect(DB::raw(/* ... */)) . This method accepts an optional
array of bindings as its second argument:
$orders = DB::table('orders')
->selectRaw('price * ? as price_with_tax', [1.0825])
->get();

whereRaw / orWhereRaw

The whereRaw and orWhereRaw methods can be used to inject a raw "where" clause into your query. These methods
accept an optional array of bindings as their second argument:
$orders = DB::table('orders')
->whereRaw('price > IF(state = "TX", ?, 100)', [200])
->get();

havingRaw / orHavingRaw

The havingRaw and orHavingRaw methods may be used to provide a raw string as the value of the "having" clause.
These methods accept an optional array of bindings as their second argument:

Page 739 of 1307

Laravel 9.x

$orders = DB::table('orders')
->select('department', DB::raw('SUM(price) as total_sales'))
->groupBy('department')
->havingRaw('SUM(price) > ?', [2500])
->get();

orderByRaw

The orderByRaw method may be used to provide a raw string as the value of the "order by" clause:
$orders = DB::table('orders')
->orderByRaw('updated_at - created_at DESC')
->get();

groupByRaw

The groupByRaw method may be used to provide a raw string as the value of the group by clause:
$orders = DB::table('orders')
->select('city', 'state')
->groupByRaw('city, state')
->get();

Joins

Inner Join Clause
The query builder may also be used to add join clauses to your queries. To perform a basic "inner join", you may use the
join method on a query builder instance. The first argument passed to the join method is the name of the table you
need to join to, while the remaining arguments specify the column constraints for the join. You may even join multiple
tables in a single query:
use Illuminate\Support\Facades\DB;
$users = DB::table('users')
->join('contacts', 'users.id', '=', 'contacts.user_id')
->join('orders', 'users.id', '=', 'orders.user_id')
->select('users.*', 'contacts.phone', 'orders.price')
->get();

Left Join / Right Join Clause
If you would like to perform a "left join" or "right join" instead of an "inner join", use the leftJoin or rightJoin
methods. These methods have the same signature as the join method:
$users = DB::table('users')
->leftJoin('posts', 'users.id', '=', 'posts.user_id')
->get();
$users = DB::table('users')
->rightJoin('posts', 'users.id', '=', 'posts.user_id')
->get();

Page 740 of 1307

Laravel 9.x

Cross Join Clause
You may use the crossJoin method to perform a "cross join". Cross joins generate a cartesian product between the first
table and the joined table:
$sizes = DB::table('sizes')
->crossJoin('colors')
->get();

Advanced Join Clauses
You may also specify more advanced join clauses. To get started, pass a closure as the second argument to the join
method. The closure will receive a Illuminate\Database\Query\JoinClause instance which allows you to specify
constraints on the "join" clause:
DB::table('users')
->join('contacts', function ($join) {
$join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);
})
->get();

If you would like to use a "where" clause on your joins, you may use the where and orWhere methods provided by the
JoinClause instance. Instead of comparing two columns, these methods will compare the column against a value:
DB::table('users')
->join('contacts', function ($join) {
$join->on('users.id', '=', 'contacts.user_id')
->where('contacts.user_id', '>', 5);
})
->get();

Subquery Joins
You may use the joinSub , leftJoinSub , and rightJoinSub methods to join a query to a subquery. Each of these
methods receives three arguments: the subquery, its table alias, and a closure that defines the related columns. In this
example, we will retrieve a collection of users where each user record also contains the created_at timestamp of the
user's most recently published blog post:
$latestPosts = DB::table('posts')
->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
->where('is_published', true)
->groupBy('user_id');
$users = DB::table('users')
->joinSub($latestPosts, 'latest_posts', function ($join) {
$join->on('users.id', '=', 'latest_posts.user_id');
})->get();

Unions

The query builder also provides a convenient method to "union" two or more queries together. For example, you may
create an initial query and use the union method to union it with more queries:

Page 741 of 1307

Laravel 9.x

use Illuminate\Support\Facades\DB;
$first = DB::table('users')
->whereNull('first_name');
$users = DB::table('users')
->whereNull('last_name')
->union($first)
->get();

In addition to the union method, the query builder provides a unionAll method. Queries that are combined using the
unionAll method will not have their duplicate results removed. The unionAll method has the same method signature
as the union method.

Basic Where Clauses
Where Clauses

You may use the query builder's where method to add "where" clauses to the query. The most basic call to the where
method requires three arguments. The first argument is the name of the column. The second argument is an operator,
which can be any of the database's supported operators. The third argument is the value to compare against the column's
value.
For example, the following query retrieves users where the value of the votes column is equal to 100 and the value of
the age column is greater than 35 :
$users = DB::table('users')
->where('votes', '=', 100)
->where('age', '>', 35)
->get();

For convenience, if you want to verify that a column is = to a given value, you may pass the value as the second argument
to the where method. Laravel will assume you would like to use the = operator:
$users = DB::table('users')->where('votes', 100)->get();

As previously mentioned, you may use any operator that is supported by your database system:
$users = DB::table('users')
->where('votes', '>=', 100)
->get();
$users = DB::table('users')
->where('votes', '<>', 100)
->get();
$users = DB::table('users')
->where('name', 'like', 'T%')
->get();

You may also pass an array of conditions to the where function. Each element of the array should be an array containing
the three arguments typically passed to the where method:

Page 742 of 1307

Laravel 9.x

$users = DB::table('users')->where([
['status', '=', '1'],
['subscribed', '<>', '1'],
])->get();

PDO does not support binding column names. Therefore, you should never allow user input to
dictate the column names referenced by your queries, including "order by" columns.

Or Where Clauses

When chaining together calls to the query builder's where method, the "where" clauses will be joined together using the
and operator. However, you may use the orWhere method to join a clause to the query using the or operator. The
orWhere method accepts the same arguments as the where method:
$users = DB::table('users')
->where('votes', '>', 100)
->orWhere('name', 'John')
->get();

If you need to group an "or" condition within parentheses, you may pass a closure as the first argument to the orWhere
method:
$users = DB::table('users')
->where('votes', '>', 100)
->orWhere(function($query) {
$query->where('name', 'Abigail')
->where('votes', '>', 50);
})
->get();

The example above will produce the following SQL:
select * from users where votes > 100 or (name = 'Abigail' and votes > 50)

You should always group orWhere calls in order to avoid unexpected behavior when global
scopes are applied.

Where Not Clauses

The whereNot and orWhereNot methods may be used to negate a given group of query constraints. For example, the
following query excludes products that are on clearance or which have a price that is less than ten:

Page 743 of 1307

Laravel 9.x

$products = DB::table('products')
->whereNot(function ($query) {
$query->where('clearance', true)
->orWhere('price', '<', 10);
})
->get();

JSON Where Clauses

Laravel also supports querying JSON column types on databases that provide support for JSON column types. Currently,
this includes MySQL 5.7+, PostgreSQL, SQL Server 2016, and SQLite 3.39.0 (with the JSON1 extension). To query a JSON
column, use the -> operator:
$users = DB::table('users')
->where('preferences->dining->meal', 'salad')
->get();

You may use whereJsonContains to query JSON arrays. This feature is not supported by SQLite database versions less
than 3.38.0:
$users = DB::table('users')
->whereJsonContains('options->languages', 'en')
->get();

If your application uses the MySQL or PostgreSQL databases, you may pass an array of values to the
whereJsonContains method:
$users = DB::table('users')
->whereJsonContains('options->languages', ['en', 'de'])
->get();

You may use whereJsonLength method to query JSON arrays by their length:
$users = DB::table('users')
->whereJsonLength('options->languages', 0)
->get();
$users = DB::table('users')
->whereJsonLength('options->languages', '>', 1)
->get();

Additional Where Clauses

whereBetween / orWhereBetween
The whereBetween method verifies that a column's value is between two values:
$users = DB::table('users')
->whereBetween('votes', [1, 100])
->get();

whereNotBetween / orWhereNotBetween

Page 744 of 1307

Laravel 9.x

The whereNotBetween method verifies that a column's value lies outside of two values:
$users = DB::table('users')
->whereNotBetween('votes', [1, 100])
->get();

whereBetweenColumns / whereNotBetweenColumns / orWhereBetweenColumns / orWhereNotBetweenColumns
The whereBetweenColumns method verifies that a column's value is between the two values of two columns in the same
table row:
$patients = DB::table('patients')
->whereBetweenColumns('weight', ['minimum_allowed_weight',
'maximum_allowed_weight'])
->get();

The whereNotBetweenColumns method verifies that a column's value lies outside the two values of two columns in the
same table row:
$patients = DB::table('patients')
->whereNotBetweenColumns('weight', ['minimum_allowed_weight',
'maximum_allowed_weight'])
->get();

whereIn / whereNotIn / orWhereIn / orWhereNotIn
The whereIn method verifies that a given column's value is contained within the given array:
$users = DB::table('users')
->whereIn('id', [1, 2, 3])
->get();

The whereNotIn method verifies that the given column's value is not contained in the given array:
$users = DB::table('users')
->whereNotIn('id', [1, 2, 3])
->get();

You may also provide a query object as the whereIn method's second argument:
$activeUsers = DB::table('users')->select('id')->where('is_active', 1);
$users = DB::table('comments')
->whereIn('user_id', $activeUsers)
->get();

The example above will produce the following SQL:

Page 745 of 1307

Laravel 9.x

select * from comments where user_id in (
select id
from users
where is_active = 1
)

If you are adding a large array of integer bindings to your query, the whereIntegerInRaw or
whereIntegerNotInRaw methods may be used to greatly reduce your memory usage.
whereNull / whereNotNull / orWhereNull / orWhereNotNull
The whereNull method verifies that the value of the given column is NULL :
$users = DB::table('users')
->whereNull('updated_at')
->get();

The whereNotNull method verifies that the column's value is not NULL :
$users = DB::table('users')
->whereNotNull('updated_at')
->get();

whereDate / whereMonth / whereDay / whereYear / whereTime
The whereDate method may be used to compare a column's value against a date:
$users = DB::table('users')
->whereDate('created_at', '2016-12-31')
->get();

The whereMonth method may be used to compare a column's value against a specific month:
$users = DB::table('users')
->whereMonth('created_at', '12')
->get();

The whereDay method may be used to compare a column's value against a specific day of the month:
$users = DB::table('users')
->whereDay('created_at', '31')
->get();

The whereYear method may be used to compare a column's value against a specific year:
$users = DB::table('users')
->whereYear('created_at', '2016')
->get();

Page 746 of 1307

Laravel 9.x

The whereTime method may be used to compare a column's value against a specific time:
$users = DB::table('users')
->whereTime('created_at', '=', '11:20:45')
->get();

whereColumn / orWhereColumn
The whereColumn method may be used to verify that two columns are equal:
$users = DB::table('users')
->whereColumn('first_name', 'last_name')
->get();

You may also pass a comparison operator to the whereColumn method:
$users = DB::table('users')
->whereColumn('updated_at', '>', 'created_at')
->get();

You may also pass an array of column comparisons to the whereColumn method. These conditions will be joined using
the and operator:
$users = DB::table('users')
->whereColumn([
['first_name', '=', 'last_name'],
['updated_at', '>', 'created_at'],
])->get();

Logical Grouping

Sometimes you may need to group several "where" clauses within parentheses in order to achieve your query's desired
logical grouping. In fact, you should generally always group calls to the orWhere method in parentheses in order to avoid
unexpected query behavior. To accomplish this, you may pass a closure to the where method:
$users = DB::table('users')
->where('name', '=', 'John')
->where(function ($query) {
$query->where('votes', '>', 100)
->orWhere('title', '=', 'Admin');
})
->get();

As you can see, passing a closure into the where method instructs the query builder to begin a constraint group. The
closure will receive a query builder instance which you can use to set the constraints that should be contained within the
parenthesis group. The example above will produce the following SQL:
select * from users where name = 'John' and (votes > 100 or title = 'Admin')

Page 747 of 1307

Laravel 9.x

You should always group orWhere calls in order to avoid unexpected behavior when global
scopes are applied.

Advanced Where Clauses
Where Exists Clauses

The whereExists method allows you to write "where exists" SQL clauses. The whereExists method accepts a closure
which will receive a query builder instance, allowing you to define the query that should be placed inside of the "exists"
clause:
$users = DB::table('users')
->whereExists(function ($query) {
$query->select(DB::raw(1))
->from('orders')
->whereColumn('orders.user_id', 'users.id');
})
->get();

The query above will produce the following SQL:
select * from users
where exists (
select 1
from orders
where orders.user_id = users.id
)

Subquery Where Clauses

Sometimes you may need to construct a "where" clause that compares the results of a subquery to a given value. You may
accomplish this by passing a closure and a value to the where method. For example, the following query will retrieve all
users who have a recent "membership" of a given type;
use App\Models\User;
$users = User::where(function ($query) {
$query->select('type')
->from('membership')
->whereColumn('membership.user_id', 'users.id')
->orderByDesc('membership.start_date')
->limit(1);
}, 'Pro')->get();

Or, you may need to construct a "where" clause that compares a column to the results of a subquery. You may accomplish
this by passing a column, operator, and closure to the where method. For example, the following query will retrieve all
income records where the amount is less than average;

Page 748 of 1307

Laravel 9.x

use App\Models\Income;
$incomes = Income::where('amount', '<', function ($query) {
$query->selectRaw('avg(i.amount)')->from('incomes as i');
})->get();

Full Text Where Clauses
Full text where clauses are currently supported by MySQL and PostgreSQL.
The whereFullText and orWhereFullText methods may be used to add full text "where" clauses to a query for
columns that have full text indexes. These methods will be transformed into the appropriate SQL for the underlying
database system by Laravel. For example, a MATCH AGAINST clause will be generated for applications utilizing MySQL:
$users = DB::table('users')
->whereFullText('bio', 'web developer')
->get();

Ordering, Grouping, Limit & Offset
Ordering

The orderBy Method
The orderBy method allows you to sort the results of the query by a given column. The first argument accepted by the
orderBy method should be the column you wish to sort by, while the second argument determines the direction of the
sort and may be either asc or desc :
$users = DB::table('users')
->orderBy('name', 'desc')
->get();

To sort by multiple columns, you may simply invoke orderBy as many times as necessary:
$users = DB::table('users')
->orderBy('name', 'desc')
->orderBy('email', 'asc')
->get();

The latest & oldest Methods
The latest and oldest methods allow you to easily order results by date. By default, the result will be ordered by the
table's created_at column. Or, you may pass the column name that you wish to sort by:
$user = DB::table('users')
->latest()
->first();

Random Ordering
Page 749 of 1307

Laravel 9.x

The inRandomOrder method may be used to sort the query results randomly. For example, you may use this method to
fetch a random user:
$randomUser = DB::table('users')
->inRandomOrder()
->first();

Removing Existing Orderings
The reorder method removes all of the "order by" clauses that have previously been applied to the query:
$query = DB::table('users')->orderBy('name');
$unorderedUsers = $query->reorder()->get();

You may pass a column and direction when calling the reorder method in order to remove all existing "order by" clauses
and apply an entirely new order to the query:
$query = DB::table('users')->orderBy('name');
$usersOrderedByEmail = $query->reorder('email', 'desc')->get();

Grouping

The groupBy & having Methods
As you might expect, the groupBy and having methods may be used to group the query results. The having
method's signature is similar to that of the where method:
$users = DB::table('users')
->groupBy('account_id')
->having('account_id', '>', 100)
->get();

You can use the havingBetween method to filter the results within a given range:
$report = DB::table('orders')
->selectRaw('count(id) as number_of_orders, customer_id')
->groupBy('customer_id')
->havingBetween('number_of_orders', [5, 15])
->get();

You may pass multiple arguments to the groupBy method to group by multiple columns:
$users = DB::table('users')
->groupBy('first_name', 'status')
->having('account_id', '>', 100)
->get();

To build more advanced having statements, see the havingRaw method.

Limit & Offset

The skip & take Methods
Page 750 of 1307

Laravel 9.x

You may use the skip and take methods to limit the number of results returned from the query or to skip a given
number of results in the query:
$users = DB::table('users')->skip(10)->take(5)->get();

Alternatively, you may use the limit and offset methods. These methods are functionally equivalent to the take
and skip methods, respectively:
$users = DB::table('users')
->offset(10)
->limit(5)
->get();

Conditional Clauses

Sometimes you may want certain query clauses to apply to a query based on another condition. For instance, you may only
want to apply a where statement if a given input value is present on the incoming HTTP request. You may accomplish this
using the when method:
$role = $request->input('role');
$users = DB::table('users')
->when($role, function ($query, $role) {
$query->where('role_id', $role);
})
->get();

The when method only executes the given closure when the first argument is true . If the first argument is false , the
closure will not be executed. So, in the example above, the closure given to the when method will only be invoked if the
role field is present on the incoming request and evaluates to true .
You may pass another closure as the third argument to the when method. This closure will only execute if the first
argument evaluates as false . To illustrate how this feature may be used, we will use it to configure the default ordering
of a query:
$sortByVotes = $request->input('sort_by_votes');
$users = DB::table('users')
->when($sortByVotes, function ($query, $sortByVotes) {
$query->orderBy('votes');
}, function ($query) {
$query->orderBy('name');
})
->get();

Insert Statements

The query builder also provides an insert method that may be used to insert records into the database table. The
insert method accepts an array of column names and values:

Page 751 of 1307

Laravel 9.x

DB::table('users')->insert([
'email' => 'kayla@example.com',
'votes' => 0
]);

You may insert several records at once by passing an array of arrays. Each array represents a record that should be
inserted into the table:
DB::table('users')->insert([
['email' => 'picard@example.com', 'votes' => 0],
['email' => 'janeway@example.com', 'votes' => 0],
]);

The insertOrIgnore method will ignore errors while inserting records into the database. When using this method, you
should be aware that duplicate record errors will be ignored and other types of errors may also be ignored depending on
the database engine. For example, insertOrIgnore will bypass MySQL's strict mode:
DB::table('users')->insertOrIgnore([
['id' => 1, 'email' => 'sisko@example.com'],
['id' => 2, 'email' => 'archer@example.com'],
]);

The insertUsing method will insert new records into the table while using a subquery to determine the data that should
be inserted:
DB::table('pruned_users')->insertUsing([
'id', 'name', 'email', 'email_verified_at'
], DB::table('users')->select(
'id', 'name', 'email', 'email_verified_at'
)->where('updated_at', '<=', now()->subMonth()));

Auto-Incrementing IDs
If the table has an auto-incrementing id, use the insertGetId method to insert a record and then retrieve the ID:
$id = DB::table('users')->insertGetId(
['email' => 'john@example.com', 'votes' => 0]
);

When using PostgreSQL the insertGetId method expects the auto-incrementing column to be
named id . If you would like to retrieve the ID from a different "sequence", you may pass the
column name as the second parameter to the insertGetId method.

Upserts

The upsert method will insert records that do not exist and update the records that already exist with new values that
you may specify. The method's first argument consists of the values to insert or update, while the second argument lists
the column(s) that uniquely identify records within the associated table. The method's third and final argument is an array
of columns that should be updated if a matching record already exists in the database:

Page 752 of 1307

Laravel 9.x

DB::table('flights')->upsert(
[
['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
],
['departure', 'destination'],
['price']
);

In the example above, Laravel will attempt to insert two records. If a record already exists with the same departure and
destination column values, Laravel will update that record's price column.
All databases except SQL Server require the columns in the second argument of the upsert
method to have a "primary" or "unique" index. In addition, the MySQL database driver ignores the
second argument of the upsert method and always uses the "primary" and "unique" indexes of
the table to detect existing records.

Update Statements

In addition to inserting records into the database, the query builder can also update existing records using the update
method. The update method, like the insert method, accepts an array of column and value pairs indicating the
columns to be updated. The update method returns the number of affected rows. You may constrain the update query
using where clauses:
$affected = DB::table('users')
->where('id', 1)
->update(['votes' => 1]);

Update Or Insert
Sometimes you may want to update an existing record in the database or create it if no matching record exists. In this
scenario, the updateOrInsert method may be used. The updateOrInsert method accepts two arguments: an array of
conditions by which to find the record, and an array of column and value pairs indicating the columns to be updated.
The updateOrInsert method will attempt to locate a matching database record using the first argument's column and
value pairs. If the record exists, it will be updated with the values in the second argument. If the record can not be found, a
new record will be inserted with the merged attributes of both arguments:
DB::table('users')
->updateOrInsert(
['email' => 'john@example.com', 'name' => 'John'],
['votes' => '2']
);

Updating JSON Columns

When updating a JSON column, you should use -> syntax to update the appropriate key in the JSON object. This
operation is supported on MySQL 5.7+ and PostgreSQL 9.5+:

Page 753 of 1307

Laravel 9.x

$affected = DB::table('users')
->where('id', 1)
->update(['options->enabled' => true]);

Increment & Decrement

The query builder also provides convenient methods for incrementing or decrementing the value of a given column. Both of
these methods accept at least one argument: the column to modify. A second argument may be provided to specify the
amount by which the column should be incremented or decremented:
DB::table('users')->increment('votes');
DB::table('users')->increment('votes', 5);
DB::table('users')->decrement('votes');
DB::table('users')->decrement('votes', 5);

If needed, you may also specify additional columns to update during the increment or decrement operation:
DB::table('users')->increment('votes', 1, ['name' => 'John']);

In addition, you may increment or decrement multiple columns at once using the incrementEach and decrementEach
methods:
DB::table('users')->incrementEach([
'votes' => 5,
'balance' => 100,
]);

Delete Statements

The query builder's delete method may be used to delete records from the table. The delete method returns the
number of affected rows. You may constrain delete statements by adding "where" clauses before calling the delete
method:
$deleted = DB::table('users')->delete();
$deleted = DB::table('users')->where('votes', '>', 100)->delete();

If you wish to truncate an entire table, which will remove all records from the table and reset the auto-incrementing ID to
zero, you may use the truncate method:
DB::table('users')->truncate();

Table Truncation & PostgreSQL
When truncating a PostgreSQL database, the CASCADE behavior will be applied. This means that all foreign key related
records in other tables will be deleted as well.

Pessimistic Locking
Page 754 of 1307

Laravel 9.x

The query builder also includes a few functions to help you achieve "pessimistic locking" when executing your select
statements. To execute a statement with a "shared lock", you may call the sharedLock method. A shared lock prevents
the selected rows from being modified until your transaction is committed:
DB::table('users')
->where('votes', '>', 100)
->sharedLock()
->get();

Alternatively, you may use the lockForUpdate method. A "for update" lock prevents the selected records from being
modified or from being selected with another shared lock:
DB::table('users')
->where('votes', '>', 100)
->lockForUpdate()
->get();

Debugging

You may use the dd and dump methods while building a query to dump the current query bindings and SQL. The dd
method will display the debug information and then stop executing the request. The dump method will display the debug
information but allow the request to continue executing:
DB::table('users')->where('votes', '>', 100)->dd();
DB::table('users')->where('votes', '>', 100)->dump();

Page 755 of 1307

Laravel 9.x

Database: Pagination

Introduction
Basic Usage
Paginating Query Builder Results
Paginating Eloquent Results
Cursor Pagination
Manually Creating A Paginator
Customizing Pagination URLs
Displaying Pagination Results
Adjusting The Pagination Link Window
Converting Results To JSON
Customizing The Pagination View
Using Bootstrap
Paginator and LengthAwarePaginator Instance Methods
Cursor Paginator Instance Methods

Introduction

In other frameworks, pagination can be very painful. We hope Laravel's approach to pagination will be a breath of fresh air.
Laravel's paginator is integrated with the query builder and Eloquent ORM and provides convenient, easy-to-use
pagination of database records with zero configuration.
By default, the HTML generated by the paginator is compatible with the Tailwind CSS framework; however, Bootstrap
pagination support is also available.
Tailwind JIT
If you are using Laravel's default Tailwind pagination views and the Tailwind JIT engine, you should ensure your
application's tailwind.config.js file's content key references Laravel's pagination views so that their Tailwind
classes are not purged:
content: [
'./resources/**/*.blade.php',
'./resources/**/*.js',
'./resources/**/*.vue',
'./vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php',
],

Basic Usage

Paginating Query Builder Results

There are several ways to paginate items. The simplest is by using the paginate method on the query builder or an
Eloquent query. The paginate method automatically takes care of setting the query's "limit" and "offset" based on the
current page being viewed by the user. By default, the current page is detected by the value of the page query string
argument on the HTTP request. This value is automatically detected by Laravel, and is also automatically inserted into links
generated by the paginator.
In this example, the only argument passed to the paginate method is the number of items you would like displayed "per
page". In this case, let's specify that we would like to display 15 items per page:

Page 756 of 1307

Laravel 9.x

<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
class UserController extends Controller
{
/**
* Show all application users.
*
* @return \Illuminate\Http\Response
*/
public function index()
{
return view('user.index', [
'users' => DB::table('users')->paginate(15)
]);
}
}

Simple Pagination
The paginate method counts the total number of records matched by the query before retrieving the records from the
database. This is done so that the paginator knows how many pages of records there are in total. However, if you do not
plan to show the total number of pages in your application's UI then the record count query is unnecessary.
Therefore, if you only need to display simple "Next" and "Previous" links in your application's UI, you may use the
simplePaginate method to perform a single, efficient query:
$users = DB::table('users')->simplePaginate(15);

Paginating Eloquent Results

You may also paginate Eloquent queries. In this example, we will paginate the App\Models\User model and indicate that
we plan to display 15 records per page. As you can see, the syntax is nearly identical to paginating query builder results:
use App\Models\User;
$users = User::paginate(15);

Of course, you may call the paginate method after setting other constraints on the query, such as where clauses:
$users = User::where('votes', '>', 100)->paginate(15);

You may also use the simplePaginate method when paginating Eloquent models:
$users = User::where('votes', '>', 100)->simplePaginate(15);

Similarly, you may use the cursorPaginate method to cursor paginate Eloquent models:
$users = User::where('votes', '>', 100)->cursorPaginate(15);

Page 757 of 1307

Laravel 9.x

Multiple Paginator Instances Per Page
Sometimes you may need to render two separate paginators on a single screen that is rendered by your application.
However, if both paginator instances use the page query string parameter to store the current page, the two paginator's
will conflict. To resolve this conflict, you may pass the name of the query string parameter you wish to use to store the
paginator's current page via the third argument provided to the paginate , simplePaginate , and cursorPaginate
methods:
use App\Models\User;
$users = User::where('votes', '>', 100)->paginate(
$perPage = 15, $columns = ['*'], $pageName = 'users'
);

Cursor Pagination

While paginate and simplePaginate create queries using the SQL "offset" clause, cursor pagination works by
constructing "where" clauses that compare the values of the ordered columns contained in the query, providing the most
efficient database performance available amongst all of Laravel's pagination methods. This method of pagination is
particularly well-suited for large data-sets and "infinite" scrolling user interfaces.
Unlike offset based pagination, which includes a page number in the query string of the URLs generated by the paginator,
cursor based pagination places a "cursor" string in the query string. The cursor is an encoded string containing the
location that the next paginated query should start paginating and the direction that it should paginate:
http://localhost/users?cursor=eyJpZCI6MTUsIl9wb2ludHNUb05leHRJdGVtcyI6dHJ1ZX0

You may create a cursor based paginator instance via the cursorPaginate method offered by the query builder. This
method returns an instance of Illuminate\Pagination\CursorPaginator :
$users = DB::table('users')->orderBy('id')->cursorPaginate(15);

Once you have retrieved a cursor paginator instance, you may display the pagination results as you typically would when
using the paginate and simplePaginate methods. For more information on the instance methods offered by the
cursor paginator, please consult the cursor paginator instance method documentation.
Your query must contain an "order by" clause in order to take advantage of cursor pagination.
Cursor vs. Offset Pagination
To illustrate the differences between offset pagination and cursor pagination, let's examine some example SQL queries.
Both of the following queries will both display the "second page" of results for a users table ordered by id :
# Offset Pagination...
select * from users order by id asc limit 15 offset 15;
# Cursor Pagination...
select * from users where id > 15 order by id asc limit 15;

The cursor pagination query offers the following advantages over offset pagination:

Page 758 of 1307

Laravel 9.x

For large data-sets, cursor pagination will offer better performance if the "order by" columns are indexed. This is
because the "offset" clause scans through all previously matched data.
For data-sets with frequent writes, offset pagination may skip records or show duplicates if results have been
recently added to or deleted from the page a user is currently viewing.
However, cursor pagination has the following limitations:
Like simplePaginate , cursor pagination can only be used to display "Next" and "Previous" links and does not
support generating links with page numbers.
It requires that the ordering is based on at least one unique column or a combination of columns that are unique.
Columns with null values are not supported.
Query expressions in "order by" clauses are supported only if they are aliased and added to the "select" clause as
well.
Query expressions with parameters are not supported.

Manually Creating A Paginator

Sometimes you may wish to create a pagination instance manually, passing it an array of items that you already have in
memory. You may do so by creating either an Illuminate\Pagination\Paginator ,
Illuminate\Pagination\LengthAwarePaginator or Illuminate\Pagination\CursorPaginator instance,
depending on your needs.
The Paginator and CursorPaginator classes do not need to know the total number of items in the result set;
however, because of this, these classes do not have methods for retrieving the index of the last page. The
LengthAwarePaginator accepts almost the same arguments as the Paginator ; however, it requires a count of the
total number of items in the result set.
In other words, the Paginator corresponds to the simplePaginate method on the query builder, the
CursorPaginator corresponds to the cursorPaginate method, and the LengthAwarePaginator corresponds to
the paginate method.
When manually creating a paginator instance, you should manually "slice" the array of results you
pass to the paginator. If you're unsure how to do this, check out the array_slice PHP function.

Customizing Pagination URLs

By default, links generated by the paginator will match the current request's URI. However, the paginator's withPath
method allows you to customize the URI used by the paginator when generating links. For example, if you want the
paginator to generate links like http://example.com/admin/users?page=N , you should pass /admin/users to the
withPath method:
use App\Models\User;
Route::get('/users', function () {
$users = User::paginate(15);
$users->withPath('/admin/users');
//
});

Appending Query String Values

Page 759 of 1307

Laravel 9.x

You may append to the query string of pagination links using the appends method. For example, to append
sort=votes to each pagination link, you should make the following call to appends :
use App\Models\User;
Route::get('/users', function () {
$users = User::paginate(15);
$users->appends(['sort' => 'votes']);
//
});

You may use the withQueryString method if you would like to append all of the current request's query string values to
the pagination links:
$users = User::paginate(15)->withQueryString();

Appending Hash Fragments
If you need to append a "hash fragment" to URLs generated by the paginator, you may use the fragment method. For
example, to append #users to the end of each pagination link, you should invoke the fragment method like so:
$users = User::paginate(15)->fragment('users');

Displaying Pagination Results

When calling the paginate method, you will receive an instance of
Illuminate\Pagination\LengthAwarePaginator , while calling the simplePaginate method returns an instance of
Illuminate\Pagination\Paginator . And, finally, calling the cursorPaginate method returns an instance of
Illuminate\Pagination\CursorPaginator .
These objects provide several methods that describe the result set. In addition to these helper methods, the paginator
instances are iterators and may be looped as an array. So, once you have retrieved the results, you may display the results
and render the page links using Blade:
<div class="container">
@foreach ($users as $user)
{{ $user->name }}
@endforeach
</div>
{{ $users->links() }}

The links method will render the links to the rest of the pages in the result set. Each of these links will already contain
the proper page query string variable. Remember, the HTML generated by the links method is compatible with the
Tailwind CSS framework.

Adjusting The Pagination Link Window

When the paginator displays pagination links, the current page number is displayed as well as links for the three pages
before and after the current page. Using the onEachSide method, you may control how many additional links are
displayed on each side of the current page within the middle, sliding window of links generated by the paginator:

Page 760 of 1307

Laravel 9.x

{{ $users->onEachSide(5)->links() }}

Converting Results To JSON

The Laravel paginator classes implement the Illuminate\Contracts\Support\Jsonable Interface contract and
expose the toJson method, so it's very easy to convert your pagination results to JSON. You may also convert a
paginator instance to JSON by returning it from a route or controller action:
use App\Models\User;
Route::get('/users', function () {
return User::paginate();
});

The JSON from the paginator will include meta information such as total , current_page , last_page , and more.
The result records are available via the data key in the JSON array. Here is an example of the JSON created by returning
a paginator instance from a route:
{
"total": 50,
"per_page": 15,
"current_page": 1,
"last_page": 4,
"first_page_url": "http://laravel.app?page=1",
"last_page_url": "http://laravel.app?page=4",
"next_page_url": "http://laravel.app?page=2",
"prev_page_url": null,
"path": "http://laravel.app",
"from": 1,
"to": 15,
"data":[
{
// Record...
},
{
// Record...
}
]
}

Customizing The Pagination View

By default, the views rendered to display the pagination links are compatible with the Tailwind CSS framework. However, if
you are not using Tailwind, you are free to define your own views to render these links. When calling the links method
on a paginator instance, you may pass the view name as the first argument to the method:
{{ $paginator->links('view.name') }}
<!-- Passing additional data to the view... -->
{{ $paginator->links('view.name', ['foo' => 'bar']) }}

However, the easiest way to customize the pagination views is by exporting them to your resources/views/vendor
directory using the vendor:publish command:
Page 761 of 1307

Laravel 9.x

php artisan vendor:publish --tag=laravel-pagination

This command will place the views in your application's resources/views/vendor/pagination directory. The
tailwind.blade.php file within this directory corresponds to the default pagination view. You may edit this file to
modify the pagination HTML.
If you would like to designate a different file as the default pagination view, you may invoke the paginator's defaultView
and defaultSimpleView methods within the boot method of your App\Providers\AppServiceProvider class:
<?php
namespace App\Providers;
use Illuminate\Pagination\Paginator;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Paginator::defaultView('view-name');
Paginator::defaultSimpleView('view-name');
}
}

Using Bootstrap

Laravel includes pagination views built using Bootstrap CSS. To use these views instead of the default Tailwind views, you
may call the paginator's useBootstrapFour or useBootstrapFive methods within the boot method of your
App\Providers\AppServiceProvider class:
use Illuminate\Pagination\Paginator;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Paginator::useBootstrapFive();
Paginator::useBootstrapFour();
}

Paginator / LengthAwarePaginator Instance Methods

Each paginator instance provides additional pagination information via the following methods:

Page 762 of 1307

Laravel 9.x

Method
$paginator->count()
$paginator->currentPage()
$paginator->firstItem()
$paginator->getOptions()
$paginator->getUrlRange($start,
$end)
$paginator->hasPages()
$paginator->hasMorePages()
$paginator->items()
$paginator->lastItem()

$paginator->lastPage()

$paginator->nextPageUrl()
$paginator->onFirstPage()
$paginator->perPage()
$paginator->previousPageUrl()

$paginator->total()

$paginator->url($page)
$paginator->getPageName()
$paginator->setPageName($name)

Description
Get the number of items for the current page.
Get the current page number.
Get the result number of the first item in the results.
Get the paginator options.
Create a range of pagination URLs.
Determine if there are enough items to split into multiple pages.
Determine if there are more items in the data store.
Get the items for the current page.
Get the result number of the last item in the results.
Get the page number of the last available page. (Not available when using
simplePaginate).
Get the URL for the next page.
Determine if the paginator is on the first page.
The number of items to be shown per page.
Get the URL for the previous page.
Determine the total number of matching items in the data store. (Not available
when using simplePaginate).
Get the URL for a given page number.
Get the query string variable used to store the page.
Set the query string variable used to store the page.

Cursor Paginator Instance Methods

Each cursor paginator instance provides additional pagination information via the following methods:

Page 763 of 1307

Laravel 9.x

Method
$paginator->count()
$paginator->cursor()
$paginator->getOptions()
$paginator->hasPages()
$paginator->hasMorePages()
$paginator->getCursorName()
$paginator->items()
$paginator->nextCursor()
$paginator->nextPageUrl()
$paginator->onFirstPage()
$paginator->onLastPage()
$paginator->perPage()
$paginator->previousCursor()
$paginator->previousPageUrl()
$paginator->setCursorName()
$paginator->url($cursor)

Description
Get the number of items for the current page.
Get the current cursor instance.
Get the paginator options.
Determine if there are enough items to split into multiple pages.
Determine if there are more items in the data store.
Get the query string variable used to store the cursor.
Get the items for the current page.
Get the cursor instance for the next set of items.
Get the URL for the next page.
Determine if the paginator is on the first page.
Determine if the paginator is on the last page.
The number of items to be shown per page.
Get the cursor instance for the previous set of items.
Get the URL for the previous page.
Set the query string variable used to store the cursor.
Get the URL for a given cursor instance.

Page 764 of 1307

Laravel 9.x

Database: Migrations

Introduction
Generating Migrations
Squashing Migrations
Migration Structure
Running Migrations
Rolling Back Migrations
Tables
Creating Tables
Updating Tables
Renaming / Dropping Tables
Columns
Creating Columns
Available Column Types
Column Modifiers
Modifying Columns
Renaming Columns
Dropping Columns
Indexes
Creating Indexes
Renaming Indexes
Dropping Indexes
Foreign Key Constraints
Events

Introduction

Migrations are like version control for your database, allowing your team to define and share the application's database
schema definition. If you have ever had to tell a teammate to manually add a column to their local database schema after
pulling in your changes from source control, you've faced the problem that database migrations solve.
The Laravel Schema facade provides database agnostic support for creating and manipulating tables across all of
Laravel's supported database systems. Typically, migrations will use this facade to create and modify database tables and
columns.

Generating Migrations

You may use the make:migration Artisan command to generate a database migration. The new migration will be placed
in your database/migrations directory. Each migration filename contains a timestamp that allows Laravel to determine
the order of the migrations:
php artisan make:migration create_flights_table

Laravel will use the name of the migration to attempt to guess the name of the table and whether or not the migration will
be creating a new table. If Laravel is able to determine the table name from the migration name, Laravel will pre-fill the
generated migration file with the specified table. Otherwise, you may simply specify the table in the migration file manually.
If you would like to specify a custom path for the generated migration, you may use the --path option when executing
the make:migration command. The given path should be relative to your application's base path.

Page 765 of 1307

Laravel 9.x

Migration stubs may be customized using stub publishing.

Squashing Migrations

As you build your application, you may accumulate more and more migrations over time. This can lead to your
database/migrations directory becoming bloated with potentially hundreds of migrations. If you would like, you may
"squash" your migrations into a single SQL file. To get started, execute the schema:dump command:
php artisan schema:dump
# Dump the current database schema and prune all existing migrations...
php artisan schema:dump --prune

When you execute this command, Laravel will write a "schema" file to your application's database/schema directory. The
schema file's name will correspond to the database connection. Now, when you attempt to migrate your database and no
other migrations have been executed, Laravel will execute first the SQL statements of the schema file of the database
connection you are using. After executing the schema file's statements, Laravel will execute any remaining migrations that
were not part of the schema dump.
If your application's tests use a different database connection than the one you typically use during local development, you
should ensure you have dumped a schema file using that database connection so that your tests are able to build your
database. You may wish to do this after dumping the database connection you typically use during local development:
php artisan schema:dump
php artisan schema:dump --database=testing --prune

You should commit your database schema file to source control so that other new developers on your team may quickly
create your application's initial database structure.
Migration squashing is only available for the MySQL, PostgreSQL, and SQLite databases and
utilizes the database's command-line client. Schema dumps may not be restored to in-memory
SQLite databases.

Migration Structure

A migration class contains two methods: up and down . The up method is used to add new tables, columns, or indexes
to your database, while the down method should reverse the operations performed by the up method.
Within both of these methods, you may use the Laravel schema builder to expressively create and modify tables. To learn
about all of the methods available on the Schema builder, check out its documentation. For example, the following
migration creates a flights table:

Page 766 of 1307

Laravel 9.x

<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
/**
* Run the migrations.
*
* @return void
*/
public function up()
{
Schema::create('flights', function (Blueprint $table) {
$table->id();
$table->string('name');
$table->string('airline');
$table->timestamps();
});
}
/**
* Reverse the migrations.
*
* @return void
*/
public function down()
{
Schema::drop('flights');
}
};

Setting The Migration Connection
If your migration will be interacting with a database connection other than your application's default database connection,
you should set the $connection property of your migration:
/**
* The database connection that should be used by the migration.
*
* @var string
*/
protected $connection = 'pgsql';
/**
* Run the migrations.
*
* @return void
*/
public function up()
{
//
}

Page 767 of 1307

Laravel 9.x

Running Migrations

To run all of your outstanding migrations, execute the migrate Artisan command:
php artisan migrate

If you would like to see which migrations have run thus far, you may use the migrate:status Artisan command:
php artisan migrate:status

If you would like to see the SQL statements that will be executed by the migrations without actually running them, you may
provide the --pretend flag to the migrate command:
php artisan migrate --pretend

Isolating Migration Execution
If you are deploying your application across multiple servers and running migrations as part of your deployment process,
you likely do not want two servers attempting to migrate the database at the same time. To avoid this, you may use the
isolated option when invoking the migrate command.
When the isolated option is provided, Laravel will acquire an atomic lock using your application's cache driver before
attempting to run your migrations. All other attempts to run the migrate command while that lock is held will not
execute; however, the command will still exit with a successful exit status code:
php artisan migrate --isolated

To utilize this feature, your application must be using the memcached , redis , dynamodb ,
database , file , or array cache driver as your application's default cache driver. In addition,
all servers must be communicating with the same central cache server.
Forcing Migrations To Run In Production
Some migration operations are destructive, which means they may cause you to lose data. In order to protect you from
running these commands against your production database, you will be prompted for confirmation before the commands
are executed. To force the commands to run without a prompt, use the --force flag:
php artisan migrate --force

Rolling Back Migrations

To roll back the latest migration operation, you may use the rollback Artisan command. This command rolls back the
last "batch" of migrations, which may include multiple migration files:
php artisan migrate:rollback

You may roll back a limited number of migrations by providing the step option to the rollback command. For example,
the following command will roll back the last five migrations:
php artisan migrate:rollback --step=5

Page 768 of 1307

Laravel 9.x

The migrate:reset command will roll back all of your application's migrations:
php artisan migrate:reset

Roll Back & Migrate Using A Single Command
The migrate:refresh command will roll back all of your migrations and then execute the migrate command. This
command effectively re-creates your entire database:
php artisan migrate:refresh
# Refresh the database and run all database seeds...
php artisan migrate:refresh --seed

You may roll back and re-migrate a limited number of migrations by providing the step option to the refresh
command. For example, the following command will roll back and re-migrate the last five migrations:
php artisan migrate:refresh --step=5

Drop All Tables & Migrate
The migrate:fresh command will drop all tables from the database and then execute the migrate command:
php artisan migrate:fresh
php artisan migrate:fresh --seed

The migrate:fresh command will drop all database tables regardless of their prefix. This
command should be used with caution when developing on a database that is shared with other
applications.

Tables

Creating Tables

To create a new database table, use the create method on the Schema facade. The create method accepts two
arguments: the first is the name of the table, while the second is a closure which receives a Blueprint object that may
be used to define the new table:
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::create('users', function (Blueprint $table) {
$table->id();
$table->string('name');
$table->string('email');
$table->timestamps();
});

When creating the table, you may use any of the schema builder's column methods to define the table's columns.
Page 769 of 1307

Laravel 9.x

Checking For Table / Column Existence
You may check for the existence of a table or column using the hasTable and hasColumn methods:
if (Schema::hasTable('users')) {
// The "users" table exists...
}
if (Schema::hasColumn('users', 'email')) {
// The "users" table exists and has an "email" column...
}

Database Connection & Table Options
If you want to perform a schema operation on a database connection that is not your application's default connection, use
the connection method:
Schema::connection('sqlite')->create('users', function (Blueprint $table) {
$table->id();
});

In addition, a few other properties and methods may be used to define other aspects of the table's creation. The engine
property may be used to specify the table's storage engine when using MySQL:
Schema::create('users', function (Blueprint $table) {
$table->engine = 'InnoDB';
// ...
});

The charset and collation properties may be used to specify the character set and collation for the created table
when using MySQL:
Schema::create('users', function (Blueprint $table) {
$table->charset = 'utf8mb4';
$table->collation = 'utf8mb4_unicode_ci';
// ...
});

The temporary method may be used to indicate that the table should be "temporary". Temporary tables are only visible
to the current connection's database session and are dropped automatically when the connection is closed:
Schema::create('calculations', function (Blueprint $table) {
$table->temporary();
// ...
});

If you would like to add a "comment" to a database table, you may invoke the comment method on the table instance.
Table comments are currently only supported by MySQL and Postgres:

Page 770 of 1307

Laravel 9.x

Schema::create('calculations', function (Blueprint $table) {
$table->comment('Business calculations');
// ...
});

Updating Tables

The table method on the Schema facade may be used to update existing tables. Like the create method, the
table method accepts two arguments: the name of the table and a closure that receives a Blueprint instance you
may use to add columns or indexes to the table:
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::table('users', function (Blueprint $table) {
$table->integer('votes');
});

Renaming / Dropping Tables

To rename an existing database table, use the rename method:
use Illuminate\Support\Facades\Schema;
Schema::rename($from, $to);

To drop an existing table, you may use the drop or dropIfExists methods:
Schema::drop('users');
Schema::dropIfExists('users');

Renaming Tables With Foreign Keys
Before renaming a table, you should verify that any foreign key constraints on the table have an explicit name in your
migration files instead of letting Laravel assign a convention based name. Otherwise, the foreign key constraint name will
refer to the old table name.

Columns

Creating Columns

The table method on the Schema facade may be used to update existing tables. Like the create method, the
table method accepts two arguments: the name of the table and a closure that receives an
Illuminate\Database\Schema\Blueprint instance you may use to add columns to the table:
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::table('users', function (Blueprint $table) {
$table->integer('votes');
});

Page 771 of 1307

Laravel 9.x

Available Column Types

The schema builder blueprint offers a variety of methods that correspond to the different types of columns you can add to
your database tables. Each of the available methods are listed in the table below:
bigIncrements
jsonb
string
bigInteger
lineString
text
binary
longText
timeTz
boolean
macAddress
time
char
mediumIncrements
timestampTz
dateTimeTz
mediumInteger
timestamp
dateTime
mediumText
timestampsTz
date
morphs
timestamps
decimal
multiLineString
tinyIncrements
double
multiPoint
tinyInteger
enum
multiPolygon
tinyText
float
nullableMorphs
unsignedBigInteger
foreignId
nullableTimestamps
unsignedDecimal
foreignIdFor
nullableUlidMorphs
unsignedInteger
foreignUlid
nullableUuidMorphs
unsignedMediumInteger
foreignUuid
point
unsignedSmallInteger
geometryCollection
polygon
unsignedTinyInteger
geometry
rememberToken
ulidMorphs
id
set
uuidMorphs
increments
smallIncrements
ulid
integer
smallInteger
uuid
ipAddress
softDeletesTz
year
json
softDeletes
bigIncrements()

The bigIncrements method creates an auto-incrementing UNSIGNED BIGINT (primary key) equivalent column:
$table->bigIncrements('id');

bigInteger()

The bigInteger method creates a BIGINT equivalent column:
$table->bigInteger('votes');

binary()

The binary method creates a BLOB equivalent column:
$table->binary('photo');

boolean()

The boolean method creates a BOOLEAN equivalent column:
$table->boolean('confirmed');

char()

The char method creates a CHAR equivalent column with of a given length:
Page 772 of 1307

Laravel 9.x

$table->char('name', 100);

dateTimeTz()

The dateTimeTz method creates a DATETIME (with timezone) equivalent column with an optional precision (total
digits):
$table->dateTimeTz('created_at', $precision = 0);

dateTime()

The dateTime method creates a DATETIME equivalent column with an optional precision (total digits):
$table->dateTime('created_at', $precision = 0);

date()

The date method creates a DATE equivalent column:
$table->date('created_at');

decimal()

The decimal method creates a DECIMAL equivalent column with the given precision (total digits) and scale (decimal
digits):
$table->decimal('amount', $precision = 8, $scale = 2);

double()

The double method creates a DOUBLE equivalent column with the given precision (total digits) and scale (decimal
digits):
$table->double('amount', 8, 2);

enum()

The enum method creates a ENUM equivalent column with the given valid values:
$table->enum('difficulty', ['easy', 'hard']);

float()

The float method creates a FLOAT equivalent column with the given precision (total digits) and scale (decimal digits):
$table->float('amount', 8, 2);

foreignId()

The foreignId method creates an UNSIGNED BIGINT equivalent column:
$table->foreignId('user_id');

Page 773 of 1307

Laravel 9.x

foreignIdFor()

The foreignIdFor method adds a {column}_id UNSIGNED BIGINT equivalent column for a given model class:
$table->foreignIdFor(User::class);

foreignUlid()

The foreignUlid method creates a ULID equivalent column:
$table->foreignUlid('user_id');

foreignUuid()

The foreignUuid method creates a UUID equivalent column:
$table->foreignUuid('user_id');

geometryCollection()

The geometryCollection method creates a GEOMETRYCOLLECTION equivalent column:
$table->geometryCollection('positions');

geometry()

The geometry method creates a GEOMETRY equivalent column:
$table->geometry('positions');

id()

The id method is an alias of the bigIncrements method. By default, the method will create an id column; however,
you may pass a column name if you would like to assign a different name to the column:
$table->id();

increments()

The increments method creates an auto-incrementing UNSIGNED INTEGER equivalent column as a primary key:
$table->increments('id');

integer()

The integer method creates an INTEGER equivalent column:
$table->integer('votes');

ipAddress()

The ipAddress method creates a VARCHAR equivalent column:

Page 774 of 1307

Laravel 9.x

$table->ipAddress('visitor');

json()

The json method creates a JSON equivalent column:
$table->json('options');

jsonb()

The jsonb method creates a JSONB equivalent column:
$table->jsonb('options');

lineString()

The lineString method creates a LINESTRING equivalent column:
$table->lineString('positions');

longText()

The longText method creates a LONGTEXT equivalent column:
$table->longText('description');

macAddress()

The macAddress method creates a column that is intended to hold a MAC address. Some database systems, such as
PostgreSQL, have a dedicated column type for this type of data. Other database systems will use a string equivalent
column:
$table->macAddress('device');

mediumIncrements()

The mediumIncrements method creates an auto-incrementing UNSIGNED MEDIUMINT equivalent column as a primary
key:
$table->mediumIncrements('id');

mediumInteger()

The mediumInteger method creates a MEDIUMINT equivalent column:
$table->mediumInteger('votes');

mediumText()

The mediumText method creates a MEDIUMTEXT equivalent column:
$table->mediumText('description');

Page 775 of 1307

Laravel 9.x

morphs()

The morphs method is a convenience method that adds a {column}_id UNSIGNED BIGINT equivalent column and a
{column}_type VARCHAR equivalent column.
This method is intended to be used when defining the columns necessary for a polymorphic Eloquent relationship. In the
following example, taggable_id and taggable_type columns would be created:
$table->morphs('taggable');

multiLineString()

The multiLineString method creates a MULTILINESTRING equivalent column:
$table->multiLineString('positions');

multiPoint()

The multiPoint method creates a MULTIPOINT equivalent column:
$table->multiPoint('positions');

multiPolygon()

The multiPolygon method creates a MULTIPOLYGON equivalent column:
$table->multiPolygon('positions');

nullableTimestamps()

The nullableTimestamps method is an alias of the timestamps method:
$table->nullableTimestamps(0);

nullableMorphs()

The method is similar to the morphs method; however, the columns that are created will be "nullable":
$table->nullableMorphs('taggable');

nullableUlidMorphs()

The method is similar to the ulidMorphs method; however, the columns that are created will be "nullable":
$table->nullableUlidMorphs('taggable');

nullableUuidMorphs()

The method is similar to the uuidMorphs method; however, the columns that are created will be "nullable":
$table->nullableUuidMorphs('taggable');

point()

The point method creates a POINT equivalent column:
Page 776 of 1307

Laravel 9.x

$table->point('position');

polygon()

The polygon method creates a POLYGON equivalent column:
$table->polygon('position');

rememberToken()

The rememberToken method creates a nullable, VARCHAR(100) equivalent column that is intended to store the current
"remember me" authentication token:
$table->rememberToken();

set()

The set method creates a SET equivalent column with the given list of valid values:
$table->set('flavors', ['strawberry', 'vanilla']);

smallIncrements()

The smallIncrements method creates an auto-incrementing UNSIGNED SMALLINT equivalent column as a primary key:
$table->smallIncrements('id');

smallInteger()

The smallInteger method creates a SMALLINT equivalent column:
$table->smallInteger('votes');

softDeletesTz()

The softDeletesTz method adds a nullable deleted_at TIMESTAMP (with timezone) equivalent column with an
optional precision (total digits). This column is intended to store the deleted_at timestamp needed for Eloquent's "soft
delete" functionality:
$table->softDeletesTz($column = 'deleted_at', $precision = 0);

softDeletes()

The softDeletes method adds a nullable deleted_at TIMESTAMP equivalent column with an optional precision (total
digits). This column is intended to store the deleted_at timestamp needed for Eloquent's "soft delete" functionality:
$table->softDeletes($column = 'deleted_at', $precision = 0);

string()

The string method creates a VARCHAR equivalent column of the given length:

Page 777 of 1307

Laravel 9.x

$table->string('name', 100);

text()

The text method creates a TEXT equivalent column:
$table->text('description');

timeTz()

The timeTz method creates a TIME (with timezone) equivalent column with an optional precision (total digits):
$table->timeTz('sunrise', $precision = 0);

time()

The time method creates a TIME equivalent column with an optional precision (total digits):
$table->time('sunrise', $precision = 0);

timestampTz()

The timestampTz method creates a TIMESTAMP (with timezone) equivalent column with an optional precision (total
digits):
$table->timestampTz('added_at', $precision = 0);

timestamp()

The timestamp method creates a TIMESTAMP equivalent column with an optional precision (total digits):
$table->timestamp('added_at', $precision = 0);

timestampsTz()

The timestampsTz method creates created_at and updated_at TIMESTAMP (with timezone) equivalent columns
with an optional precision (total digits):
$table->timestampsTz($precision = 0);

timestamps()

The timestamps method creates created_at and updated_at TIMESTAMP equivalent columns with an optional
precision (total digits):
$table->timestamps($precision = 0);

tinyIncrements()

The tinyIncrements method creates an auto-incrementing UNSIGNED TINYINT equivalent column as a primary key:
$table->tinyIncrements('id');

Page 778 of 1307

Laravel 9.x

tinyInteger()

The tinyInteger method creates a TINYINT equivalent column:
$table->tinyInteger('votes');

tinyText()

The tinyText method creates a TINYTEXT equivalent column:
$table->tinyText('notes');

unsignedBigInteger()

The unsignedBigInteger method creates an UNSIGNED BIGINT equivalent column:
$table->unsignedBigInteger('votes');

unsignedDecimal()

The unsignedDecimal method creates an UNSIGNED DECIMAL equivalent column with an optional precision (total
digits) and scale (decimal digits):
$table->unsignedDecimal('amount', $precision = 8, $scale = 2);

unsignedInteger()

The unsignedInteger method creates an UNSIGNED INTEGER equivalent column:
$table->unsignedInteger('votes');

unsignedMediumInteger()

The unsignedMediumInteger method creates an UNSIGNED MEDIUMINT equivalent column:
$table->unsignedMediumInteger('votes');

unsignedSmallInteger()

The unsignedSmallInteger method creates an UNSIGNED SMALLINT equivalent column:
$table->unsignedSmallInteger('votes');

unsignedTinyInteger()

The unsignedTinyInteger method creates an UNSIGNED TINYINT equivalent column:
$table->unsignedTinyInteger('votes');

ulidMorphs()

The ulidMorphs method is a convenience method that adds a {column}_id CHAR(26) equivalent column and a
{column}_type VARCHAR equivalent column.

Page 779 of 1307

Laravel 9.x

This method is intended to be used when defining the columns necessary for a polymorphic Eloquent relationship that use
ULID identifiers. In the following example, taggable_id and taggable_type columns would be created:
$table->ulidMorphs('taggable');

uuidMorphs()

The uuidMorphs method is a convenience method that adds a {column}_id CHAR(36) equivalent column and a
{column}_type VARCHAR equivalent column.
This method is intended to be used when defining the columns necessary for a polymorphic Eloquent relationship that use
UUID identifiers. In the following example, taggable_id and taggable_type columns would be created:
$table->uuidMorphs('taggable');

ulid()

The ulid method creates a ULID equivalent column:
$table->ulid('id');

uuid()

The uuid method creates a UUID equivalent column:
$table->uuid('id');

year()

The year method creates a YEAR equivalent column:
$table->year('birth_year');

Column Modifiers

In addition to the column types listed above, there are several column "modifiers" you may use when adding a column to a
database table. For example, to make the column "nullable", you may use the nullable method:
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::table('users', function (Blueprint $table) {
$table->string('email')->nullable();
});

The following table contains all of the available column modifiers. This list does not include index modifiers:

Page 780 of 1307

Laravel 9.x

Modifier
->after('column')
->autoIncrement()
->charset('utf8mb4')
>collation('utf8mb4_unicode_ci')
->comment('my comment')
->default($value)
->first()
->from($integer)
->invisible()
->nullable($value = true)
->storedAs($expression)
->unsigned()
->useCurrent()

->useCurrentOnUpdate()

->virtualAs($expression)
->generatedAs($expression)

->always()

->isGeometry()

Description
Place the column "after" another column (MySQL).
Set INTEGER columns as auto-incrementing (primary key).
Specify a character set for the column (MySQL).
Specify a collation for the column (MySQL/PostgreSQL/SQL Server).
Add a comment to a column (MySQL/PostgreSQL).
Specify a "default" value for the column.
Place the column "first" in the table (MySQL).
Set the starting value of an auto-incrementing field (MySQL / PostgreSQL).
Make the column "invisible" to SELECT * queries (MySQL).
Allow NULL values to be inserted into the column.
Create a stored generated column (MySQL / PostgreSQL).
Set INTEGER columns as UNSIGNED (MySQL).
Set TIMESTAMP columns to use CURRENT_TIMESTAMP as default value.
Set TIMESTAMP columns to use CURRENT_TIMESTAMP when a record is
updated.
Create a virtual generated column (MySQL / PostgreSQL / SQLite).
Create an identity column with specified sequence options (PostgreSQL).
Defines the precedence of sequence values over input for an identity column
(PostgreSQL).
Set spatial column type to geometry - the default type is geography (PostgreSQL).

Default Expressions
The default modifier accepts a value or an Illuminate\Database\Query\Expression instance. Using an
Expression instance will prevent Laravel from wrapping the value in quotes and allow you to use database specific
functions. One situation where this is particularly useful is when you need to assign default values to JSON columns:

Page 781 of 1307

Laravel 9.x

<?php
use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Query\Expression;
use Illuminate\Database\Migrations\Migration;
return new class extends Migration
{
/**
* Run the migrations.
*
* @return void
*/
public function up()
{
Schema::create('flights', function (Blueprint $table) {
$table->id();
$table->json('movies')->default(new Expression('(JSON_ARRAY())'));
$table->timestamps();
});
}
};

Support for default expressions depends on your database driver, database version, and the field
type. Please refer to your database's documentation. In addition, it is not possible to combine raw
default expressions (using DB::raw ) with column changes via the change method.
Column Order
When using the MySQL database, the after method may be used to add columns after an existing column in the
schema:
$table->after('password', function ($table) {
$table->string('address_line1');
$table->string('address_line2');
$table->string('city');
});

Modifying Columns

Prerequisites
Before modifying a column, you must install the doctrine/dbal package using the Composer package manager. The
Doctrine DBAL library is used to determine the current state of the column and to create the SQL queries needed to make
the requested changes to your column:
composer require doctrine/dbal

If you plan to modify columns created using the timestamp method, you must also add the following configuration to
your application's config/database.php configuration file:
Page 782 of 1307

Laravel 9.x

use Illuminate\Database\DBAL\TimestampType;
'dbal' => [
'types' => [
'timestamp' => TimestampType::class,
],
],

If your application is using Microsoft SQL Server, please ensure that you install
doctrine/dbal:^3.0 .
Updating Column Attributes
The change method allows you to modify the type and attributes of existing columns. For example, you may wish to
increase the size of a string column. To see the change method in action, let's increase the size of the name column
from 25 to 50. To accomplish this, we simply define the new state of the column and then call the change method:
Schema::table('users', function (Blueprint $table) {
$table->string('name', 50)->change();
});

We could also modify a column to be nullable:
Schema::table('users', function (Blueprint $table) {
$table->string('name', 50)->nullable()->change();
});

The following column types can be modified: bigInteger , binary , boolean , char , date ,
dateTime , dateTimeTz , decimal , double , integer , json , longText , mediumText ,
smallInteger , string , text , time , tinyText , unsignedBigInteger ,
unsignedInteger , unsignedSmallInteger , and uuid . To modify a timestamp column
type a Doctrine type must be registered.

Renaming Columns

To rename a column, you may use the renameColumn method provided by the schema builder:
Schema::table('users', function (Blueprint $table) {
$table->renameColumn('from', 'to');
});

Renaming Columns On Legacy Databases
If you are running a database installation older than one of the following releases, you should ensure that you have installed
the doctrine/dbal library via the Composer package manager before renaming a column:
MySQL < 8.0.3
Page 783 of 1307

Laravel 9.x

MariaDB < 10.5.2
SQLite < 3.25.0

Dropping Columns

To drop a column, you may use the dropColumn method on the schema builder:
Schema::table('users', function (Blueprint $table) {
$table->dropColumn('votes');
});

You may drop multiple columns from a table by passing an array of column names to the dropColumn method:
Schema::table('users', function (Blueprint $table) {
$table->dropColumn(['votes', 'avatar', 'location']);
});

Dropping Columns On Legacy Databases
If you are running a version of SQLite prior to 3.35.0 , you must install the doctrine/dbal package via the Composer
package manager before the dropColumn method may be used. Dropping or modifying multiple columns within a single
migration while using this package is not supported.
Available Command Aliases
Laravel provides several convenient methods related to dropping common types of columns. Each of these methods is
described in the table below:
Command
$table->dropMorphs('morphable');
$table->dropRememberToken();
$table->dropSoftDeletes();
$table->dropSoftDeletesTz();
$table->dropTimestamps();
$table->dropTimestampsTz();

Description
Drop the morphable_id and morphable_type columns.
Drop the remember_token column.
Drop the deleted_at column.
Alias of dropSoftDeletes() method.
Drop the created_at and updated_at columns.
Alias of dropTimestamps() method.

Indexes

Creating Indexes

The Laravel schema builder supports several types of indexes. The following example creates a new email column and
specifies that its values should be unique. To create the index, we can chain the unique method onto the column
definition:
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::table('users', function (Blueprint $table) {
$table->string('email')->unique();
});

Page 784 of 1307

Laravel 9.x

Alternatively, you may create the index after defining the column. To do so, you should call the unique method on the
schema builder blueprint. This method accepts the name of the column that should receive a unique index:
$table->unique('email');

You may even pass an array of columns to an index method to create a compound (or composite) index:
$table->index(['account_id', 'created_at']);

When creating an index, Laravel will automatically generate an index name based on the table, column names, and the
index type, but you may pass a second argument to the method to specify the index name yourself:
$table->unique('email', 'unique_email');

Available Index Types
Laravel's schema builder blueprint class provides methods for creating each type of index supported by Laravel. Each
index method accepts an optional second argument to specify the name of the index. If omitted, the name will be derived
from the names of the table and column(s) used for the index, as well as the index type. Each of the available index
methods is described in the table below:
Command
$table->primary('id');
$table->primary(['id', 'parent_id']);
$table->unique('email');
$table->index('state');
$table->fullText('body');
$table->fullText('body')->language('english');
$table->spatialIndex('location');

Description
Adds a primary key.
Adds composite keys.
Adds a unique index.
Adds an index.
Adds a full text index (MySQL/PostgreSQL).
Adds a full text index of the specified language (PostgreSQL).
Adds a spatial index (except SQLite).

Index Lengths & MySQL / MariaDB
By default, Laravel uses the utf8mb4 character set. If you are running a version of MySQL older than the 5.7.7 release or
MariaDB older than the 10.2.2 release, you may need to manually configure the default string length generated by
migrations in order for MySQL to create indexes for them. You may configure the default string length by calling the
Schema::defaultStringLength method within the boot method of your App\Providers\AppServiceProvider
class:

Page 785 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Schema;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Schema::defaultStringLength(191);
}

Alternatively, you may enable the innodb_large_prefix option for your database. Refer to your database's
documentation for instructions on how to properly enable this option.

Renaming Indexes

To rename an index, you may use the renameIndex method provided by the schema builder blueprint. This method
accepts the current index name as its first argument and the desired name as its second argument:
$table->renameIndex('from', 'to')

If your application is utilizing an SQLite database, you must install the doctrine/dbal package
via the Composer package manager before the renameIndex method may be used.

Dropping Indexes

To drop an index, you must specify the index's name. By default, Laravel automatically assigns an index name based on the
table name, the name of the indexed column, and the index type. Here are some examples:
Command
$table->dropPrimary('users_id_primary');
$table->dropUnique('users_email_unique');
$table->dropIndex('geo_state_index');
$table->dropFullText('posts_body_fulltext');
$table->dropSpatialIndex('geo_location_spatialindex');

Description
Drop a primary key from the "users" table.
Drop a unique index from the "users" table.
Drop a basic index from the "geo" table.
Drop a full text index from the "posts" table.
Drop a spatial index from the "geo" table (except SQLite).

If you pass an array of columns into a method that drops indexes, the conventional index name will be generated based on
the table name, columns, and index type:
Schema::table('geo', function (Blueprint $table) {
$table->dropIndex(['state']); // Drops index 'geo_state_index'
});

Foreign Key Constraints

Page 786 of 1307

Laravel 9.x

Laravel also provides support for creating foreign key constraints, which are used to force referential integrity at the
database level. For example, let's define a user_id column on the posts table that references the id column on a
users table:
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::table('posts', function (Blueprint $table) {
$table->unsignedBigInteger('user_id');
$table->foreign('user_id')->references('id')->on('users');
});

Since this syntax is rather verbose, Laravel provides additional, terser methods that use conventions to provide a better
developer experience. When using the foreignId method to create your column, the example above can be rewritten
like so:
Schema::table('posts', function (Blueprint $table) {
$table->foreignId('user_id')->constrained();
});

The foreignId method creates an UNSIGNED BIGINT equivalent column, while the constrained method will use
conventions to determine the table and column name being referenced. If your table name does not match Laravel's
conventions, you may specify the table name by passing it as an argument to the constrained method:
Schema::table('posts', function (Blueprint $table) {
$table->foreignId('user_id')->constrained('users');
});

You may also specify the desired action for the "on delete" and "on update" properties of the constraint:
$table->foreignId('user_id')
->constrained()
->onUpdate('cascade')
->onDelete('cascade');

An alternative, expressive syntax is also provided for these actions:
Method
$table->cascadeOnUpdate();
$table->restrictOnUpdate();
$table->cascadeOnDelete();
$table->restrictOnDelete();
$table->nullOnDelete();

Description
Updates should cascade.
Updates should be restricted.
Deletes should cascade.
Deletes should be restricted.
Deletes should set the foreign key value to null.

Any additional column modifiers must be called before the constrained method:

Page 787 of 1307

Laravel 9.x

$table->foreignId('user_id')
->nullable()
->constrained();

Dropping Foreign Keys
To drop a foreign key, you may use the dropForeign method, passing the name of the foreign key constraint to be
deleted as an argument. Foreign key constraints use the same naming convention as indexes. In other words, the foreign
key constraint name is based on the name of the table and the columns in the constraint, followed by a "_foreign" suffix:
$table->dropForeign('posts_user_id_foreign');

Alternatively, you may pass an array containing the column name that holds the foreign key to the dropForeign method.
The array will be converted to a foreign key constraint name using Laravel's constraint naming conventions:
$table->dropForeign(['user_id']);

Toggling Foreign Key Constraints
You may enable or disable foreign key constraints within your migrations by using the following methods:
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();
Schema::withoutForeignKeyConstraints(function () {
// Constraints disabled within this closure...
});

SQLite disables foreign key constraints by default. When using SQLite, make sure to enable foreign
key support in your database configuration before attempting to create them in your migrations. In
addition, SQLite only supports foreign keys upon creation of the table and not when tables are
altered.

Events

For convenience, each migration operation will dispatch an event. All of the following events extend the base
Illuminate\Database\Events\MigrationEvent class:

Page 788 of 1307

Laravel 9.x

Class
Illuminate\Database\Events\MigrationsStarted
Illuminate\Database\Events\MigrationsEnded
Illuminate\Database\Events\MigrationStarted
Illuminate\Database\Events\MigrationEnded
Illuminate\Database\Events\SchemaDumped
Illuminate\Database\Events\SchemaLoaded

Description
A batch of migrations is about to be executed.
A batch of migrations has finished executing.
A single migration is about to be executed.
A single migration has finished executing.
A database schema dump has completed.
An existing database schema dump has loaded.

Page 789 of 1307

Laravel 9.x

Database: Seeding

Introduction
Writing Seeders
Using Model Factories
Calling Additional Seeders
Muting Model Events
Running Seeders

Introduction

Laravel includes the ability to seed your database with data using seed classes. All seed classes are stored in the
database/seeders directory. By default, a DatabaseSeeder class is defined for you. From this class, you may use the
call method to run other seed classes, allowing you to control the seeding order.
Mass assignment protection is automatically disabled during database seeding.

Writing Seeders

To generate a seeder, execute the make:seeder Artisan command. All seeders generated by the framework will be
placed in the database/seeders directory:
php artisan make:seeder UserSeeder

A seeder class only contains one method by default: run . This method is called when the db:seed Artisan command is
executed. Within the run method, you may insert data into your database however you wish. You may use the query
builder to manually insert data or you may use Eloquent model factories.
As an example, let's modify the default DatabaseSeeder class and add a database insert statement to the run method:

Page 790 of 1307

Laravel 9.x

<?php
namespace Database\Seeders;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
class DatabaseSeeder extends Seeder
{
/**
* Run the database seeders.
*
* @return void
*/
public function run()
{
DB::table('users')->insert([
'name' => Str::random(10),
'email' => Str::random(10).'@gmail.com',
'password' => Hash::make('password'),
]);
}
}

You may type-hint any dependencies you need within the run method's signature. They will
automatically be resolved via the Laravel service container.

Using Model Factories

Of course, manually specifying the attributes for each model seed is cumbersome. Instead, you can use model factories to
conveniently generate large amounts of database records. First, review the model factory documentation to learn how to
define your factories.
For example, let's create 50 users that each has one related post:
use App\Models\User;
/**
* Run the database seeders.
*
* @return void
*/
public function run()
{
User::factory()
->count(50)
->hasPosts(1)
->create();
}

Page 791 of 1307

Laravel 9.x

Calling Additional Seeders

Within the DatabaseSeeder class, you may use the call method to execute additional seed classes. Using the call
method allows you to break up your database seeding into multiple files so that no single seeder class becomes too large.
The call method accepts an array of seeder classes that should be executed:
/**
* Run the database seeders.
*
* @return void
*/
public function run()
{
$this->call([
UserSeeder::class,
PostSeeder::class,
CommentSeeder::class,
]);
}

Muting Model Events

While running seeds, you may want to prevent models from dispatching events. You may achieve this using the
WithoutModelEvents trait. When used, the WithoutModelEvents trait ensures no model events are dispatched, even
if additional seed classes are executed via the call method:
<?php
namespace Database\Seeders;
use Illuminate\Database\Seeder;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;
class DatabaseSeeder extends Seeder
{
use WithoutModelEvents;
/**
* Run the database seeders.
*
* @return void
*/
public function run()
{
$this->call([
UserSeeder::class,
]);
}
}

Running Seeders

You may execute the db:seed Artisan command to seed your database. By default, the db:seed command runs the
Database\Seeders\DatabaseSeeder class, which may in turn invoke other seed classes. However, you may use the -class option to specify a specific seeder class to run individually:
Page 792 of 1307

Laravel 9.x

php artisan db:seed
php artisan db:seed --class=UserSeeder

You may also seed your database using the migrate:fresh command in combination with the --seed option, which
will drop all tables and re-run all of your migrations. This command is useful for completely re-building your database. The
--seeder option may be used to specify a specific seeder to run:
php artisan migrate:fresh --seed
php artisan migrate:fresh --seed --seeder=UserSeeder

Forcing Seeders To Run In Production
Some seeding operations may cause you to alter or lose data. In order to protect you from running seeding commands
against your production database, you will be prompted for confirmation before the seeders are executed in the
production environment. To force the seeders to run without a prompt, use the --force flag:
php artisan db:seed --force

Page 793 of 1307

Laravel 9.x

Introduction
Configuration
Clusters
Predis
phpredis
Interacting With Redis
Transactions
Pipelining Commands
Pub / Sub

Redis

Introduction

Redis is an open source, advanced key-value store. It is often referred to as a data structure server since keys can contain
strings, hashes, lists, sets, and sorted sets.
Before using Redis with Laravel, we encourage you to install and use the phpredis PHP extension via PECL. The extension
is more complex to install compared to "user-land" PHP packages but may yield better performance for applications that
make heavy use of Redis. If you are using Laravel Sail, this extension is already installed in your application's Docker
container.
If you are unable to install the phpredis extension, you may install the predis/predis package via Composer. Predis is a
Redis client written entirely in PHP and does not require any additional extensions:
composer require predis/predis

Configuration

You may configure your application's Redis settings via the config/database.php configuration file. Within this file, you
will see a redis array containing the Redis servers utilized by your application:
'redis' => [
'client' => env('REDIS_CLIENT', 'phpredis'),
'default' => [
'host' => env('REDIS_HOST', '127.0.0.1'),
'password' => env('REDIS_PASSWORD'),
'port' => env('REDIS_PORT', 6379),
'database' => env('REDIS_DB', 0),
],
'cache' => [
'host' => env('REDIS_HOST', '127.0.0.1'),
'password' => env('REDIS_PASSWORD'),
'port' => env('REDIS_PORT', 6379),
'database' => env('REDIS_CACHE_DB', 1),
],
],

Page 794 of 1307

Laravel 9.x

Each Redis server defined in your configuration file is required to have a name, host, and a port unless you define a single
URL to represent the Redis connection:
'redis' => [
'client' => env('REDIS_CLIENT', 'phpredis'),
'default' => [
'url' => 'tcp://127.0.0.1:6379?database=0',
],
'cache' => [
'url' => 'tls://user:password@127.0.0.1:6380?database=1',
],
],

Configuring The Connection Scheme
By default, Redis clients will use the tcp scheme when connecting to your Redis servers; however, you may use TLS /
SSL encryption by specifying a scheme configuration option in your Redis server's configuration array:
'redis' => [
'client' => env('REDIS_CLIENT', 'phpredis'),
'default' => [
'scheme' => 'tls',
'host' => env('REDIS_HOST', '127.0.0.1'),
'password' => env('REDIS_PASSWORD'),
'port' => env('REDIS_PORT', 6379),
'database' => env('REDIS_DB', 0),
],
],

Clusters

If your application is utilizing a cluster of Redis servers, you should define these clusters within a clusters key of your
Redis configuration. This configuration key does not exist by default so you will need to create it within your application's
config/database.php configuration file:

Page 795 of 1307

Laravel 9.x

'redis' => [
'client' => env('REDIS_CLIENT', 'phpredis'),
'clusters' => [
'default' => [
[
'host' => env('REDIS_HOST', 'localhost'),
'password' => env('REDIS_PASSWORD'),
'port' => env('REDIS_PORT', 6379),
'database' => 0,
],
],
],
],

By default, clusters will perform client-side sharding across your nodes, allowing you to pool nodes and create a large
amount of available RAM. However, client-side sharding does not handle failover; therefore, it is primarily suited for
transient cached data that is available from another primary data store.
If you would like to use native Redis clustering instead of client-side sharding, you may specify this by setting the
options.cluster configuration value to redis within your application's config/database.php configuration file:
'redis' => [
'client' => env('REDIS_CLIENT', 'phpredis'),
'options' => [
'cluster' => env('REDIS_CLUSTER', 'redis'),
],
'clusters' => [
// ...
],
],

Predis

If you would like your application to interact with Redis via the Predis package, you should ensure the REDIS_CLIENT
environment variable's value is predis :
'redis' => [
'client' => env('REDIS_CLIENT', 'predis'),
// ...
],

In addition to the default host , port , database , and password server configuration options, Predis supports
additional connection parameters that may be defined for each of your Redis servers. To utilize these additional
configuration options, add them to your Redis server configuration in your application's config/database.php
configuration file:
Page 796 of 1307

Laravel 9.x

'default' => [
'host' => env('REDIS_HOST', 'localhost'),
'password' => env('REDIS_PASSWORD'),
'port' => env('REDIS_PORT', 6379),
'database' => 0,
'read_write_timeout' => 60,
],

The Redis Facade Alias
Laravel's config/app.php configuration file contains an aliases array which defines all of the class aliases that will
be registered by the framework. By default, no Redis alias is included because it would conflict with the Redis class
name provided by the phpredis extension. If you are using the Predis client and would like to add a Redis alias, you may
add it to the aliases array in your application's config/app.php configuration file:
'aliases' => Facade::defaultAliases()->merge([
'Redis' => Illuminate\Support\Facades\Redis::class,
])->toArray(),

phpredis

By default, Laravel will use the phpredis extension to communicate with Redis. The client that Laravel will use to
communicate with Redis is dictated by the value of the redis.client configuration option, which typically reflects the
value of the REDIS_CLIENT environment variable:
'redis' => [
'client' => env('REDIS_CLIENT', 'phpredis'),
// Rest of Redis configuration...
],

In addition to the default scheme , host , port , database , and password server configuration options, phpredis
supports the following additional connection parameters: name , persistent , persistent_id , prefix ,
read_timeout , retry_interval , timeout , and context . You may add any of these options to your Redis server
configuration in the config/database.php configuration file:
'default' => [
'host' => env('REDIS_HOST', 'localhost'),
'password' => env('REDIS_PASSWORD'),
'port' => env('REDIS_PORT', 6379),
'database' => 0,
'read_timeout' => 60,
'context' => [
// 'auth' => ['username', 'secret'],
// 'stream' => ['verify_peer' => false],
],
],

phpredis Serialization & Compression
The phpredis extension may also be configured to use a variety of serialization and compression algorithms. These
algorithms can be configured via the options array of your Redis configuration:

Page 797 of 1307

Laravel 9.x

'redis' => [
'client' => env('REDIS_CLIENT', 'phpredis'),
'options' => [
'serializer' => Redis::SERIALIZER_MSGPACK,
'compression' => Redis::COMPRESSION_LZ4,
],
// Rest of Redis configuration...
],

Currently supported serialization algorithms include: Redis::SERIALIZER_NONE (default), Redis::SERIALIZER_PHP ,
Redis::SERIALIZER_JSON , Redis::SERIALIZER_IGBINARY , and Redis::SERIALIZER_MSGPACK .
Supported compression algorithms include: Redis::COMPRESSION_NONE (default), Redis::COMPRESSION_LZF ,
Redis::COMPRESSION_ZSTD , and Redis::COMPRESSION_LZ4 .

Interacting With Redis

You may interact with Redis by calling various methods on the Redis facade. The Redis facade supports dynamic
methods, meaning you may call any Redis command on the facade and the command will be passed directly to Redis. In
this example, we will call the Redis GET command by calling the get method on the Redis facade:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\Redis;
class UserController extends Controller
{
/**
* Show the profile for the given user.
*
* @param

int

$id

* @return \Illuminate\Http\Response
*/
public function show($id)
{
return view('user.profile', [
'user' => Redis::get('user:profile:'.$id)
]);
}
}

As mentioned above, you may call any of Redis' commands on the Redis facade. Laravel uses magic methods to pass
the commands to the Redis server. If a Redis command expects arguments, you should pass those to the facade's
corresponding method:

Page 798 of 1307

Laravel 9.x

use Illuminate\Support\Facades\Redis;
Redis::set('name', 'Taylor');
$values = Redis::lrange('names', 5, 10);

Alternatively, you may pass commands to the server using the Redis facade's command method, which accepts the
name of the command as its first argument and an array of values as its second argument:
$values = Redis::command('lrange', ['name', 5, 10]);

Using Multiple Redis Connections
Your application's config/database.php configuration file allows you to define multiple Redis connections / servers.
You may obtain a connection to a specific Redis connection using the Redis facade's connection method:
$redis = Redis::connection('connection-name');

To obtain an instance of the default Redis connection, you may call the connection method without any additional
arguments:
$redis = Redis::connection();

Transactions

The Redis facade's transaction method provides a convenient wrapper around Redis' native MULTI and EXEC
commands. The transaction method accepts a closure as its only argument. This closure will receive a Redis
connection instance and may issue any commands it would like to this instance. All of the Redis commands issued within
the closure will be executed in a single, atomic transaction:
use Illuminate\Support\Facades\Redis;
Redis::transaction(function ($redis) {
$redis->incr('user_visits', 1);
$redis->incr('total_visits', 1);
});

When defining a Redis transaction, you may not retrieve any values from the Redis connection.
Remember, your transaction is executed as a single, atomic operation and that operation is not
executed until your entire closure has finished executing its commands.
Lua Scripts
The eval method provides another method of executing multiple Redis commands in a single, atomic operation.
However, the eval method has the benefit of being able to interact with and inspect Redis key values during that
operation. Redis scripts are written in the Lua programming language.
The eval method can be a bit scary at first, but we'll explore a basic example to break the ice. The eval method
expects several arguments. First, you should pass the Lua script (as a string) to the method. Secondly, you should pass the

Page 799 of 1307

Laravel 9.x

number of keys (as an integer) that the script interacts with. Thirdly, you should pass the names of those keys. Finally, you
may pass any other additional arguments that you need to access within your script.
In this example, we will increment a counter, inspect its new value, and increment a second counter if the first counter's
value is greater than five. Finally, we will return the value of the first counter:
$value = Redis::eval(<<<'LUA'
local counter = redis.call("incr", KEYS[1])
if counter > 5 then
redis.call("incr", KEYS[2])
end
return counter
LUA, 2, 'first-counter', 'second-counter');

Please consult the Redis documentation for more information on Redis scripting.

Pipelining Commands

Sometimes you may need to execute dozens of Redis commands. Instead of making a network trip to your Redis server for
each command, you may use the pipeline method. The pipeline method accepts one argument: a closure that
receives a Redis instance. You may issue all of your commands to this Redis instance and they will all be sent to the Redis
server at the same time to reduce network trips to the server. The commands will still be executed in the order they were
issued:
use Illuminate\Support\Facades\Redis;
Redis::pipeline(function ($pipe) {
for ($i = 0; $i < 1000; $i++) {
$pipe->set("key:$i", $i);
}
});

Pub / Sub

Laravel provides a convenient interface to the Redis publish and subscribe commands. These Redis commands allow
you to listen for messages on a given "channel". You may publish messages to the channel from another application, or
even using another programming language, allowing easy communication between applications and processes.
First, let's setup a channel listener using the subscribe method. We'll place this method call within an Artisan command
since calling the subscribe method begins a long-running process:

Page 800 of 1307

Laravel 9.x

<?php
namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Redis;
class RedisSubscribe extends Command
{
/**
* The name and signature of the console command.
*
* @var string
*/
protected $signature = 'redis:subscribe';
/**
* The console command description.
*
* @var string
*/
protected $description = 'Subscribe to a Redis channel';
/**
* Execute the console command.
*
* @return mixed
*/
public function handle()
{
Redis::subscribe(['test-channel'], function ($message) {
echo $message;
});
}
}

Now we may publish messages to the channel using the publish method:
use Illuminate\Support\Facades\Redis;
Route::get('/publish', function () {
// ...
Redis::publish('test-channel', json_encode([
'name' => 'Adam Wathan'
]));
});

Wildcard Subscriptions
Using the psubscribe method, you may subscribe to a wildcard channel, which may be useful for catching all messages
on all channels. The channel name will be passed as the second argument to the provided closure:

Page 801 of 1307

Laravel 9.x

Redis::psubscribe(['*'], function ($message, $channel) {
echo $message;
});
Redis::psubscribe(['users.*'], function ($message, $channel) {
echo $message;
});

Page 802 of 1307

Laravel 9.x

Chapter 8

Eloquent ORM

Page 803 of 1307

Laravel 9.x

Eloquent: Getting Started

Introduction
Generating Model Classes
Eloquent Model Conventions
Table Names
Primary Keys
UUID & ULID Keys
Timestamps
Database Connections
Default Attribute Values
Configuring Eloquent Strictness
Retrieving Models
Collections
Chunking Results
Chunk Using Lazy Collections
Cursors
Advanced Subqueries
Retrieving Single Models / Aggregates
Retrieving Or Creating Models
Retrieving Aggregates
Inserting & Updating Models
Inserts
Updates
Mass Assignment
Upserts
Deleting Models
Soft Deleting
Querying Soft Deleted Models
Pruning Models
Replicating Models
Query Scopes
Global Scopes
Local Scopes
Comparing Models
Events
Using Closures
Observers
Muting Events

Introduction

Laravel includes Eloquent, an object-relational mapper (ORM) that makes it enjoyable to interact with your database. When
using Eloquent, each database table has a corresponding "Model" that is used to interact with that table. In addition to
retrieving records from the database table, Eloquent models allow you to insert, update, and delete records from the table
as well.

Page 804 of 1307

Laravel 9.x

Before getting started, be sure to configure a database connection in your application's
config/database.php configuration file. For more information on configuring your database,
check out the database configuration documentation.
Laravel Bootcamp
If you're new to Laravel, feel free to jump into the Laravel Bootcamp. The Laravel Bootcamp will walk you through building
your first Laravel application using Eloquent. It's a great way to get a tour of everything the Laravel and Eloquent have to
offer.

Generating Model Classes

To get started, let's create an Eloquent model. Models typically live in the app\Models directory and extend the
Illuminate\Database\Eloquent\Model class. You may use the make:model Artisan command to generate a new
model:
php artisan make:model Flight

If you would like to generate a database migration when you generate the model, you may use the --migration or -m
option:
php artisan make:model Flight --migration

You may generate various other types of classes when generating a model, such as factories, seeders, policies, controllers,
and form requests. In addition, these options may be combined to create multiple classes at once:

Page 805 of 1307

Laravel 9.x

# Generate a model and a FlightFactory class...
php artisan make:model Flight --factory
php artisan make:model Flight -f
# Generate a model and a FlightSeeder class...
php artisan make:model Flight --seed
php artisan make:model Flight -s
# Generate a model and a FlightController class...
php artisan make:model Flight --controller
php artisan make:model Flight -c
# Generate a model, FlightController resource class, and form request classes...
php artisan make:model Flight --controller --resource --requests
php artisan make:model Flight -crR
# Generate a model and a FlightPolicy class...
php artisan make:model Flight --policy
# Generate a model and a migration, factory, seeder, and controller...
php artisan make:model Flight -mfsc
# Shortcut to generate a model, migration, factory, seeder, policy, controller, and form
requests...
php artisan make:model Flight --all
# Generate a pivot model...
php artisan make:model Member --pivot

Inspecting Models
Sometimes it can be difficult to determine all of a model's available attributes and relationships just by skimming its code.
Instead, try the model:show Artisan command, which provides a convenient overview of all the model's attributes and
relations:
php artisan model:show Flight

Eloquent Model Conventions

Models generated by the make:model command will be placed in the app/Models directory. Let's examine a basic
model class and discuss some of Eloquent's key conventions:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
//
}

Page 806 of 1307

Laravel 9.x

Table Names

After glancing at the example above, you may have noticed that we did not tell Eloquent which database table corresponds
to our Flight model. By convention, the "snake case", plural name of the class will be used as the table name unless
another name is explicitly specified. So, in this case, Eloquent will assume the Flight model stores records in the
flights table, while an AirTrafficController model would store records in an air_traffic_controllers table.
If your model's corresponding database table does not fit this convention, you may manually specify the model's table
name by defining a table property on the model:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
/**
* The table associated with the model.
*
* @var string
*/
protected $table = 'my_flights';
}

Primary Keys

Eloquent will also assume that each model's corresponding database table has a primary key column named id . If
necessary, you may define a protected $primaryKey property on your model to specify a different column that serves as
your model's primary key:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
/**
* The primary key associated with the table.
*
* @var string
*/
protected $primaryKey = 'flight_id';
}

In addition, Eloquent assumes that the primary key is an incrementing integer value, which means that Eloquent will
automatically cast the primary key to an integer. If you wish to use a non-incrementing or a non-numeric primary key you
must define a public $incrementing property on your model that is set to false :

Page 807 of 1307

Laravel 9.x

<?php
class Flight extends Model
{
/**
* Indicates if the model's ID is auto-incrementing.
*
* @var bool
*/
public $incrementing = false;
}

If your model's primary key is not an integer, you should define a protected $keyType property on your model. This
property should have a value of string :
<?php
class Flight extends Model
{
/**
* The data type of the auto-incrementing ID.
*
* @var string
*/
protected $keyType = 'string';
}

"Composite" Primary Keys
Eloquent requires each model to have at least one uniquely identifying "ID" that can serve as its primary key. "Composite"
primary keys are not supported by Eloquent models. However, you are free to add additional multi-column, unique indexes
to your database tables in addition to the table's uniquely identifying primary key.

UUID & ULID Keys

Instead of using auto-incrementing integers as your Eloquent model's primary keys, you may choose to use UUIDs instead.
UUIDs are universally unique alpha-numeric identifiers that are 36 characters long.
If you would like a model to use a UUID key instead of an auto-incrementing integer key, you may use the
Illuminate\Database\Eloquent\Concerns\HasUuids trait on the model. Of course, you should ensure that the model
has a UUID equivalent primary key column:
use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Model;
class Article extends Model
{
use HasUuids;
// ...
}
$article = Article::create(['title' => 'Traveling to Europe']);
$article->id; // "8f8e8478-9035-4d23-b9a7-62f4d2612ce5"

Page 808 of 1307

Laravel 9.x

By default, The HasUuids trait will generate "ordered" UUIDs for your models. These UUIDs are more efficient for
indexed database storage because they can be sorted lexicographically.
You can override the UUID generation process for a given model by defining a newUniqueId method on the model. In
addition, you may specify which columns should receive UUIDs by defining a uniqueIds method on the model:
use Ramsey\Uuid\Uuid;
/**
* Generate a new UUID for the model.
*
* @return string
*/
public function newUniqueId()
{
return (string) Uuid::uuid4();
}
/**
* Get the columns that should receive a unique identifier.
*
* @return array
*/
public function uniqueIds()
{
return ['id', 'discount_code'];
}

If you wish, you may choose to utilize "ULIDs" instead of UUIDs. ULIDs are similar to UUIDs; however, they are only 26
characters in length. Like ordered UUIDs, ULIDs are lexicographically sortable for efficient database indexing. To utilize
ULIDs, you should use the Illuminate\Database\Eloquent\Concerns\HasUlids trait on your model. You should also
ensure that the model has a ULID equivalent primary key column:
use Illuminate\Database\Eloquent\Concerns\HasUlids;
use Illuminate\Database\Eloquent\Model;
class Article extends Model
{
use HasUlids;
// ...
}
$article = Article::create(['title' => 'Traveling to Asia']);
$article->id; // "01gd4d3tgrrfqeda94gdbtdk5c"

Timestamps

By default, Eloquent expects created_at and updated_at columns to exist on your model's corresponding database
table. Eloquent will automatically set these column's values when models are created or updated. If you do not want these
columns to be automatically managed by Eloquent, you should define a $timestamps property on your model with a
value of false :

Page 809 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
/**
* Indicates if the model should be timestamped.
*
* @var bool
*/
public $timestamps = false;
}

If you need to customize the format of your model's timestamps, set the $dateFormat property on your model. This
property determines how date attributes are stored in the database as well as their format when the model is serialized to
an array or JSON:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
/**
* The storage format of the model's date columns.
*
* @var string
*/
protected $dateFormat = 'U';
}

If you need to customize the names of the columns used to store the timestamps, you may define CREATED_AT and
UPDATED_AT constants on your model:
<?php
class Flight extends Model
{
const CREATED_AT = 'creation_date';
const UPDATED_AT = 'updated_date';
}

If you would like to perform model operations without the model having its updated_at timestamp modified, you may
operate on the model within a closure given to the withoutTimestamps method:
Model::withoutTimestamps(fn () => $post->increment(['reads']));

Database Connections
Page 810 of 1307

Laravel 9.x

By default, all Eloquent models will use the default database connection that is configured for your application. If you
would like to specify a different connection that should be used when interacting with a particular model, you should define
a $connection property on the model:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
/**
* The database connection that should be used by the model.
*
* @var string
*/
protected $connection = 'sqlite';
}

Default Attribute Values

By default, a newly instantiated model instance will not contain any attribute values. If you would like to define the default
values for some of your model's attributes, you may define an $attributes property on your model. Attribute values
placed in the $attributes array should be in their raw, "storable" format as if they were just read from the database:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
/**
* The model's default values for attributes.
*
* @var array
*/
protected $attributes = [
'options' => '[]',
'delayed' => false,
];
}

Configuring Eloquent Strictness

Laravel offers several methods that allow you to configure Eloquent's behavior and "strictness" in a variety of situations.
First, the preventLazyLoading method accepts an optional boolean argument that indicates if lazy loading should be
prevented. For example, you may wish to only disable lazy loading in non-production environments so that your production
environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code.
Typically, this method should be invoked in the boot method of your application's AppServiceProvider :

Page 811 of 1307

Laravel 9.x

use Illuminate\Database\Eloquent\Model;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Model::preventLazyLoading(! $this->app->isProduction());
}

Also, you may instruct Laravel to throw an exception when attempting to fill an unfillable attribute by invoking the
preventSilentlyDiscardingAttributes method. This can help prevent unexpected errors during local development
when attempting to set an attribute that has not been added to the model's fillable array:
Model::preventSilentlyDiscardingAttributes(! $this->app->isProduction());

Finally, you may instruct Eloquent to throw an exception if you attempt to access an attribute on a model when that
attribute was not actually retrieved from the database or when the attribute does not exist. For example, this may occur
when you forget to add an attribute to the select clause of an Eloquent query:
Model::preventAccessingMissingAttributes(! $this->app->isProduction());

Enabling Eloquent "Strict Mode"
For convenience, you may enable all three of the methods discussed above by simply invoking the shouldBeStrict
method:
Model::shouldBeStrict(! $this->app->isProduction());

Retrieving Models

Once you have created a model and its associated database table, you are ready to start retrieving data from your
database. You can think of each Eloquent model as a powerful query builder allowing you to fluently query the database
table associated with the model. The model's all method will retrieve all of the records from the model's associated
database table:
use App\Models\Flight;
foreach (Flight::all() as $flight) {
echo $flight->name;
}

Building Queries
The Eloquent all method will return all of the results in the model's table. However, since each Eloquent model serves as
a query builder, you may add additional constraints to queries and then invoke the get method to retrieve the results:

Page 812 of 1307

Laravel 9.x

$flights = Flight::where('active', 1)
->orderBy('name')
->take(10)
->get();

Since Eloquent models are query builders, you should review all of the methods provided by
Laravel's query builder. You may use any of these methods when writing your Eloquent queries.
Refreshing Models
If you already have an instance of an Eloquent model that was retrieved from the database, you can "refresh" the model
using the fresh and refresh methods. The fresh method will re-retrieve the model from the database. The existing
model instance will not be affected:
$flight = Flight::where('number', 'FR 900')->first();
$freshFlight = $flight->fresh();

The refresh method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded
relationships will be refreshed as well:
$flight = Flight::where('number', 'FR 900')->first();
$flight->number = 'FR 456';
$flight->refresh();
$flight->number; // "FR 900"

Collections

As we have seen, Eloquent methods like all and get retrieve multiple records from the database. However, these
methods don't return a plain PHP array. Instead, an instance of Illuminate\Database\Eloquent\Collection is
returned.
The Eloquent Collection class extends Laravel's base Illuminate\Support\Collection class, which provides a
variety of helpful methods for interacting with data collections. For example, the reject method may be used to remove
models from a collection based on the results of an invoked closure:
$flights = Flight::where('destination', 'Paris')->get();
$flights = $flights->reject(function ($flight) {
return $flight->cancelled;
});

In addition to the methods provided by Laravel's base collection class, the Eloquent collection class provides a few extra
methods that are specifically intended for interacting with collections of Eloquent models.
Since all of Laravel's collections implement PHP's iterable interfaces, you may loop over collections as if they were an
array:

Page 813 of 1307

Laravel 9.x

foreach ($flights as $flight) {
echo $flight->name;
}

Chunking Results

Your application may run out of memory if you attempt to load tens of thousands of Eloquent records via the all or get
methods. Instead of using these methods, the chunk method may be used to process large numbers of models more
efficiently.
The chunk method will retrieve a subset of Eloquent models, passing them to a closure for processing. Since only the
current chunk of Eloquent models is retrieved at a time, the chunk method will provide significantly reduced memory
usage when working with a large number of models:
use App\Models\Flight;
Flight::chunk(200, function ($flights) {
foreach ($flights as $flight) {
//
}
});

The first argument passed to the chunk method is the number of records you wish to receive per "chunk". The closure
passed as the second argument will be invoked for each chunk that is retrieved from the database. A database query will
be executed to retrieve each chunk of records passed to the closure.
If you are filtering the results of the chunk method based on a column that you will also be updating while iterating over
the results, you should use the chunkById method. Using the chunk method in these scenarios could lead to
unexpected and inconsistent results. Internally, the chunkById method will always retrieve models with an id column
greater than the last model in the previous chunk:
Flight::where('departed', true)
->chunkById(200, function ($flights) {
$flights->each->update(['departed' => false]);
}, $column = 'id');

Chunking Using Lazy Collections

The lazy method works similarly to the chunk method in the sense that, behind the scenes, it executes the query in
chunks. However, instead of passing each chunk directly into a callback as is, the lazy method returns a flattened
LazyCollection of Eloquent models, which lets you interact with the results as a single stream:
use App\Models\Flight;
foreach (Flight::lazy() as $flight) {
//
}

If you are filtering the results of the lazy method based on a column that you will also be updating while iterating over
the results, you should use the lazyById method. Internally, the lazyById method will always retrieve models with an
id column greater than the last model in the previous chunk:

Page 814 of 1307

Laravel 9.x

Flight::where('departed', true)
->lazyById(200, $column = 'id')
->each->update(['departed' => false]);

You may filter the results based on the descending order of the id using the lazyByIdDesc method.

Cursors

Similar to the lazy method, the cursor method may be used to significantly reduce your application's memory
consumption when iterating through tens of thousands of Eloquent model records.
The cursor method will only execute a single database query; however, the individual Eloquent models will not be
hydrated until they are actually iterated over. Therefore, only one Eloquent model is kept in memory at any given time while
iterating over the cursor.
Since the cursor method only ever holds a single Eloquent model in memory at a time, it cannot
eager load relationships. If you need to eager load relationships, consider using the lazy method
instead.
Internally, the cursor method uses PHP generators to implement this functionality:
use App\Models\Flight;
foreach (Flight::where('destination', 'Zurich')->cursor() as $flight) {
//
}

The cursor returns an Illuminate\Support\LazyCollection instance. Lazy collections allow you to use many of the
collection methods available on typical Laravel collections while only loading a single model into memory at a time:
use App\Models\User;
$users = User::cursor()->filter(function ($user) {
return $user->id > 500;
});
foreach ($users as $user) {
echo $user->id;
}

Although the cursor method uses far less memory than a regular query (by only holding a single Eloquent model in
memory at a time), it will still eventually run out of memory. This is due to PHP's PDO driver internally caching all raw query
results in its buffer. If you're dealing with a very large number of Eloquent records, consider using the lazy method
instead.

Advanced Subqueries

Subquery Selects
Eloquent also offers advanced subquery support, which allows you to pull information from related tables in a single query.
For example, let's imagine that we have a table of flight destinations and a table of flights to destinations. The
flights table contains an arrived_at column which indicates when the flight arrived at the destination.
Page 815 of 1307

Laravel 9.x

Using the subquery functionality available to the query builder's select and addSelect methods, we can select all of
the destinations and the name of the flight that most recently arrived at that destination using a single query:
use App\Models\Destination;
use App\Models\Flight;
return Destination::addSelect(['last_flight' => Flight::select('name')
->whereColumn('destination_id', 'destinations.id')
->orderByDesc('arrived_at')
->limit(1)
])->get();

Subquery Ordering
In addition, the query builder's orderBy function supports subqueries. Continuing to use our flight example, we may use
this functionality to sort all destinations based on when the last flight arrived at that destination. Again, this may be done
while executing a single database query:
return Destination::orderByDesc(
Flight::select('arrived_at')
->whereColumn('destination_id', 'destinations.id')
->orderByDesc('arrived_at')
->limit(1)
)->get();

Retrieving Single Models / Aggregates

In addition to retrieving all of the records matching a given query, you may also retrieve single records using the find ,
first , or firstWhere methods. Instead of returning a collection of models, these methods return a single model
instance:
use App\Models\Flight;
// Retrieve a model by its primary key...
$flight = Flight::find(1);
// Retrieve the first model matching the query constraints...
$flight = Flight::where('active', 1)->first();
// Alternative to retrieving the first model matching the query constraints...
$flight = Flight::firstWhere('active', 1);

Sometimes you may wish to perform some other action if no results are found. The findOr and firstOr methods will
return a single model instance or, if no results are found, execute the given closure. The value returned by the closure will
be considered the result of the method:
$flight = Flight::findOr(1, function () {
// ...
});
$flight = Flight::where('legs', '>', 3)->firstOr(function () {
// ...
});

Page 816 of 1307

Laravel 9.x

Not Found Exceptions
Sometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers.
The findOrFail and firstOrFail methods will retrieve the first result of the query; however, if no result is found, an
Illuminate\Database\Eloquent\ModelNotFoundException will be thrown:
$flight = Flight::findOrFail(1);
$flight = Flight::where('legs', '>', 3)->firstOrFail();

If the ModelNotFoundException is not caught, a 404 HTTP response is automatically sent back to the client:
use App\Models\Flight;
Route::get('/api/flights/{id}', function ($id) {
return Flight::findOrFail($id);
});

Retrieving Or Creating Models

The firstOrCreate method will attempt to locate a database record using the given column / value pairs. If the model
can not be found in the database, a record will be inserted with the attributes resulting from merging the first array
argument with the optional second array argument:
The firstOrNew method, like firstOrCreate , will attempt to locate a record in the database matching the given
attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by
firstOrNew has not yet been persisted to the database. You will need to manually call the save method to persist it:
use App\Models\Flight;
// Retrieve flight by name or create it if it doesn't exist...
$flight = Flight::firstOrCreate([
'name' => 'London to Paris'
]);
// Retrieve flight by name or create it with the name, delayed, and arrival_time attributes...
$flight = Flight::firstOrCreate(
['name' => 'London to Paris'],
['delayed' => 1, 'arrival_time' => '11:30']
);
// Retrieve flight by name or instantiate a new Flight instance...
$flight = Flight::firstOrNew([
'name' => 'London to Paris'
]);
// Retrieve flight by name or instantiate with the name, delayed, and arrival_time attributes...
$flight = Flight::firstOrNew(
['name' => 'Tokyo to Sydney'],
['delayed' => 1, 'arrival_time' => '11:30']
);

Retrieving Aggregates

Page 817 of 1307

Laravel 9.x

When interacting with Eloquent models, you may also use the count , sum , max , and other aggregate methods
provided by the Laravel query builder. As you might expect, these methods return a scalar value instead of an Eloquent
model instance:
$count = Flight::where('active', 1)->count();
$max = Flight::where('active', 1)->max('price');

Inserting & Updating Models
Inserts

Of course, when using Eloquent, we don't only need to retrieve models from the database. We also need to insert new
records. Thankfully, Eloquent makes it simple. To insert a new record into the database, you should instantiate a new model
instance and set attributes on the model. Then, call the save method on the model instance:
<?php
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Flight;
use Illuminate\Http\Request;
class FlightController extends Controller
{
/**
* Store a new flight in the database.
*
* @param

\Illuminate\Http\Request

$request

* @return \Illuminate\Http\Response
*/
public function store(Request $request)
{
// Validate the request...
$flight = new Flight;
$flight->name = $request->name;
$flight->save();
}
}

In this example, we assign the name field from the incoming HTTP request to the name attribute of the
App\Models\Flight model instance. When we call the save method, a record will be inserted into the database. The
model's created_at and updated_at timestamps will automatically be set when the save method is called, so there
is no need to set them manually.
Alternatively, you may use the create method to "save" a new model using a single PHP statement. The inserted model
instance will be returned to you by the create method:

Page 818 of 1307

Laravel 9.x

use App\Models\Flight;
$flight = Flight::create([
'name' => 'London to Paris',
]);

However, before using the create method, you will need to specify either a fillable or guarded property on your
model class. These properties are required because all Eloquent models are protected against mass assignment
vulnerabilities by default. To learn more about mass assignment, please consult the mass assignment documentation.

Updates

The save method may also be used to update models that already exist in the database. To update a model, you should
retrieve it and set any attributes you wish to update. Then, you should call the model's save method. Again, the
updated_at timestamp will automatically be updated, so there is no need to manually set its value:
use App\Models\Flight;
$flight = Flight::find(1);
$flight->name = 'Paris to London';
$flight->save();

Mass Updates
Updates can also be performed against models that match a given query. In this example, all flights that are active and
have a destination of San Diego will be marked as delayed:
Flight::where('active', 1)
->where('destination', 'San Diego')
->update(['delayed' => 1]);

The update method expects an array of column and value pairs representing the columns that should be updated. The
update method returns the number of affected rows.
When issuing a mass update via Eloquent, the saving , saved , updating , and updated
model events will not be fired for the updated models. This is because the models are never
actually retrieved when issuing a mass update.
Examining Attribute Changes
Eloquent provides the isDirty , isClean , and wasChanged methods to examine the internal state of your model and
determine how its attributes have changed from when the model was originally retrieved.
The isDirty method determines if any of the model's attributes have been changed since the model was retrieved. You
may pass a specific attribute name or an array of attributes to the isDirty method to determine if any of the attributes
are "dirty". The isClean method will determine if an attribute has remained unchanged since the model was retrieved.
This method also accepts an optional attribute argument:

Page 819 of 1307

Laravel 9.x

use App\Models\User;
$user = User::create([
'first_name' => 'Taylor',
'last_name' => 'Otwell',
'title' => 'Developer',
]);
$user->title = 'Painter';
$user->isDirty(); // true
$user->isDirty('title'); // true
$user->isDirty('first_name'); // false
$user->isDirty(['first_name', 'title']); // true
$user->isClean(); // false
$user->isClean('title'); // false
$user->isClean('first_name'); // true
$user->isClean(['first_name', 'title']); // false
$user->save();
$user->isDirty(); // false
$user->isClean(); // true

The wasChanged method determines if any attributes were changed when the model was last saved within the current
request cycle. If needed, you may pass an attribute name to see if a particular attribute was changed:
$user = User::create([
'first_name' => 'Taylor',
'last_name' => 'Otwell',
'title' => 'Developer',
]);
$user->title = 'Painter';
$user->save();
$user->wasChanged(); // true
$user->wasChanged('title'); // true
$user->wasChanged(['title', 'slug']); // true
$user->wasChanged('first_name'); // false
$user->wasChanged(['first_name', 'title']); // true

The getOriginal method returns an array containing the original attributes of the model regardless of any changes to
the model since it was retrieved. If needed, you may pass a specific attribute name to get the original value of a particular
attribute:

Page 820 of 1307

Laravel 9.x

$user = User::find(1);
$user->name; // John
$user->email; // john@example.com
$user->name = "Jack";
$user->name; // Jack
$user->getOriginal('name'); // John
$user->getOriginal(); // Array of original attributes...

Mass Assignment

You may use the create method to "save" a new model using a single PHP statement. The inserted model instance will
be returned to you by the method:
use App\Models\Flight;
$flight = Flight::create([
'name' => 'London to Paris',
]);

However, before using the create method, you will need to specify either a fillable or guarded property on your
model class. These properties are required because all Eloquent models are protected against mass assignment
vulnerabilities by default.
A mass assignment vulnerability occurs when a user passes an unexpected HTTP request field and that field changes a
column in your database that you did not expect. For example, a malicious user might send an is_admin parameter
through an HTTP request, which is then passed to your model's create method, allowing the user to escalate
themselves to an administrator.
So, to get started, you should define which model attributes you want to make mass assignable. You may do this using the
$fillable property on the model. For example, let's make the name attribute of our Flight model mass assignable:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model
{
/**
* The attributes that are mass assignable.
*
* @var array
*/
protected $fillable = ['name'];
}

Once you have specified which attributes are mass assignable, you may use the create method to insert a new record in
the database. The create method returns the newly created model instance:
$flight = Flight::create(['name' => 'London to Paris']);

Page 821 of 1307

Laravel 9.x

If you already have a model instance, you may use the fill method to populate it with an array of attributes:
$flight->fill(['name' => 'Amsterdam to Frankfurt']);

Mass Assignment & JSON Columns
When assigning JSON columns, each column's mass assignable key must be specified in your model's $fillable array.
For security, Laravel does not support updating nested JSON attributes when using the guarded property:
/**
* The attributes that are mass assignable.
*
* @var array
*/
protected $fillable = [
'options->enabled',
];

Allowing Mass Assignment
If you would like to make all of your attributes mass assignable, you may define your model's $guarded property as an
empty array. If you choose to unguard your model, you should take special care to always hand-craft the arrays passed to
Eloquent's fill , create , and update methods:
/**
* The attributes that aren't mass assignable.
*
* @var array
*/
protected $guarded = [];

Mass Assignment Exceptions
By default, attributes that are not included in the $fillable array are silently discarded when performing massassignment operations. In production, this is expected behavior; however, during local development it can lead to
confusion as to why model changes are not taking effect.
If you wish, you may instruct Laravel to throw an exception when attempting to fill an unfillable attribute by invoking the
preventSilentlyDiscardingAttributes method. Typically, this method should be invoked within the boot method
of one of your application's service providers:
use Illuminate\Database\Eloquent\Model;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Model::preventSilentlyDiscardingAttributes($this->app->isLocal());
}

Upserts
Page 822 of 1307

Laravel 9.x

Occasionally, you may need to update an existing model or create a new model if no matching model exists. Like the
firstOrCreate method, the updateOrCreate method persists the model, so there's no need to manually call the
save method.
In the example below, if a flight exists with a departure location of Oakland and a destination location of San
Diego , its price and discounted columns will be updated. If no such flight exists, a new flight will be created which
has the attributes resulting from merging the first argument array with the second argument array:
$flight = Flight::updateOrCreate(
['departure' => 'Oakland', 'destination' => 'San Diego'],
['price' => 99, 'discounted' => 1]
);

If you would like to perform multiple "upserts" in a single query, then you should use the upsert method instead. The
method's first argument consists of the values to insert or update, while the second argument lists the column(s) that
uniquely identify records within the associated table. The method's third and final argument is an array of the columns that
should be updated if a matching record already exists in the database. The upsert method will automatically set the
created_at and updated_at timestamps if timestamps are enabled on the model:
Flight::upsert([
['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
], ['departure', 'destination'], ['price']);

All databases except SQL Server require the columns in the second argument of the upsert
method to have a "primary" or "unique" index. In addition, the MySQL database driver ignores the
second argument of the upsert method and always uses the "primary" and "unique" indexes of
the table to detect existing records.

Deleting Models

To delete a model, you may call the delete method on the model instance:
use App\Models\Flight;
$flight = Flight::find(1);
$flight->delete();

You may call the truncate method to delete all of the model's associated database records. The truncate operation
will also reset any auto-incrementing IDs on the model's associated table:
Flight::truncate();

Deleting An Existing Model By Its Primary Key
In the example above, we are retrieving the model from the database before calling the delete method. However, if you
know the primary key of the model, you may delete the model without explicitly retrieving it by calling the destroy
method. In addition to accepting the single primary key, the destroy method will accept multiple primary keys, an array
of primary keys, or a collection of primary keys:
Page 823 of 1307

Laravel 9.x

Flight::destroy(1);
Flight::destroy(1, 2, 3);
Flight::destroy([1, 2, 3]);
Flight::destroy(collect([1, 2, 3]));

The destroy method loads each model individually and calls the delete method so that the
deleting and deleted events are properly dispatched for each model.
Deleting Models Using Queries
Of course, you may build an Eloquent query to delete all models matching your query's criteria. In this example, we will
delete all flights that are marked as inactive. Like mass updates, mass deletes will not dispatch model events for the
models that are deleted:
$deleted = Flight::where('active', 0)->delete();

When executing a mass delete statement via Eloquent, the deleting and deleted model
events will not be dispatched for the deleted models. This is because the models are never actually
retrieved when executing the delete statement.

Soft Deleting

In addition to actually removing records from your database, Eloquent can also "soft delete" models. When models are soft
deleted, they are not actually removed from your database. Instead, a deleted_at attribute is set on the model
indicating the date and time at which the model was "deleted". To enable soft deletes for a model, add the
Illuminate\Database\Eloquent\SoftDeletes trait to the model:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
class Flight extends Model
{
use SoftDeletes;
}

The SoftDeletes trait will automatically cast the deleted_at attribute to a DateTime /
Carbon instance for you.

Page 824 of 1307

Laravel 9.x

You should also add the deleted_at column to your database table. The Laravel schema builder contains a helper
method to create this column:
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::table('flights', function (Blueprint $table) {
$table->softDeletes();
});
Schema::table('flights', function (Blueprint $table) {
$table->dropSoftDeletes();
});

Now, when you call the delete method on the model, the deleted_at column will be set to the current date and time.
However, the model's database record will be left in the table. When querying a model that uses soft deletes, the soft
deleted models will automatically be excluded from all query results.
To determine if a given model instance has been soft deleted, you may use the trashed method:
if ($flight->trashed()) {
//
}

Restoring Soft Deleted Models
Sometimes you may wish to "un-delete" a soft deleted model. To restore a soft deleted model, you may call the restore
method on a model instance. The restore method will set the model's deleted_at column to null :
$flight->restore();

You may also use the restore method in a query to restore multiple models. Again, like other "mass" operations, this will
not dispatch any model events for the models that are restored:
Flight::withTrashed()
->where('airline_id', 1)
->restore();

The restore method may also be used when building relationship queries:
$flight->history()->restore();

Permanently Deleting Models
Sometimes you may need to truly remove a model from your database. You may use the forceDelete method to
permanently remove a soft deleted model from the database table:
$flight->forceDelete();

You may also use the forceDelete method when building Eloquent relationship queries:
$flight->history()->forceDelete();

Page 825 of 1307

Laravel 9.x

Querying Soft Deleted Models

Including Soft Deleted Models
As noted above, soft deleted models will automatically be excluded from query results. However, you may force soft
deleted models to be included in a query's results by calling the withTrashed method on the query:
use App\Models\Flight;
$flights = Flight::withTrashed()
->where('account_id', 1)
->get();

The withTrashed method may also be called when building a relationship query:
$flight->history()->withTrashed()->get();

Retrieving Only Soft Deleted Models
The onlyTrashed method will retrieve only soft deleted models:
$flights = Flight::onlyTrashed()
->where('airline_id', 1)
->get();

Pruning Models

Sometimes you may want to periodically delete models that are no longer needed. To accomplish this, you may add the
Illuminate\Database\Eloquent\Prunable or Illuminate\Database\Eloquent\MassPrunable trait to the models
you would like to periodically prune. After adding one of the traits to the model, implement a prunable method which
returns an Eloquent query builder that resolves the models that are no longer needed:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Prunable;
class Flight extends Model
{
use Prunable;
/**
* Get the prunable model query.
*
* @return \Illuminate\Database\Eloquent\Builder
*/
public function prunable()
{
return static::where('created_at', '<=', now()->subMonth());
}
}

Page 826 of 1307

Laravel 9.x

When marking models as Prunable , you may also define a pruning method on the model. This method will be called
before the model is deleted. This method can be useful for deleting any additional resources associated with the model,
such as stored files, before the model is permanently removed from the database:
/**
* Prepare the model for pruning.
*
* @return void
*/
protected function pruning()
{
//
}

After configuring your prunable model, you should schedule the model:prune Artisan command in your application's
App\Console\Kernel class. You are free to choose the appropriate interval at which this command should be run:
/**
* Define the application's command schedule.
*
* @param

\Illuminate\Console\Scheduling\Schedule

$schedule

* @return void
*/
protected function schedule(Schedule $schedule)
{
$schedule->command('model:prune')->daily();
}

Behind the scenes, the model:prune command will automatically detect "Prunable" models within your application's
app/Models directory. If your models are in a different location, you may use the --model option to specify the model
class names:
$schedule->command('model:prune', [
'--model' => [Address::class, Flight::class],
])->daily();

If you wish to exclude certain models from being pruned while pruning all other detected models, you may use the -option:

except

$schedule->command('model:prune', [
'--except' => [Address::class, Flight::class],
])->daily();

You may test your prunable query by executing the model:prune command with the --pretend option. When
pretending, the model:prune command will simply report how many records would be pruned if the command were to
actually run:
php artisan model:prune --pretend

Page 827 of 1307

Laravel 9.x

Soft deleting models will be permanently deleted ( forceDelete ) if they match the prunable
query.
Mass Pruning
When models are marked with the Illuminate\Database\Eloquent\MassPrunable trait, models are deleted from the
database using mass-deletion queries. Therefore, the pruning method will not be invoked, nor will the deleting and
deleted model events be dispatched. This is because the models are never actually retrieved before deletion, thus
making the pruning process much more efficient:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\MassPrunable;
class Flight extends Model
{
use MassPrunable;
/**
* Get the prunable model query.
*
* @return \Illuminate\Database\Eloquent\Builder
*/
public function prunable()
{
return static::where('created_at', '<=', now()->subMonth());
}
}

Replicating Models

You may create an unsaved copy of an existing model instance using the replicate method. This method is particularly
useful when you have model instances that share many of the same attributes:

Page 828 of 1307

Laravel 9.x

use App\Models\Address;
$shipping = Address::create([
'type' => 'shipping',
'line_1' => '123 Example Street',
'city' => 'Victorville',
'state' => 'CA',
'postcode' => '90001',
]);
$billing = $shipping->replicate()->fill([
'type' => 'billing'
]);
$billing->save();

To exclude one or more attributes from being replicated to the new model, you may pass an array to the replicate
method:
$flight = Flight::create([
'destination' => 'LAX',
'origin' => 'LHR',
'last_flown' => '2020-03-04 11:00:00',
'last_pilot_id' => 747,
]);
$flight = $flight->replicate([
'last_flown',
'last_pilot_id'
]);

Query Scopes
Global Scopes

Global scopes allow you to add constraints to all queries for a given model. Laravel's own soft delete functionality utilizes
global scopes to only retrieve "non-deleted" models from the database. Writing your own global scopes can provide a
convenient, easy way to make sure every query for a given model receives certain constraints.
Writing Global Scopes
Writing a global scope is simple. First, define a class that implements the Illuminate\Database\Eloquent\Scope
interface. Laravel does not have a conventional location where you should place scope classes, so you are free to place
this class in any directory that you wish.
The Scope interface requires you to implement one method: apply . The apply method may add where constraints
or other types of clauses to the query as needed:

Page 829 of 1307

Laravel 9.x

<?php
namespace App\Models\Scopes;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;
class AncientScope implements Scope
{
/**
* Apply the scope to a given Eloquent query builder.
*
* @param

\Illuminate\Database\Eloquent\Builder

* @param

\Illuminate\Database\Eloquent\Model

$builder

$model

* @return void
*/
public function apply(Builder $builder, Model $model)
{
$builder->where('created_at', '<', now()->subYears(2000));
}
}

If your global scope is adding columns to the select clause of the query, you should use the
addSelect method instead of select . This will prevent the unintentional replacement of the
query's existing select clause.
Applying Global Scopes
To assign a global scope to a model, you should override the model's booted method and invoke the model's
addGlobalScope method. The addGlobalScope method accepts an instance of your scope as its only argument:
<?php
namespace App\Models;
use App\Models\Scopes\AncientScope;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* The "booted" method of the model.
*
* @return void
*/
protected static function booted()
{
static::addGlobalScope(new AncientScope);
}
}

Page 830 of 1307

Laravel 9.x

After adding the scope in the example above to the App\Models\User model, a call to the User::all() method will
execute the following SQL query:
select * from `users` where `created_at` < 0021-02-18 00:00:00

Anonymous Global Scopes
Eloquent also allows you to define global scopes using closures, which is particularly useful for simple scopes that do not
warrant a separate class of their own. When defining a global scope using a closure, you should provide a scope name of
your own choosing as the first argument to the addGlobalScope method:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* The "booted" method of the model.
*
* @return void
*/
protected static function booted()
{
static::addGlobalScope('ancient', function (Builder $builder) {
$builder->where('created_at', '<', now()->subYears(2000));
});
}
}

Removing Global Scopes
If you would like to remove a global scope for a given query, you may use the withoutGlobalScope method. This method
accepts the class name of the global scope as its only argument:
User::withoutGlobalScope(AncientScope::class)->get();

Or, if you defined the global scope using a closure, you should pass the string name that you assigned to the global scope:
User::withoutGlobalScope('ancient')->get();

If you would like to remove several or even all of the query's global scopes, you may use the withoutGlobalScopes
method:

Page 831 of 1307

Laravel 9.x

// Remove all of the global scopes...
User::withoutGlobalScopes()->get();
// Remove some of the global scopes...
User::withoutGlobalScopes([
FirstScope::class, SecondScope::class
])->get();

Local Scopes

Local scopes allow you to define common sets of query constraints that you may easily re-use throughout your application.
For example, you may need to frequently retrieve all users that are considered "popular". To define a scope, prefix an
Eloquent model method with scope .
Scopes should always return the same query builder instance or void :
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* Scope a query to only include popular users.
*
* @param

\Illuminate\Database\Eloquent\Builder

$query

* @return \Illuminate\Database\Eloquent\Builder
*/
public function scopePopular($query)
{
return $query->where('votes', '>', 100);
}
/**
* Scope a query to only include active users.
*
* @param

\Illuminate\Database\Eloquent\Builder

$query

* @return void
*/
public function scopeActive($query)
{
$query->where('active', 1);
}
}

Utilizing A Local Scope
Once the scope has been defined, you may call the scope methods when querying the model. However, you should not
include the scope prefix when calling the method. You can even chain calls to various scopes:

Page 832 of 1307

Laravel 9.x

use App\Models\User;
$users = User::popular()->active()->orderBy('created_at')->get();

Combining multiple Eloquent model scopes via an or query operator may require the use of closures to achieve the
correct logical grouping:
$users = User::popular()->orWhere(function (Builder $query) {
$query->active();
})->get();

However, since this can be cumbersome, Laravel provides a "higher order" orWhere method that allows you to fluently
chain scopes together without the use of closures:
$users = App\Models\User::popular()->orWhere->active()->get();

Dynamic Scopes
Sometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to
your scope method's signature. Scope parameters should be defined after the $query parameter:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* Scope a query to only include users of a given type.
*
* @param

\Illuminate\Database\Eloquent\Builder

* @param

mixed

$query

$type

* @return \Illuminate\Database\Eloquent\Builder
*/
public function scopeOfType($query, $type)
{
return $query->where('type', $type);
}
}

Once the expected arguments have been added to your scope method's signature, you may pass the arguments when
calling the scope:
$users = User::ofType('admin')->get();

Comparing Models

Sometimes you may need to determine if two models are the "same" or not. The is and isNot methods may be used
to quickly verify two models have the same primary key, table, and database connection or not:

Page 833 of 1307

Laravel 9.x

if ($post->is($anotherPost)) {
//
}
if ($post->isNot($anotherPost)) {
//
}

The is and isNot methods are also available when using the belongsTo , hasOne , morphTo , and morphOne
relationships. This method is particularly helpful when you would like to compare a related model without issuing a query to
retrieve that model:
if ($post->author()->is($user)) {
//
}

Events
Want to broadcast your Eloquent events directly to your client-side application? Check out
Laravel's model event broadcasting.
Eloquent models dispatch several events, allowing you to hook into the following moments in a model's lifecycle:
retrieved , creating , created , updating , updated , saving , saved , deleting , deleted , trashed ,
forceDeleting , forceDeleted , restoring , restored , and replicating .
The retrieved event will dispatch when an existing model is retrieved from the database. When a new model is saved
for the first time, the creating and created events will dispatch. The updating / updated events will dispatch
when an existing model is modified and the save method is called. The saving / saved events will dispatch when a
model is created or updated - even if the model's attributes have not been changed. Event names ending with -ing are
dispatched before any changes to the model are persisted, while events ending with -ed are dispatched after the
changes to the model are persisted.
To start listening to model events, define a $dispatchesEvents property on your Eloquent model. This property maps
various points of the Eloquent model's lifecycle to your own event classes. Each model event class should expect to
receive an instance of the affected model via its constructor:

Page 834 of 1307

Laravel 9.x

<?php
namespace App\Models;
use App\Events\UserDeleted;
use App\Events\UserSaved;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable
{
use Notifiable;
/**
* The event map for the model.
*
* @var array
*/
protected $dispatchesEvents = [
'saved' => UserSaved::class,
'deleted' => UserDeleted::class,
];
}

After defining and mapping your Eloquent events, you may use event listeners to handle the events.
When issuing a mass update or delete query via Eloquent, the saved , updated , deleting ,
and deleted model events will not be dispatched for the affected models. This is because the
models are never actually retrieved when performing mass updates or deletes.

Using Closures

Instead of using custom event classes, you may register closures that execute when various model events are dispatched.
Typically, you should register these closures in the booted method of your model:

Page 835 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* The "booted" method of the model.
*
* @return void
*/
protected static function booted()
{
static::created(function ($user) {
//
});
}
}

If needed, you may utilize queueable anonymous event listeners when registering model events. This will instruct Laravel to
execute the model event listener in the background using your application's queue:
use function Illuminate\Events\queueable;
static::created(queueable(function ($user) {
//
}));

Observers

Defining Observers
If you are listening for many events on a given model, you may use observers to group all of your listeners into a single
class. Observer classes have method names which reflect the Eloquent events you wish to listen for. Each of these
methods receives the affected model as their only argument. The make:observer Artisan command is the easiest way to
create a new observer class:
php artisan make:observer UserObserver --model=User

This command will place the new observer in your app/Observers directory. If this directory does not exist, Artisan will
create it for you. Your fresh observer will look like the following:

Page 836 of 1307

Laravel 9.x

<?php
namespace App\Observers;
use App\Models\User;
class UserObserver
{
/**
* Handle the User "created" event.
*
* @param

\App\Models\User

$user

* @return void
*/
public function created(User $user)
{
//
}
/**
* Handle the User "updated" event.
*
* @param

\App\Models\User

$user

* @return void
*/
public function updated(User $user)
{
//
}
/**
* Handle the User "deleted" event.
*
* @param

\App\Models\User

$user

* @return void
*/
public function deleted(User $user)
{
//
}
/**
* Handle the User "restored" event.
*
* @param

\App\Models\User

$user

* @return void
*/
public function restored(User $user)
{
//
}
/**
* Handle the User "forceDeleted" event.
*
* @param

\App\Models\User

$user

Page 837 of 1307

Laravel 9.x

* @return void
*/
public function forceDeleted(User $user)
{
//
}
}

To register an observer, you need to call the observe method on the model you wish to observe. You may register
observers in the boot method of your application's App\Providers\EventServiceProvider service provider:
use App\Models\User;
use App\Observers\UserObserver;
/**
* Register any events for your application.
*
* @return void
*/
public function boot()
{
User::observe(UserObserver::class);
}

Alternatively, you may list your observers within an $observers property of your applications'
App\Providers\EventServiceProvider class:
use App\Models\User;
use App\Observers\UserObserver;
/**
* The model observers for your application.
*
* @var array
*/
protected $observers = [
User::class => [UserObserver::class],
];

There are additional events an observer can listen to, such as saving and retrieved . These
events are described within the events documentation.
Observers & Database Transactions
When models are being created within a database transaction, you may want to instruct an observer to only execute its
event handlers after the database transaction is committed. You may accomplish this by defining an $afterCommit
property on the observer. If a database transaction is not in progress, the event handlers will execute immediately:

Page 838 of 1307

Laravel 9.x

<?php
namespace App\Observers;
use App\Models\User;
class UserObserver
{
/**
* Handle events after all transactions are committed.
*
* @var bool
*/
public $afterCommit = true;
/**
* Handle the User "created" event.
*
* @param

\App\Models\User

$user

* @return void
*/
public function created(User $user)
{
//
}
}

Muting Events

You may occasionally need to temporarily "mute" all events fired by a model. You may achieve this using the
withoutEvents method. The withoutEvents method accepts a closure as its only argument. Any code executed
within this closure will not dispatch model events, and any value returned by the closure will be returned by the
withoutEvents method:
use App\Models\User;
$user = User::withoutEvents(function () {
User::findOrFail(1)->delete();
return User::find(2);
});

Saving A Single Model Without Events
Sometimes you may wish to "save" a given model without dispatching any events. You may accomplish this using the
saveQuietly method:
$user = User::findOrFail(1);
$user->name = 'Victoria Faith';
$user->saveQuietly();

You may also "update", "delete", "soft delete", "restore", and "replicate" a given model without dispatching any events:
Page 839 of 1307

Laravel 9.x

$user->deleteQuietly();
$user->forceDeleteQuietly();
$user->restoreQuietly();

Page 840 of 1307

Laravel 9.x

Eloquent: Relationships

Introduction
Defining Relationships
One To One
One To Many
One To Many (Inverse) / Belongs To
Has One Of Many
Has One Through
Has Many Through
Many To Many Relationships
Retrieving Intermediate Table Columns
Filtering Queries Via Intermediate Table Columns
Ordering Queries Via Intermediate Table Columns
Defining Custom Intermediate Table Models
Polymorphic Relationships
One To One
One To Many
One Of Many
Many To Many
Custom Polymorphic Types
Dynamic Relationships
Querying Relations
Relationship Methods Vs. Dynamic Properties
Querying Relationship Existence
Querying Relationship Absence
Querying Morph To Relationships
Aggregating Related Models
Counting Related Models
Other Aggregate Functions
Counting Related Models On Morph To Relationships
Eager Loading
Constraining Eager Loads
Lazy Eager Loading
Preventing Lazy Loading
Inserting & Updating Related Models
The save Method
The create Method
Belongs To Relationships
Many To Many Relationships
Touching Parent Timestamps

Introduction

Database tables are often related to one another. For example, a blog post may have many comments or an order could be
related to the user who placed it. Eloquent makes managing and working with these relationships easy, and supports a
variety of common relationships:
One To One
One To Many
Many To Many
Page 841 of 1307

Laravel 9.x

Has One Through
Has Many Through
One To One (Polymorphic)
One To Many (Polymorphic)
Many To Many (Polymorphic)

Defining Relationships

Eloquent relationships are defined as methods on your Eloquent model classes. Since relationships also serve as powerful
query builders, defining relationships as methods provides powerful method chaining and querying capabilities. For
example, we may chain additional query constraints on this posts relationship:
$user->posts()->where('active', 1)->get();

But, before diving too deep into using relationships, let's learn how to define each type of relationship supported by
Eloquent.

One To One

A one-to-one relationship is a very basic type of database relationship. For example, a User model might be associated
with one Phone model. To define this relationship, we will place a phone method on the User model. The phone
method should call the hasOne method and return its result. The hasOne method is available to your model via the
model's Illuminate\Database\Eloquent\Model base class:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* Get the phone associated with the user.
*/
public function phone()
{
return $this->hasOne(Phone::class);
}
}

The first argument passed to the hasOne method is the name of the related model class. Once the relationship is defined,
we may retrieve the related record using Eloquent's dynamic properties. Dynamic properties allow you to access
relationship methods as if they were properties defined on the model:
$phone = User::find(1)->phone;

Eloquent determines the foreign key of the relationship based on the parent model name. In this case, the Phone model is
automatically assumed to have a user_id foreign key. If you wish to override this convention, you may pass a second
argument to the hasOne method:
return $this->hasOne(Phone::class, 'foreign_key');

Page 842 of 1307

Laravel 9.x

Additionally, Eloquent assumes that the foreign key should have a value matching the primary key column of the parent. In
other words, Eloquent will look for the value of the user's id column in the user_id column of the Phone record. If
you would like the relationship to use a primary key value other than id or your model's $primaryKey property, you
may pass a third argument to the hasOne method:
return $this->hasOne(Phone::class, 'foreign_key', 'local_key');

Defining The Inverse Of The Relationship
So, we can access the Phone model from our User model. Next, let's define a relationship on the Phone model that
will let us access the user that owns the phone. We can define the inverse of a hasOne relationship using the
belongsTo method:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Phone extends Model
{
/**
* Get the user that owns the phone.
*/
public function user()
{
return $this->belongsTo(User::class);
}
}

When invoking the user method, Eloquent will attempt to find a User model that has an id which matches the
user_id column on the Phone model.
Eloquent determines the foreign key name by examining the name of the relationship method and suffixing the method
name with _id . So, in this case, Eloquent assumes that the Phone model has a user_id column. However, if the
foreign key on the Phone model is not user_id , you may pass a custom key name as the second argument to the
belongsTo method:
/**
* Get the user that owns the phone.
*/
public function user()
{
return $this->belongsTo(User::class, 'foreign_key');
}

If the parent model does not use id as its primary key, or you wish to find the associated model using a different column,
you may pass a third argument to the belongsTo method specifying the parent table's custom key:

Page 843 of 1307

Laravel 9.x

/**
* Get the user that owns the phone.
*/
public function user()
{
return $this->belongsTo(User::class, 'foreign_key', 'owner_key');
}

One To Many

A one-to-many relationship is used to define relationships where a single model is the parent to one or more child models.
For example, a blog post may have an infinite number of comments. Like all other Eloquent relationships, one-to-many
relationships are defined by defining a method on your Eloquent model:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Post extends Model
{
/**
* Get the comments for the blog post.
*/
public function comments()
{
return $this->hasMany(Comment::class);
}
}

Remember, Eloquent will automatically determine the proper foreign key column for the Comment model. By convention,
Eloquent will take the "snake case" name of the parent model and suffix it with _id . So, in this example, Eloquent will
assume the foreign key column on the Comment model is post_id .
Once the relationship method has been defined, we can access the collection of related comments by accessing the
comments property. Remember, since Eloquent provides "dynamic relationship properties", we can access relationship
methods as if they were defined as properties on the model:
use App\Models\Post;
$comments = Post::find(1)->comments;
foreach ($comments as $comment) {
//
}

Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the
comments method and continuing to chain conditions onto the query:
$comment = Post::find(1)->comments()
->where('title', 'foo')
->first();

Page 844 of 1307

Laravel 9.x

Like the hasOne method, you may also override the foreign and local keys by passing additional arguments to the
hasMany method:
return $this->hasMany(Comment::class, 'foreign_key');
return $this->hasMany(Comment::class, 'foreign_key', 'local_key');

One To Many (Inverse) / Belongs To

Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post.
To define the inverse of a hasMany relationship, define a relationship method on the child model which calls the
belongsTo method:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Comment extends Model
{
/**
* Get the post that owns the comment.
*/
public function post()
{
return $this->belongsTo(Post::class);
}
}

Once the relationship has been defined, we can retrieve a comment's parent post by accessing the post "dynamic
relationship property":
use App\Models\Comment;
$comment = Comment::find(1);
return $comment->post->title;

In the example above, Eloquent will attempt to find a Post model that has an id which matches the post_id column
on the Comment model.
Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the
method name with a _ followed by the name of the parent model's primary key column. So, in this example, Eloquent will
assume the Post model's foreign key on the comments table is post_id .
However, if the foreign key for your relationship does not follow these conventions, you may pass a custom foreign key
name as the second argument to the belongsTo method:

Page 845 of 1307

Laravel 9.x

/**
* Get the post that owns the comment.
*/
public function post()
{
return $this->belongsTo(Post::class, 'foreign_key');
}

If your parent model does not use id as its primary key, or you wish to find the associated model using a different
column, you may pass a third argument to the belongsTo method specifying your parent table's custom key:
/**
* Get the post that owns the comment.
*/
public function post()
{
return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');
}

Default Models
The belongsTo , hasOne , hasOneThrough , and morphOne relationships allow you to define a default model that will
be returned if the given relationship is null . This pattern is often referred to as the Null Object pattern and can help
remove conditional checks in your code. In the following example, the user relation will return an empty
App\Models\User model if no user is attached to the Post model:
/**
* Get the author of the post.
*/
public function user()
{
return $this->belongsTo(User::class)->withDefault();
}

To populate the default model with attributes, you may pass an array or closure to the withDefault method:

Page 846 of 1307

Laravel 9.x

/**
* Get the author of the post.
*/
public function user()
{
return $this->belongsTo(User::class)->withDefault([
'name' => 'Guest Author',
]);
}
/**
* Get the author of the post.
*/
public function user()
{
return $this->belongsTo(User::class)->withDefault(function ($user, $post) {
$user->name = 'Guest Author';
});
}

Querying Belongs To Relationships
When querying for the children of a "belongs to" relationship, you may manually build the where clause to retrieve the
corresponding Eloquent models:
use App\Models\Post;
$posts = Post::where('user_id', $user->id)->get();

However, you may find it more convenient to use the whereBelongsTo method, which will automatically determine the
proper relationship and foreign key for the given model:
$posts = Post::whereBelongsTo($user)->get();

You may also provide a collection instance to the whereBelongsTo method. When doing so, Laravel will retrieve models
that belong to any of the parent models within the collection:
$users = User::where('vip', true)->get();
$posts = Post::whereBelongsTo($users)->get();

By default, Laravel will determine the relationship associated with the given model based on the class name of the model;
however, you may specify the relationship name manually by providing it as the second argument to the whereBelongsTo
method:
$posts = Post::whereBelongsTo($user, 'author')->get();

Has One Of Many

Sometimes a model may have many related models, yet you want to easily retrieve the "latest" or "oldest" related model of
the relationship. For example, a User model may be related to many Order models, but you want to define a convenient
way to interact with the most recent order the user has placed. You may accomplish this using the hasOne relationship
type combined with the ofMany methods:
Page 847 of 1307

Laravel 9.x

/**
* Get the user's most recent order.
*/
public function latestOrder()
{
return $this->hasOne(Order::class)->latestOfMany();
}

Likewise, you may define a method to retrieve the "oldest", or first, related model of a relationship:
/**
* Get the user's oldest order.
*/
public function oldestOrder()
{
return $this->hasOne(Order::class)->oldestOfMany();
}

By default, the latestOfMany and oldestOfMany methods will retrieve the latest or oldest related model based on the
model's primary key, which must be sortable. However, sometimes you may wish to retrieve a single model from a larger
relationship using a different sorting criteria.
For example, using the ofMany method, you may retrieve the user's most expensive order. The ofMany method accepts
the sortable column as its first argument and which aggregate function ( min or max ) to apply when querying for the
related model:
/**
* Get the user's largest order.
*/
public function largestOrder()
{
return $this->hasOne(Order::class)->ofMany('price', 'max');
}

Because PostgreSQL does not support executing the MAX function against UUID columns, it is not
currently possible to use one-of-many relationships in combination with PostgreSQL UUID
columns.
Advanced Has One Of Many Relationships
It is possible to construct more advanced "has one of many" relationships. For example, a Product model may have
many associated Price models that are retained in the system even after new pricing is published. In addition, new
pricing data for the product may be able to be published in advance to take effect at a future date via a published_at
column.
So, in summary, we need to retrieve the latest published pricing where the published date is not in the future. In addition, if
two prices have the same published date, we will prefer the price with the greatest ID. To accomplish this, we must pass an
array to the ofMany method that contains the sortable columns which determine the latest price. In addition, a closure
will be provided as the second argument to the ofMany method. This closure will be responsible for adding additional
publish date constraints to the relationship query:

Page 848 of 1307

Laravel 9.x

/**
* Get the current pricing for the product.
*/
public function currentPricing()
{
return $this->hasOne(Price::class)->ofMany([
'published_at' => 'max',
'id' => 'max',
], function ($query) {
$query->where('published_at', '<', now());
});
}

Has One Through

The "has-one-through" relationship defines a one-to-one relationship with another model. However, this relationship
indicates that the declaring model can be matched with one instance of another model by proceeding through a third
model.
For example, in a vehicle repair shop application, each Mechanic model may be associated with one Car model, and
each Car model may be associated with one Owner model. While the mechanic and the owner have no direct
relationship within the database, the mechanic can access the owner through the Car model. Let's look at the tables
necessary to define this relationship:
mechanics
id - integer
name - string
cars
id - integer
model - string
mechanic_id - integer
owners
id - integer
name - string
car_id - integer

Now that we have examined the table structure for the relationship, let's define the relationship on the Mechanic model:

Page 849 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Mechanic extends Model
{
/**
* Get the car's owner.
*/
public function carOwner()
{
return $this->hasOneThrough(Owner::class, Car::class);
}
}

The first argument passed to the hasOneThrough method is the name of the final model we wish to access, while the
second argument is the name of the intermediate model.
Or, if the relevant relationships have already been defined on all of the models involved in the relationship, you may fluently
define a "has-one-through" relationship by invoking the through method and supplying the names of those
relationships. For example, if the Mechanic model has a cars relationship and the Car model has an owner
relationship, you may define a "has-one-through" relationship connecting the mechanic and the owner like so:
// String based syntax...
return $this->through('cars')->has('owner');
// Dynamic syntax...
return $this->throughCars()->hasOwner();

Key Conventions
Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to
customize the keys of the relationship, you may pass them as the third and fourth arguments to the hasOneThrough
method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of
the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the
intermediate model:

Page 850 of 1307

Laravel 9.x

class Mechanic extends Model
{
/**
* Get the car's owner.
*/
public function carOwner()
{
return $this->hasOneThrough(
Owner::class,
Car::class,
'mechanic_id', // Foreign key on the cars table...
'car_id', // Foreign key on the owners table...
'id', // Local key on the mechanics table...
'id' // Local key on the cars table...
);
}
}

Or, as discussed earlier, if the relevant relationships have already been defined on all of the models involved in the
relationship, you may fluently define a "has-one-through" relationship by invoking the through method and supplying
the names of those relationships. This approach offers the advantage of reusing the key conventions already defined on
the existing relationships:
// String based syntax...
return $this->through('cars')->has('owner');
// Dynamic syntax...
return $this->throughCars()->hasOwner();

Has Many Through

The "has-many-through" relationship provides a convenient way to access distant relations via an intermediate relation.
For example, let's assume we are building a deployment platform like Laravel Vapor. A Project model might access
many Deployment models through an intermediate Environment model. Using this example, you could easily gather all
deployments for a given project. Let's look at the tables required to define this relationship:
projects
id - integer
name - string
environments
id - integer
project_id - integer
name - string
deployments
id - integer
environment_id - integer
commit_hash - string

Now that we have examined the table structure for the relationship, let's define the relationship on the Project model:

Page 851 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Project extends Model
{
/**
* Get all of the deployments for the project.
*/
public function deployments()
{
return $this->hasManyThrough(Deployment::class, Environment::class);
}
}

The first argument passed to the hasManyThrough method is the name of the final model we wish to access, while the
second argument is the name of the intermediate model.
Or, if the relevant relationships have already been defined on all of the models involved in the relationship, you may fluently
define a "has-many-through" relationship by invoking the through method and supplying the names of those
relationships. For example, if the Project model has a environments relationship and the Environment model has a
deployments relationship, you may define a "has-many-through" relationship connecting the project and the
deployments like so:
// String based syntax...
return $this->through('environments')->has('deployments');
// Dynamic syntax...
return $this->throughEnvironments()->hasDeployments();

Though the Deployment model's table does not contain a project_id column, the hasManyThrough relation
provides access to a project's deployments via $project->deployments . To retrieve these models, Eloquent inspects
the project_id column on the intermediate Environment model's table. After finding the relevant environment IDs,
they are used to query the Deployment model's table.
Key Conventions
Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to
customize the keys of the relationship, you may pass them as the third and fourth arguments to the hasManyThrough
method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of
the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the
intermediate model:

Page 852 of 1307

Laravel 9.x

class Project extends Model
{
public function deployments()
{
return $this->hasManyThrough(
Deployment::class,
Environment::class,
'project_id', // Foreign key on the environments table...
'environment_id', // Foreign key on the deployments table...
'id', // Local key on the projects table...
'id' // Local key on the environments table...
);
}
}

Or, as discussed earlier, if the relevant relationships have already been defined on all of the models involved in the
relationship, you may fluently define a "has-many-through" relationship by invoking the through method and supplying
the names of those relationships. This approach offers the advantage of reusing the key conventions already defined on
the existing relationships:
// String based syntax...
return $this->through('environments')->has('deployments');
// Dynamic syntax...
return $this->throughEnvironments()->hasDeployments();

Many To Many Relationships

Many-to-many relations are slightly more complicated than hasOne and hasMany relationships. An example of a manyto-many relationship is a user that has many roles and those roles are also shared by other users in the application. For
example, a user may be assigned the role of "Author" and "Editor"; however, those roles may also be assigned to other
users as well. So, a user has many roles and a role has many users.
Table Structure
To define this relationship, three database tables are needed: users , roles , and role_user . The role_user table
is derived from the alphabetical order of the related model names and contains user_id and role_id columns. This
table is used as an intermediate table linking the users and roles.
Remember, since a role can belong to many users, we cannot simply place a user_id column on the roles table. This
would mean that a role could only belong to a single user. In order to provide support for roles being assigned to multiple
users, the role_user table is needed. We can summarize the relationship's table structure like so:
users
id - integer
name - string
roles
id - integer
name - string
role_user
user_id - integer
role_id - integer

Page 853 of 1307

Laravel 9.x

Model Structure
Many-to-many relationships are defined by writing a method that returns the result of the belongsToMany method. The
belongsToMany method is provided by the Illuminate\Database\Eloquent\Model base class that is used by all of
your application's Eloquent models. For example, let's define a roles method on our User model. The first argument
passed to this method is the name of the related model class:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* The roles that belong to the user.
*/
public function roles()
{
return $this->belongsToMany(Role::class);
}
}

Once the relationship is defined, you may access the user's roles using the roles dynamic relationship property:
use App\Models\User;
$user = User::find(1);
foreach ($user->roles as $role) {
//
}

Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the
roles method and continuing to chain conditions onto the query:
$roles = User::find(1)->roles()->orderBy('name')->get();

To determine the table name of the relationship's intermediate table, Eloquent will join the two related model names in
alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the
belongsToMany method:
return $this->belongsToMany(Role::class, 'role_user');

In addition to customizing the name of the intermediate table, you may also customize the column names of the keys on
the table by passing additional arguments to the belongsToMany method. The third argument is the foreign key name of
the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that
you are joining to:
return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');

Defining The Inverse Of The Relationship
Page 854 of 1307

Laravel 9.x

To define the "inverse" of a many-to-many relationship, you should define a method on the related model which also
returns the result of the belongsToMany method. To complete our user / role example, let's define the users method
on the Role model:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Role extends Model
{
/**
* The users that belong to the role.
*/
public function users()
{
return $this->belongsToMany(User::class);
}
}

As you can see, the relationship is defined exactly the same as its User model counterpart with the exception of
referencing the App\Models\User model. Since we're reusing the belongsToMany method, all of the usual table and
key customization options are available when defining the "inverse" of many-to-many relationships.

Retrieving Intermediate Table Columns

As you have already learned, working with many-to-many relations requires the presence of an intermediate table.
Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our User model has
many Role models that it is related to. After accessing this relationship, we may access the intermediate table using the
pivot attribute on the models:
use App\Models\User;
$user = User::find(1);
foreach ($user->roles as $role) {
echo $role->pivot->created_at;
}

Notice that each Role model we retrieve is automatically assigned a pivot attribute. This attribute contains a model
representing the intermediate table.
By default, only the model keys will be present on the pivot model. If your intermediate table contains extra attributes,
you must specify them when defining the relationship:
return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');

If you would like your intermediate table to have created_at and updated_at timestamps that are automatically
maintained by Eloquent, call the withTimestamps method when defining the relationship:
return $this->belongsToMany(Role::class)->withTimestamps();

Page 855 of 1307

Laravel 9.x

Intermediate tables that utilize Eloquent's automatically maintained timestamps are required to
have both created_at and updated_at timestamp columns.
Customizing The pivot Attribute Name
As noted previously, attributes from the intermediate table may be accessed on models via the pivot attribute. However,
you are free to customize the name of this attribute to better reflect its purpose within your application.
For example, if your application contains users that may subscribe to podcasts, you likely have a many-to-many
relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table attribute to
subscription instead of pivot . This can be done using the as method when defining the relationship:
return $this->belongsToMany(Podcast::class)
->as('subscription')
->withTimestamps();

Once the custom intermediate table attribute has been specified, you may access the intermediate table data using the
customized name:
$users = User::with('podcasts')->get();
foreach ($users->flatMap->podcasts as $podcast) {
echo $podcast->subscription->created_at;
}

Filtering Queries Via Intermediate Table Columns

You can also filter the results returned by belongsToMany relationship queries using the wherePivot ,
wherePivotIn , wherePivotNotIn , wherePivotBetween , wherePivotNotBetween , wherePivotNull , and
wherePivotNotNull methods when defining the relationship:

Page 856 of 1307

Laravel 9.x

return $this->belongsToMany(Role::class)
->wherePivot('approved', 1);
return $this->belongsToMany(Role::class)
->wherePivotIn('priority', [1, 2]);
return $this->belongsToMany(Role::class)
->wherePivotNotIn('priority', [1, 2]);
return $this->belongsToMany(Podcast::class)
->as('subscriptions')
->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31
00:00:00']);
return $this->belongsToMany(Podcast::class)
->as('subscriptions')
->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31
00:00:00']);
return $this->belongsToMany(Podcast::class)
->as('subscriptions')
->wherePivotNull('expired_at');
return $this->belongsToMany(Podcast::class)
->as('subscriptions')
->wherePivotNotNull('expired_at');

Ordering Queries Via Intermediate Table Columns

You can order the results returned by belongsToMany relationship queries using the orderByPivot method. In the
following example, we will retrieve all of the latest badges for the user:
return $this->belongsToMany(Badge::class)
->where('rank', 'gold')
->orderByPivot('created_at', 'desc');

Defining Custom Intermediate Table Models

If you would like to define a custom model to represent the intermediate table of your many-to-many relationship, you may
call the using method when defining the relationship. Custom pivot models give you the opportunity to define additional
behavior on the pivot model, such as methods and casts.
Custom many-to-many pivot models should extend the Illuminate\Database\Eloquent\Relations\Pivot class while
custom polymorphic many-to-many pivot models should extend the
Illuminate\Database\Eloquent\Relations\MorphPivot class. For example, we may define a Role model which
uses a custom RoleUser pivot model:

Page 857 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Role extends Model
{
/**
* The users that belong to the role.
*/
public function users()
{
return $this->belongsToMany(User::class)->using(RoleUser::class);
}
}

When defining the RoleUser model, you should extend the Illuminate\Database\Eloquent\Relations\Pivot
class:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Relations\Pivot;
class RoleUser extends Pivot
{
//
}

Pivot models may not use the SoftDeletes trait. If you need to soft delete pivot records consider
converting your pivot model to an actual Eloquent model.
Custom Pivot Models And Incrementing IDs
If you have defined a many-to-many relationship that uses a custom pivot model, and that pivot model has an autoincrementing primary key, you should ensure your custom pivot model class defines an incrementing property that is
set to true .
/**
* Indicates if the IDs are auto-incrementing.
*
* @var bool
*/
public $incrementing = true;

Polymorphic Relationships

A polymorphic relationship allows the child model to belong to more than one type of model using a single association. For
example, imagine you are building an application that allows users to share blog posts and videos. In such an application, a
Page 858 of 1307

Laravel 9.x

Comment

model might belong to both the Post and Video models.

One To One (Polymorphic)

Table Structure
A one-to-one polymorphic relation is similar to a typical one-to-one relation; however, the child model can belong to more
than one type of model using a single association. For example, a blog Post and a User may share a polymorphic
relation to an Image model. Using a one-to-one polymorphic relation allows you to have a single table of unique images
that may be associated with posts and users. First, let's examine the table structure:
posts
id - integer
name - string
users
id - integer
name - string
images
id - integer
url - string
imageable_id - integer
imageable_type - string

Note the imageable_id and imageable_type columns on the images table. The imageable_id column will
contain the ID value of the post or user, while the imageable_type column will contain the class name of the parent
model. The imageable_type column is used by Eloquent to determine which "type" of parent model to return when
accessing the imageable relation. In this case, the column would contain either App\Models\Post or
App\Models\User .
Model Structure
Next, let's examine the model definitions needed to build this relationship:

Page 859 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Image extends Model
{
/**
* Get the parent imageable model (user or post).
*/
public function imageable()
{
return $this->morphTo();
}
}
class Post extends Model
{
/**
* Get the post's image.
*/
public function image()
{
return $this->morphOne(Image::class, 'imageable');
}
}
class User extends Model
{
/**
* Get the user's image.
*/
public function image()
{
return $this->morphOne(Image::class, 'imageable');
}
}

Retrieving The Relationship
Once your database table and models are defined, you may access the relationships via your models. For example, to
retrieve the image for a post, we can access the image dynamic relationship property:
use App\Models\Post;
$post = Post::find(1);
$image = $post->image;

You may retrieve the parent of the polymorphic model by accessing the name of the method that performs the call to
morphTo . In this case, that is the imageable method on the Image model. So, we will access that method as a
dynamic relationship property:

Page 860 of 1307

Laravel 9.x

use App\Models\Image;
$image = Image::find(1);
$imageable = $image->imageable;

The imageable relation on the Image model will return either a Post or User instance, depending on which type of
model owns the image.
Key Conventions
If necessary, you may specify the name of the "id" and "type" columns utilized by your polymorphic child model. If you do
so, ensure that you always pass the name of the relationship as the first argument to the morphTo method. Typically, this
value should match the method name, so you may use PHP's __FUNCTION__ constant:
/**
* Get the model that the image belongs to.
*/
public function imageable()
{
return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');
}

One To Many (Polymorphic)

Table Structure
A one-to-many polymorphic relation is similar to a typical one-to-many relation; however, the child model can belong to
more than one type of model using a single association. For example, imagine users of your application can "comment" on
posts and videos. Using polymorphic relationships, you may use a single comments table to contain comments for both
posts and videos. First, let's examine the table structure required to build this relationship:
posts
id - integer
title - string
body - text
videos
id - integer
title - string
url - string
comments
id - integer
body - text
commentable_id - integer
commentable_type - string

Model Structure
Next, let's examine the model definitions needed to build this relationship:

Page 861 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Comment extends Model
{
/**
* Get the parent commentable model (post or video).
*/
public function commentable()
{
return $this->morphTo();
}
}
class Post extends Model
{
/**
* Get all of the post's comments.
*/
public function comments()
{
return $this->morphMany(Comment::class, 'commentable');
}
}
class Video extends Model
{
/**
* Get all of the video's comments.
*/
public function comments()
{
return $this->morphMany(Comment::class, 'commentable');
}
}

Retrieving The Relationship
Once your database table and models are defined, you may access the relationships via your model's dynamic relationship
properties. For example, to access all of the comments for a post, we can use the comments dynamic property:
use App\Models\Post;
$post = Post::find(1);
foreach ($post->comments as $comment) {
//
}

You may also retrieve the parent of a polymorphic child model by accessing the name of the method that performs the call
to morphTo . In this case, that is the commentable method on the Comment model. So, we will access that method as a
dynamic relationship property in order to access the comment's parent model:
Page 862 of 1307

Laravel 9.x

use App\Models\Comment;
$comment = Comment::find(1);
$commentable = $comment->commentable;

The commentable relation on the Comment model will return either a Post or Video instance, depending on which
type of model is the comment's parent.

One Of Many (Polymorphic)

Sometimes a model may have many related models, yet you want to easily retrieve the "latest" or "oldest" related model of
the relationship. For example, a User model may be related to many Image models, but you want to define a convenient
way to interact with the most recent image the user has uploaded. You may accomplish this using the morphOne
relationship type combined with the ofMany methods:
/**
* Get the user's most recent image.
*/
public function latestImage()
{
return $this->morphOne(Image::class, 'imageable')->latestOfMany();
}

Likewise, you may define a method to retrieve the "oldest", or first, related model of a relationship:
/**
* Get the user's oldest image.
*/
public function oldestImage()
{
return $this->morphOne(Image::class, 'imageable')->oldestOfMany();
}

By default, the latestOfMany and oldestOfMany methods will retrieve the latest or oldest related model based on the
model's primary key, which must be sortable. However, sometimes you may wish to retrieve a single model from a larger
relationship using a different sorting criteria.
For example, using the ofMany method, you may retrieve the user's most "liked" image. The ofMany method accepts
the sortable column as its first argument and which aggregate function ( min or max ) to apply when querying for the
related model:
/**
* Get the user's most popular image.
*/
public function bestImage()
{
return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');
}

Page 863 of 1307

Laravel 9.x

It is possible to construct more advanced "one of many" relationships. For more information, please
consult the has one of many documentation.

Many To Many (Polymorphic)

Table Structure
Many-to-many polymorphic relations are slightly more complicated than "morph one" and "morph many" relationships. For
example, a Post model and Video model could share a polymorphic relation to a Tag model. Using a many-to-many
polymorphic relation in this situation would allow your application to have a single table of unique tags that may be
associated with posts or videos. First, let's examine the table structure required to build this relationship:
posts
id - integer
name - string
videos
id - integer
name - string
tags
id - integer
name - string
taggables
tag_id - integer
taggable_id - integer
taggable_type - string

Before diving into polymorphic many-to-many relationships, you may benefit from reading the
documentation on typical many-to-many relationships.
Model Structure
Next, we're ready to define the relationships on the models. The Post and Video models will both contain a tags
method that calls the morphToMany method provided by the base Eloquent model class.
The morphToMany method accepts the name of the related model as well as the "relationship name". Based on the name
we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as "taggable":

Page 864 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Post extends Model
{
/**
* Get all of the tags for the post.
*/
public function tags()
{
return $this->morphToMany(Tag::class, 'taggable');
}
}

Defining The Inverse Of The Relationship
Next, on the Tag model, you should define a method for each of its possible parent models. So, in this example, we will
define a posts method and a videos method. Both of these methods should return the result of the morphedByMany
method.
The morphedByMany method accepts the name of the related model as well as the "relationship name". Based on the
name we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as "taggable":
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Tag extends Model
{
/**
* Get all of the posts that are assigned this tag.
*/
public function posts()
{
return $this->morphedByMany(Post::class, 'taggable');
}
/**
* Get all of the videos that are assigned this tag.
*/
public function videos()
{
return $this->morphedByMany(Video::class, 'taggable');
}
}

Retrieving The Relationship
Once your database table and models are defined, you may access the relationships via your models. For example, to
access all of the tags for a post, you may use the tags dynamic relationship property:
Page 865 of 1307

Laravel 9.x

use App\Models\Post;
$post = Post::find(1);
foreach ($post->tags as $tag) {
//
}

You may retrieve the parent of a polymorphic relation from the polymorphic child model by accessing the name of the
method that performs the call to morphedByMany . In this case, that is the posts or videos methods on the Tag
model:
use App\Models\Tag;
$tag = Tag::find(1);
foreach ($tag->posts as $post) {
//
}
foreach ($tag->videos as $video) {
//
}

Custom Polymorphic Types

By default, Laravel will use the fully qualified class name to store the "type" of the related model. For instance, given the
one-to-many relationship example above where a Comment model may belong to a Post or a Video model, the default
commentable_type would be either App\Models\Post or App\Models\Video , respectively. However, you may wish
to decouple these values from your application's internal structure.
For example, instead of using the model names as the "type", we may use simple strings such as post and video . By
doing so, the polymorphic "type" column values in our database will remain valid even if the models are renamed:
use Illuminate\Database\Eloquent\Relations\Relation;
Relation::enforceMorphMap([
'post' => 'App\Models\Post',
'video' => 'App\Models\Video',
]);

You may call the enforceMorphMap method in the boot method of your App\Providers\AppServiceProvider class
or create a separate service provider if you wish.
You may determine the morph alias of a given model at runtime using the model's getMorphClass method. Conversely,
you may determine the fully-qualified class name associated with a morph alias using the Relation::getMorphedModel
method:
use Illuminate\Database\Eloquent\Relations\Relation;
$alias = $post->getMorphClass();
$class = Relation::getMorphedModel($alias);

Page 866 of 1307

Laravel 9.x

When adding a "morph map" to your existing application, every morphable *_type column value
in your database that still contains a fully-qualified class will need to be converted to its "map"
name.

Dynamic Relationships

You may use the resolveRelationUsing method to define relations between Eloquent models at runtime. While not
typically recommended for normal application development, this may occasionally be useful when developing Laravel
packages.
The resolveRelationUsing method accepts the desired relationship name as its first argument. The second argument
passed to the method should be a closure that accepts the model instance and returns a valid Eloquent relationship
definition. Typically, you should configure dynamic relationships within the boot method of a service provider:
use App\Models\Order;
use App\Models\Customer;
Order::resolveRelationUsing('customer', function ($orderModel) {
return $orderModel->belongsTo(Customer::class, 'customer_id');
});

When defining dynamic relationships, always provide explicit key name arguments to the Eloquent
relationship methods.

Querying Relations

Since all Eloquent relationships are defined via methods, you may call those methods to obtain an instance of the
relationship without actually executing a query to load the related models. In addition, all types of Eloquent relationships
also serve as query builders, allowing you to continue to chain constraints onto the relationship query before finally
executing the SQL query against your database.
For example, imagine a blog application in which a User model has many associated Post models:

Page 867 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
/**
* Get all of the posts for the user.
*/
public function posts()
{
return $this->hasMany(Post::class);
}
}

You may query the posts relationship and add additional constraints to the relationship like so:
use App\Models\User;
$user = User::find(1);
$user->posts()->where('active', 1)->get();

You are able to use any of the Laravel query builder's methods on the relationship, so be sure to explore the query builder
documentation to learn about all of the methods that are available to you.
Chaining orWhere Clauses After Relationships
As demonstrated in the example above, you are free to add additional constraints to relationships when querying them.
However, use caution when chaining orWhere clauses onto a relationship, as the orWhere clauses will be logically
grouped at the same level as the relationship constraint:
$user->posts()
->where('active', 1)
->orWhere('votes', '>=', 100)
->get();

The example above will generate the following SQL. As you can see, the or clause instructs the query to return any user
with greater than 100 votes. The query is no longer constrained to a specific user:
select *
from posts
where user_id = ? and active = 1 or votes >= 100

In most situations, you should use logical groups to group the conditional checks between parentheses:

Page 868 of 1307

Laravel 9.x

use Illuminate\Database\Eloquent\Builder;
$user->posts()
->where(function (Builder $query) {
return $query->where('active', 1)
->orWhere('votes', '>=', 100);
})
->get();

The example above will produce the following SQL. Note that the logical grouping has properly grouped the constraints
and the query remains constrained to a specific user:
select *
from posts
where user_id = ? and (active = 1 or votes >= 100)

Relationship Methods Vs. Dynamic Properties

If you do not need to add additional constraints to an Eloquent relationship query, you may access the relationship as if it
were a property. For example, continuing to use our User and Post example models, we may access all of a user's
posts like so:
use App\Models\User;
$user = User::find(1);
foreach ($user->posts as $post) {
//
}

Dynamic relationship properties perform "lazy loading", meaning they will only load their relationship data when you
actually access them. Because of this, developers often use eager loading to pre-load relationships they know will be
accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to
load a model's relations.

Querying Relationship Existence

When retrieving model records, you may wish to limit your results based on the existence of a relationship. For example,
imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the
relationship to the has and orHas methods:
use App\Models\Post;
// Retrieve all posts that have at least one comment...
$posts = Post::has('comments')->get();

You may also specify an operator and count value to further customize the query:
// Retrieve all posts that have three or more comments...
$posts = Post::has('comments', '>=', 3)->get();

Nested has statements may be constructed using "dot" notation. For example, you may retrieve all posts that have at
least one comment that has at least one image:
Page 869 of 1307

Laravel 9.x

// Retrieve posts that have at least one comment with images...
$posts = Post::has('comments.images')->get();

If you need even more power, you may use the whereHas and orWhereHas methods to define additional query
constraints on your has queries, such as inspecting the content of a comment:
use Illuminate\Database\Eloquent\Builder;
// Retrieve posts with at least one comment containing words like code%...
$posts = Post::whereHas('comments', function (Builder $query) {
$query->where('content', 'like', 'code%');
})->get();
// Retrieve posts with at least ten comments containing words like code%...
$posts = Post::whereHas('comments', function (Builder $query) {
$query->where('content', 'like', 'code%');
}, '>=', 10)->get();

Eloquent does not currently support querying for relationship existence across databases. The
relationships must exist within the same database.
Inline Relationship Existence Queries
If you would like to query for a relationship's existence with a single, simple where condition attached to the relationship
query, you may find it more convenient to use the whereRelation , orWhereRelation , whereMorphRelation , and
orWhereMorphRelation methods. For example, we may query for all posts that have unapproved comments:
use App\Models\Post;
$posts = Post::whereRelation('comments', 'is_approved', false)->get();

Of course, like calls to the query builder's where method, you may also specify an operator:
$posts = Post::whereRelation(
'comments', 'created_at', '>=', now()->subHour()
)->get();

Querying Relationship Absence

When retrieving model records, you may wish to limit your results based on the absence of a relationship. For example,
imagine you want to retrieve all blog posts that don't have any comments. To do so, you may pass the name of the
relationship to the doesntHave and orDoesntHave methods:
use App\Models\Post;
$posts = Post::doesntHave('comments')->get();

If you need even more power, you may use the whereDoesntHave and orWhereDoesntHave methods to add additional
query constraints to your doesntHave queries, such as inspecting the content of a comment:

Page 870 of 1307

Laravel 9.x

use Illuminate\Database\Eloquent\Builder;
$posts = Post::whereDoesntHave('comments', function (Builder $query) {
$query->where('content', 'like', 'code%');
})->get();

You may use "dot" notation to execute a query against a nested relationship. For example, the following query will retrieve
all posts that do not have comments; however, posts that have comments from authors that are not banned will be included
in the results:
use Illuminate\Database\Eloquent\Builder;
$posts = Post::whereDoesntHave('comments.author', function (Builder $query) {
$query->where('banned', 0);
})->get();

Querying Morph To Relationships

To query the existence of "morph to" relationships, you may use the whereHasMorph and whereDoesntHaveMorph
methods. These methods accept the name of the relationship as their first argument. Next, the methods accept the names
of the related models that you wish to include in the query. Finally, you may provide a closure which customizes the
relationship query:
use App\Models\Comment;
use App\Models\Post;
use App\Models\Video;
use Illuminate\Database\Eloquent\Builder;
// Retrieve comments associated to posts or videos with a title like code%...
$comments = Comment::whereHasMorph(
'commentable',
[Post::class, Video::class],
function (Builder $query) {
$query->where('title', 'like', 'code%');
}
)->get();
// Retrieve comments associated to posts with a title not like code%...
$comments = Comment::whereDoesntHaveMorph(
'commentable',
Post::class,
function (Builder $query) {
$query->where('title', 'like', 'code%');
}
)->get();

You may occasionally need to add query constraints based on the "type" of the related polymorphic model. The closure
passed to the whereHasMorph method may receive a $type value as its second argument. This argument allows you to
inspect the "type" of the query that is being built:

Page 871 of 1307

Laravel 9.x

use Illuminate\Database\Eloquent\Builder;
$comments = Comment::whereHasMorph(
'commentable',
[Post::class, Video::class],
function (Builder $query, $type) {
$column = $type === Post::class ? 'content' : 'title';
$query->where($column, 'like', 'code%');
}
)->get();

Querying All Related Models
Instead of passing an array of possible polymorphic models, you may provide * as a wildcard value. This will instruct
Laravel to retrieve all of the possible polymorphic types from the database. Laravel will execute an additional query in order
to perform this operation:
use Illuminate\Database\Eloquent\Builder;
$comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {
$query->where('title', 'like', 'foo%');
})->get();

Aggregating Related Models
Counting Related Models

Sometimes you may want to count the number of related models for a given relationship without actually loading the
models. To accomplish this, you may use the withCount method. The withCount method will place a
{relation}_count attribute on the resulting models:
use App\Models\Post;
$posts = Post::withCount('comments')->get();
foreach ($posts as $post) {
echo $post->comments_count;
}

By passing an array to the withCount method, you may add the "counts" for multiple relations as well as add additional
constraints to the queries:
use Illuminate\Database\Eloquent\Builder;
$posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
$query->where('content', 'like', 'code%');
}])->get();
echo $posts[0]->votes_count;
echo $posts[0]->comments_count;

You may also alias the relationship count result, allowing multiple counts on the same relationship:
Page 872 of 1307

Laravel 9.x

use Illuminate\Database\Eloquent\Builder;
$posts = Post::withCount([
'comments',
'comments as pending_comments_count' => function (Builder $query) {
$query->where('approved', false);
},
])->get();
echo $posts[0]->comments_count;
echo $posts[0]->pending_comments_count;

Deferred Count Loading
Using the loadCount method, you may load a relationship count after the parent model has already been retrieved:
$book = Book::first();
$book->loadCount('genres');

If you need to set additional query constraints on the count query, you may pass an array keyed by the relationships you
wish to count. The array values should be closures which receive the query builder instance:
$book->loadCount(['reviews' => function ($query) {
$query->where('rating', 5);
}])

Relationship Counting & Custom Select Statements
If you're combining withCount with a select statement, ensure that you call withCount after the select method:
$posts = Post::select(['title', 'body'])
->withCount('comments')
->get();

Other Aggregate Functions

In addition to the withCount method, Eloquent provides withMin , withMax , withAvg , withSum , and
withExists methods. These methods will place a {relation}_{function}_{column} attribute on your resulting
models:
use App\Models\Post;
$posts = Post::withSum('comments', 'votes')->get();
foreach ($posts as $post) {
echo $post->comments_sum_votes;
}

If you wish to access the result of the aggregate function using another name, you may specify your own alias:

Page 873 of 1307

Laravel 9.x

$posts = Post::withSum('comments as total_comments', 'votes')->get();
foreach ($posts as $post) {
echo $post->total_comments;
}

Like the loadCount method, deferred versions of these methods are also available. These additional aggregate
operations may be performed on Eloquent models that have already been retrieved:
$post = Post::first();
$post->loadSum('comments', 'votes');

If you're combining these aggregate methods with a select statement, ensure that you call the aggregate methods after
the select method:
$posts = Post::select(['title', 'body'])
->withExists('comments')
->get();

Counting Related Models On Morph To Relationships

If you would like to eager load a "morph to" relationship, as well as related model counts for the various entities that may
be returned by that relationship, you may utilize the with method in combination with the morphTo relationship's
morphWithCount method.
In this example, let's assume that Photo and Post models may create ActivityFeed models. We will assume the
ActivityFeed model defines a "morph to" relationship named parentable that allows us to retrieve the parent
Photo or Post model for a given ActivityFeed instance. Additionally, let's assume that Photo models "have
many" Tag models and Post models "have many" Comment models.
Now, let's imagine we want to retrieve ActivityFeed instances and eager load the parentable parent models for each
ActivityFeed instance. In addition, we want to retrieve the number of tags that are associated with each parent photo
and the number of comments that are associated with each parent post:
use Illuminate\Database\Eloquent\Relations\MorphTo;
$activities = ActivityFeed::with([
'parentable' => function (MorphTo $morphTo) {
$morphTo->morphWithCount([
Photo::class => ['tags'],
Post::class => ['comments'],
]);
}])->get();

Deferred Count Loading
Let's assume we have already retrieved a set of ActivityFeed models and now we would like to load the nested
relationship counts for the various parentable models associated with the activity feeds. You may use the
loadMorphCount method to accomplish this:

Page 874 of 1307

Laravel 9.x

$activities = ActivityFeed::with('parentable')->get();
$activities->loadMorphCount('parentable', [
Photo::class => ['tags'],
Post::class => ['comments'],
]);

Eager Loading

When accessing Eloquent relationships as properties, the related models are "lazy loaded". This means the relationship
data is not actually loaded until you first access the property. However, Eloquent can "eager load" relationships at the time
you query the parent model. Eager loading alleviates the "N + 1" query problem. To illustrate the N + 1 query problem,
consider a Book model that "belongs to" to an Author model:
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Book extends Model
{
/**
* Get the author that wrote the book.
*/
public function author()
{
return $this->belongsTo(Author::class);
}
}

Now, let's retrieve all books and their authors:
use App\Models\Book;
$books = Book::all();
foreach ($books as $book) {
echo $book->author->name;
}

This loop will execute one query to retrieve all of the books within the database table, then another query for each book in
order to retrieve the book's author. So, if we have 25 books, the code above would run 26 queries: one for the original
book, and 25 additional queries to retrieve the author of each book.
Thankfully, we can use eager loading to reduce this operation to just two queries. When building a query, you may specify
which relationships should be eager loaded using the with method:
$books = Book::with('author')->get();
foreach ($books as $book) {
echo $book->author->name;
}

Page 875 of 1307

Laravel 9.x

For this operation, only two queries will be executed - one query to retrieve all of the books and one query to retrieve all of
the authors for all of the books:
select * from books
select * from authors where id in (1, 2, 3, 4, 5, ...)

Eager Loading Multiple Relationships
Sometimes you may need to eager load several different relationships. To do so, just pass an array of relationships to the
with method:
$books = Book::with(['author', 'publisher'])->get();

Nested Eager Loading
To eager load a relationship's relationships, you may use "dot" syntax. For example, let's eager load all of the book's
authors and all of the author's personal contacts:
$books = Book::with('author.contacts')->get();

Alternatively, you may specify nested eager loaded relationships by providing a nested array to the with method, which
can be convenient when eager loading multiple nested relationships:
$books = Book::with([
'author' => [
'contacts',
'publisher',
],
])->get();

Nested Eager Loading morphTo Relationships
If you would like to eager load a morphTo relationship, as well as nested relationships on the various entities that may be
returned by that relationship, you may use the with method in combination with the morphTo relationship's
morphWith method. To help illustrate this method, let's consider the following model:
<?php
use Illuminate\Database\Eloquent\Model;
class ActivityFeed extends Model
{
/**
* Get the parent of the activity feed record.
*/
public function parentable()
{
return $this->morphTo();
}
}

In this example, let's assume Event , Photo , and Post models may create ActivityFeed models. Additionally, let's
assume that Event models belong to a Calendar model, Photo models are associated with Tag models, and
Page 876 of 1307

Laravel 9.x

models belong to an Author model.
Using these model definitions and relationships, we may retrieve ActivityFeed model instances and eager load all
parentable models and their respective nested relationships:
Post

use Illuminate\Database\Eloquent\Relations\MorphTo;
$activities = ActivityFeed::query()
->with(['parentable' => function (MorphTo $morphTo) {
$morphTo->morphWith([
Event::class => ['calendar'],
Photo::class => ['tags'],
Post::class => ['author'],
]);
}])->get();

Eager Loading Specific Columns
You may not always need every column from the relationships you are retrieving. For this reason, Eloquent allows you to
specify which columns of the relationship you would like to retrieve:
$books = Book::with('author:id,name,book_id')->get();

When using this feature, you should always include the id column and any relevant foreign key
columns in the list of columns you wish to retrieve.
Eager Loading By Default
Sometimes you might want to always load some relationships when retrieving a model. To accomplish this, you may define
a $with property on the model:

Page 877 of 1307

Laravel 9.x

<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Book extends Model
{
/**
* The relationships that should always be loaded.
*
* @var array
*/
protected $with = ['author'];
/**
* Get the author that wrote the book.
*/
public function author()
{
return $this->belongsTo(Author::class);
}
/**
* Get the genre of the book.
*/
public function genre()
{
return $this->belongsTo(Genre::class);
}
}

If you would like to remove an item from the $with property for a single query, you may use the without method:
$books = Book::without('author')->get();

If you would like to override all items within the $with property for a single query, you may use the withOnly method:
$books = Book::withOnly('genre')->get();

Constraining Eager Loads

Sometimes you may wish to eager load a relationship but also specify additional query conditions for the eager loading
query. You can accomplish this by passing an array of relationships to the with method where the array key is a
relationship name and the array value is a closure that adds additional constraints to the eager loading query:
use App\Models\User;
$users = User::with(['posts' => function ($query) {
$query->where('title', 'like', '%code%');
}])->get();

In this example, Eloquent will only eager load posts where the post's title column contains the word code . You may
call other query builder methods to further customize the eager loading operation:
Page 878 of 1307

Laravel 9.x

$users = User::with(['posts' => function ($query) {
$query->orderBy('created_at', 'desc');
}])->get();

The limit and take query builder methods may not be used when constraining eager loads.
Constraining Eager Loading Of morphTo Relationships
If you are eager loading a morphTo relationship, Eloquent will run multiple queries to fetch each type of related model.
You may add additional constraints to each of these queries using the MorphTo relation's constrain method:
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Relations\MorphTo;
$comments = Comment::with(['commentable' => function (MorphTo $morphTo) {
$morphTo->constrain([
Post::class => function (Builder $query) {
$query->whereNull('hidden_at');
},
Video::class => function (Builder $query) {
$query->where('type', 'educational');
},
]);
}])->get();

In this example, Eloquent will only eager load posts that have not been hidden and videos that have a type value of
"educational".
Constraining Eager Loads With Relationship Existence
You may sometimes find yourself needing to check for the existence of a relationship while simultaneously loading the
relationship based on the same conditions. For example, you may wish to only retrieve User models that have child
Post models matching a given query condition while also eager loading the matching posts. You may accomplish this
using the withWhereHas method:
use App\Models\User;
$users = User::withWhereHas('posts', function ($query) {
$query->where('featured', true);
})->get();

Lazy Eager Loading

Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this
may be useful if you need to dynamically decide whether to load related models:

Page 879 of 1307

Laravel 9.x

use App\Models\Book;
$books = Book::all();
if ($someCondition) {
$books->load('author', 'publisher');
}

If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the
relationships you wish to load. The array values should be closure instances which receive the query instance:
$author->load(['books' => function ($query) {
$query->orderBy('published_date', 'asc');
}]);

To load a relationship only when it has not already been loaded, use the loadMissing method:
$book->loadMissing('author');

Nested Lazy Eager Loading & morphTo
If you would like to eager load a morphTo relationship, as well as nested relationships on the various entities that may be
returned by that relationship, you may use the loadMorph method.
This method accepts the name of the morphTo relationship as its first argument, and an array of model / relationship
pairs as its second argument. To help illustrate this method, let's consider the following model:
<?php
use Illuminate\Database\Eloquent\Model;
class ActivityFeed extends Model
{
/**
* Get the parent of the activity feed record.
*/
public function parentable()
{
return $this->morphTo();
}
}

In this example, let's assume Event , Photo , and Post models may create ActivityFeed models. Additionally, let's
assume that Event models belong to a Calendar model, Photo models are associated with Tag models, and
Post models belong to an Author model.
Using these model definitions and relationships, we may retrieve ActivityFeed model instances and eager load all
parentable models and their respective nested relationships:

Page 880 of 1307

Laravel 9.x

$activities = ActivityFeed::with('parentable')
->get()
->loadMorph('parentable', [
Event::class => ['calendar'],
Photo::class => ['tags'],
Post::class => ['author'],
]);


As previously discussed, eager loading relationships can often provide significant performance benefits to your
application. Therefore, if you would like, you may instruct Laravel to always prevent the lazy loading of relationships. To
Preventing Lazy Loading
accomplish this, you may invoke the preventLazyLoading method offered by the base Eloquent model class. Typically,
you should call this method within the boot method of your application's AppServiceProvider class.
The preventLazyLoading method accepts an optional boolean argument that indicates if lazy loading should be
prevented. For example, you may wish to only disable lazy loading in non-production environments so that your production
environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code:
use Illuminate\Database\Eloquent\Model;
/**
* Bootstrap any application services.
*
* @return void
*/
public function boot()
{
Model::preventLazyLoading(! $this->app->isProduction());
}

After preventing lazy loading, Eloquent will throw a Illuminate\Database\LazyLoadingViolationException
exception when your application attempts to lazy load any Eloquent relationship.
You may customize the behavior of lazy loading violations using the handleLazyLoadingViolationsUsing method. For
example, using this method, you may instruct lazy loading violations to only be logged instead of interrupting the
application's execution with exceptions:
Model::handleLazyLoadingViolationUsing(function ($model, $relation) {
$class = get_class($model);
info("Attempted to lazy load [{$relation}] on model [{$class}].");
});

Inserting & Updating Related Models
The save Method

Eloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to add a
new comment to a post. Instead of manually setting the post_id attribute on the Comment model you may insert the
comment using the relationship's save method:

Page 881 of 1307

Laravel 9.x

use App\Models\Comment;
use App\Models\Post;
$comment = new Comment(['message' => 'A new comment.']);
$post = Post::find(1);
$post->comments()->save($comment);

Note that we did not access the comments relationship as a dynamic property. Instead, we called the comments method
to obtain an instance of the relationship. The save method will automatically add the appropriate post_id value to the
new Comment model.
If you need to save multiple related models, you may use the saveMany method:
$post = Post::find(1);
$post->comments()->saveMany([
new Comment(['message' => 'A new comment.']),
new Comment(['message' => 'Another new comment.']),
]);

The save and saveMany methods will persist the given model instances, but will not add the newly persisted models to
any in-memory relationships that are already loaded onto the parent model. If you plan on accessing the relationship after
using the save or saveMany methods, you may wish to use the refresh method to reload the model and its
relationships:
$post->comments()->save($comment);
$post->refresh();
// All comments, including the newly saved comment...
$post->comments;

Recursively Saving Models & Relationships
If you would like to save your model and all of its associated relationships, you may use the push method. In this
example, the Post model will be saved as well as its comments and the comment's authors:
$post = Post::find(1);
$post->comments[0]->message = 'Message';
$post->comments[0]->author->name = 'Author Name';
$post->push();

The pushQuietly method may be used to save a model and its associated relationships without raising any events:
$post->pushQuietly();

The create Method

Page 882 of 1307

Laravel 9.x

In addition to the save and saveMany methods, you may also use the create method, which accepts an array of
attributes, creates a model, and inserts it into the database. The difference between save and create is that save
accepts a full Eloquent model instance while create accepts a plain PHP array . The newly created model will be
returned by the create method:
use App\Models\Post;
$post = Post::find(1);
$comment = $post->comments()->create([
'message' => 'A new comment.',
]);

You may use the createMany method to create multiple related models:
$post = Post::find(1);
$post->comments()->createMany([
['message' => 'A new comment.'],
['message' => 'Another new comment.'],
]);

You may also use the findOrNew , firstOrNew , firstOrCreate , and updateOrCreate methods to create and
update models on relationships.
Before using the create method, be sure to review the mass assignment documentation.

Belongs To Relationships

If you would like to assign a child model to a new parent model, you may use the associate method. In this example, the
User model defines a belongsTo relationship to the Account model. This associate method will set the foreign
key on the child model:
use App\Models\Account;
$account = Account::find(10);
$user->account()->associate($account);
$user->save();

To remove a parent model from a child model, you may use the dissociate method. This method will set the
relationship's foreign key to null :
$user->account()->dissociate();
$user->save();

Many To Many Relationships
Page 883 of 1307

Laravel 9.x

Attaching / Detaching
Eloquent also provides methods to make working with many-to-many relationships more convenient. For example, let's
imagine a user can have many roles and a role can have many users. You may use the attach method to attach a role to
a user by inserting a record in the relationship's intermediate table:
use App\Models\User;
$user = User::find(1);
$user->roles()->attach($roleId);

When attaching a relationship to a model, you may also pass an array of additional data to be inserted into the intermediate
table:
$user->roles()->attach($roleId, ['expires' => $expires]);

Sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the
detach method. The detach method will delete the appropriate record out of the intermediate table; however, both
models will remain in the database:
// Detach a single role from the user...
$user->roles()->detach($roleId);
// Detach all roles from the user...
$user->roles()->detach();

For convenience, attach and detach also accept arrays of IDs as input:
$user = User::find(1);
$user->roles()->detach([1, 2, 3]);
$user->roles()->attach([
1 => ['expires' => $expires],
2 => ['expires' => $expires],
]);
